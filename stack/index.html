<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>$PHAT â€” Conveyor Munch</title>

  <style>
    :root{
      --bg1:#2b0b4a;
      --bg2:#14051f;
      --glass: rgba(255,255,255,.08);
      --stroke: rgba(255,255,255,.14);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.66);
      --accent:#ffd400;
      --ok:#33ff9a;
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --radius: 22px;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--text);
      background:
        radial-gradient(1100px 700px at 50% -100px, rgba(192,114,255,.35), transparent 60%),
        radial-gradient(900px 600px at 20% 10%, rgba(255,212,0,.14), transparent 55%),
        radial-gradient(900px 600px at 80% 20%, rgba(90,255,200,.10), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow-x:hidden;
      padding: env(safe-area-inset-top) 14px env(safe-area-inset-bottom) 14px;
    }
    .wrap{ max-width: 980px; margin: 0 auto; padding: 12px 0 28px; }

    .topRow{
      display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      margin-bottom: 12px;
    }
    .pillTitle{
      display:flex; align-items:center; gap:10px;
      padding: 10px 14px; border-radius: 999px;
      background: var(--glass); border: 1px solid var(--stroke);
      box-shadow: 0 12px 40px rgba(0,0,0,.22);
      user-select:none;
    }
    .subPill{
      flex: 1 1 420px; min-width: 280px;
      padding: 10px 14px; border-radius: 999px;
      background: var(--glass); border: 1px solid var(--stroke);
      color: var(--muted);
    }
    .btn{
      border:0; padding: 12px 16px; border-radius: 999px;
      font-weight: 900; cursor:pointer; user-select:none;
      box-shadow: var(--shadow); background: var(--accent); color: rgba(0,0,0,.85);
    }
    .btn.secondary{ background: rgba(255,255,255,.10); border: 1px solid var(--stroke); color: var(--text); box-shadow:none; }
    .btn:active{ transform: translateY(1px); }

    .statsRow{
      display:grid; grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px; margin-top: 10px; margin-bottom: 14px;
    }
    @media (max-width: 780px){ .statsRow{ grid-template-columns: 1fr; } .subPill{ flex:1 1 100%; } }

    .card{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: var(--radius);
      padding: 14px 14px;
      box-shadow: 0 18px 60px rgba(0,0,0,.22);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .kicker{ color: var(--muted); font-weight: 800; letter-spacing: .8px; font-size: 12px; }
    .big{ font-size: 34px; font-weight: 950; line-height: 1.0; margin-top: 4px; }
    .mini{ color: var(--muted); margin-top: 4px; font-weight: 700; }

    .stageCard{ padding: 12px; }
    .stage{
      position: relative;
      width: 100%;
      height: min(66vh, 620px);
      min-height: 520px;
      border-radius: calc(var(--radius) + 6px);
      overflow: hidden;
      background:
        radial-gradient(900px 500px at 50% 15%, rgba(255,255,255,.08), transparent 60%),
        radial-gradient(600px 340px at 60% 30%, rgba(255,212,0,.10), transparent 60%),
        linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.40));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 30px 90px rgba(0,0,0,.35);
    }

    .thought{
      position:absolute; left: 50%; top: 8%;
      transform: translateX(-50%);
      width: min(460px, 86%); height: 170px;
      pointer-events:none;
      opacity:.98;
    }
    .thought img{ width:100%; height:100%; object-fit: contain; filter: drop-shadow(0 18px 40px rgba(0,0,0,.35)); }

    .targetIcon{
      position:absolute; left: 50%; top: 10%;
      transform: translateX(-50%);
      width: 110px; height: 110px;
      display:grid; place-items:center; pointer-events:none;
    }
    .targetIcon img{ width: 92px; height: 92px; object-fit: contain; filter: drop-shadow(0 18px 40px rgba(0,0,0,.25)); }
    .targetLabel{
      position:absolute; left: 50%; top: 132px;
      transform: translateX(-50%);
      font-weight: 950; letter-spacing:.3px;
      color: rgba(255,255,255,.88);
      text-shadow: 0 8px 22px rgba(0,0,0,.45);
      pointer-events:none; font-size: 13px;
      white-space: nowrap;
    }

    .character{
      position:absolute; left: 50%; top: 34%;
      transform: translateX(-50%);
      width: min(520px, 92%);
      pointer-events:none;
      filter: drop-shadow(0 22px 60px rgba(0,0,0,.55));
      user-select:none;
    }
    .belt{
      position:absolute; left: 50%; bottom: 5%;
      transform: translateX(-50%);
      width: min(860px, 120%);
      pointer-events:none;
      opacity: .98;
      filter: drop-shadow(0 26px 70px rgba(0,0,0,.55));
      user-select:none;
    }

    .foodItem{
      position:absolute;
      width: 92px; height: 92px;
      left: 0; top: 0;
      transform: translate(-50%, -50%);
      touch-action: none;
      user-select:none;
      cursor: grab;
      filter: drop-shadow(0 18px 40px rgba(0,0,0,.42));
    }
    .foodItem:active{ cursor: grabbing; }

    .floatingBanner{
      position:absolute;
      left:50%; top: 52%;
      transform: translate(-50%, -50%);
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.18);
      font-weight: 950;
      letter-spacing: .6px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .16s ease, transform .16s ease;
      text-align:center;
    }
    .floatingBanner.show{ opacity: 1; transform: translate(-50%, -58%); }

    .mouthHit{
      position:absolute;
      left: 50%; top: 44%;
      width: 92px; height: 72px;
      transform: translate(-50%, -50%);
      border-radius: 999px;
      opacity: 0;
      pointer-events:none;
      background: rgba(51,255,154,.12);
      border: 2px solid rgba(51,255,154,.55);
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
    }
    body.debug .mouthHit{ opacity: 1; }

    .debugPanel{
      margin-top: 12px;
      display:none;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
    }
    body.debug .debugPanel{ display:flex; }
    .tiny{ font-size: 12px; color: var(--muted); font-weight: 800; }
    .chip{
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.14);
      cursor:pointer;
      user-select:none;
      font-weight: 950;
    }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      padding: 10px 14px;
      background: rgba(0,0,0,.65);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 999px;
      color: rgba(255,255,255,.92);
      font-weight: 900;
      opacity: 0;
      pointer-events:none;
      transition: opacity .16s ease, transform .16s ease;
      z-index: 9999;
      text-align:center;
      max-width: 92vw;
    }
    .toast.show{ opacity: 1; transform: translateX(-50%) translateY(-6px); }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topRow">
      <div class="pillTitle" id="titleTap">
        <b>$PHAT â€” Conveyor Munch</b>
        <span class="tiny" id="modeTag" style="margin-left:6px; opacity:.7;"></span>
      </div>
      <div class="subPill">Drag the correct snack (from the thought bubble) into his mouth. Wrong = streak nuked.</div>
      <button class="btn" id="restartBtn">Run it back</button>
      <button class="btn secondary" id="shareBtn">Share score</button>
    </div>

    <div class="statsRow">
      <div class="card">
        <div class="kicker">RUN</div>
        <div class="big"><span id="runCorrect">0</span> <span style="font-size:14px; font-weight:950; opacity:.7;">correct</span></div>
        <div class="mini">Streak: <span id="streak">0</span> â€¢ Mult: <span id="mult">1.00x</span></div>
      </div>
      <div class="card">
        <div class="kicker">BEST</div>
        <div class="big"><span id="best">0</span> <span style="font-size:14px; font-weight:950; opacity:.7;">correct</span></div>
        <div class="mini">Daily best: <span id="dailyBest">0</span></div>
      </div>
      <div class="card">
        <div class="kicker">DAILY GOAL</div>
        <div class="big"><span id="daily">0</span><span style="opacity:.7;"> / </span><span id="goal">30</span></div>
        <div class="mini">Resets in <span id="resetIn">--:--:--</span></div>
      </div>
    </div>

    <div class="card stageCard">
      <div class="stage" id="stage">
        <div class="thought">
          <img src="../assets/thought-bubble.png" alt="Thought bubble" draggable="false">
        </div>

        <div class="targetIcon">
          <img id="targetImg" src="../assets/food_burger.png" alt="Target food" draggable="false">
        </div>
        <div class="targetLabel" id="targetName">BURGER</div>

        <img class="character" id="character" src="../assets/stack_base.png" alt="Seated character" draggable="false">
        <div class="mouthHit" id="mouthHit"></div>

        <img class="belt" id="belt" src="../assets/conveyor.png" alt="Conveyor belt" draggable="false">

        <div class="floatingBanner" id="banner">MISSED</div>
      </div>

      <div class="debugPanel">
        <span class="tiny">Debug mouth align:</span>
        <span class="chip" data-move="-2,0">â—€</span>
        <span class="chip" data-move="2,0">â–¶</span>
        <span class="chip" data-move="0,-2">â–²</span>
        <span class="chip" data-move="0,2">â–¼</span>
        <span class="chip" id="saveMouth">Save</span>
        <span class="tiny" id="mouthPos"></span>
      </div>
    </div>
  </div>

  <div class="toast" id="toast">Saved</div>

  <script>
    const ASSET = (p) => `../assets/${p}`;

    // IMPORTANT: your actual filename is stack_base.png
    const CHARACTER_SRC = ASSET('stack_base.png');

    // Foods (must match your exact /assets filenames)
    const FOODS = [
      { file:'food_brownies.png', label:'BROWNIES' },
      { file:'food_burger.png', label:'BURGER' },
      { file:'food_cake.png', label:'CAKE' },
      { file:'food_chinese_takeout.png', label:'TAKEOUT' },
      { file:'food_cookie_pizza.png', label:'COOKIE PIZZA' },
      { file:'food_donut_stack.png', label:'DONUT STACK' },
      { file:'food_fried_chicken.png', label:'FRIED CHICKEN' },
      { file:'food_fries.png', label:'FRIES' },
      { file:'food_grilledcheese.png', label:'GRILLED CHEESE' },
      { file:'food_hotdogs.png', label:'HOTDOGS' },
      { file:'food_icecream_cone.png', label:'ICE CREAM' },
      { file:'food_milkshake_chocolate.png', label:'CHOC SHAKE' },
      { file:'food_milkshake_strawberry.png', label:'STRAW SHAKE' },
      { file:'food_milkshake_vanilla.png', label:'VANILLA SHAKE' },
      { file:'food_onion_rings.png', label:'ONION RINGS' },
    ];

    const DAILY_GOAL = 30;

    const el = (id) => document.getElementById(id);
    const stage = el('stage');
    const targetImg = el('targetImg');
    const targetName = el('targetName');
    const banner = el('banner');
    const toast = el('toast');

    const runCorrectEl = el('runCorrect');
    const streakEl = el('streak');
    const multEl = el('mult');
    const bestEl = el('best');
    const dailyBestEl = el('dailyBest');
    const dailyEl = el('daily');
    const goalEl = el('goal');
    const resetInEl = el('resetIn');

    const restartBtn = el('restartBtn');
    const shareBtn = el('shareBtn');
    const characterEl = el('character');
    const mouthHit = el('mouthHit');

    // Mouth hitbox offsets from stage center (px)
    const MOUTH_STORAGE_KEY = 'phat_mouth_v2';
    let mouth = { x: 0, y: -10, w: 92, h: 72 };

    // Scrolling conveyor settings
    let beltSpeed = 155;           // px/sec baseline
    let spawnEvery = 650;          // ms baseline
    const maxFoods = 9;            // keep performance good on mobile
    let laneY = 0;
    let leftX = 0, rightX = 0;

    // Game stats
    let runCorrect = 0;
    let streak = 0;
    let mult = 1.0;

    // Daily / best
    const DAY_KEY = () => new Date().toISOString().slice(0,10);
    const LS_BEST = 'phat_conv_best_v2';
    const LS_DAILY = 'phat_conv_daily_v2';
    const LS_DAILYBEST = 'phat_conv_dailybest_v2';

    let dailyDone = 0;
    let dailyBest = 0;
    let bestAll = 0;

    // Target food
    let target = null;

    // Food objects on belt
    // { id, food, x, y, dir, el, isTarget }
    let foods = [];
    let nextId = 1;

    // Dragging
    let dragging = null; // food object
    let dragOffset = {x:0,y:0};

    // Timing
    let lastTime = performance.now();
    let spawnTimer = 0;

    // Debug mode
    let tapCount = 0;
    let debug = false;

    function safeLoadJSON(key, fallback){
      try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; }
      catch{ return fallback; }
    }

    function toastMsg(msg){
      toast.textContent = msg;
      toast.classList.add('show');
      setTimeout(()=>toast.classList.remove('show'), 1100);
    }

    function showBanner(msg){
      banner.textContent = msg;
      banner.classList.add('show');
      setTimeout(()=>banner.classList.remove('show'), 650);
    }

    function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

    function stageMetrics(){
      const r = stage.getBoundingClientRect();
      laneY = r.height * 0.72;
      leftX = r.width * 0.08;
      rightX = r.width * 0.92;
    }

    function setMouth(){
      const r = stage.getBoundingClientRect();
      const cx = r.width/2;
      const cy = r.height/2;

      mouthHit.style.width = mouth.w + 'px';
      mouthHit.style.height = mouth.h + 'px';
      mouthHit.style.left = (cx + mouth.x) + 'px';
      mouthHit.style.top  = (cy + mouth.y) + 'px';

      el('mouthPos').textContent = `x:${mouth.x} y:${mouth.y}`;
    }

    function loadMouth(){
      const saved = safeLoadJSON(MOUTH_STORAGE_KEY, null);
      if(saved && typeof saved.x === 'number') mouth = { ...mouth, ...saved };
    }
    function saveMouth(){
      localStorage.setItem(MOUTH_STORAGE_KEY, JSON.stringify(mouth));
      toastMsg('Mouth saved');
    }

    function setDebugMode(on){
      debug = on;
      document.body.classList.toggle('debug', debug);
      el('modeTag').textContent = debug ? 'DEBUG' : '';
      setMouth();
    }

    function setDifficulty(){
      // speed up with streak
      const s = Math.min(streak, 40);
      beltSpeed = 155 + s * 7.5;

      // spawn faster with streak (more chaos)
      spawnEvery = Math.max(360, 650 - s * 6);

      // multiplier steps
      mult = 1 + Math.floor(streak / 5) * 0.25;
      multEl.textContent = mult.toFixed(2) + 'x';
    }

    function setTarget(){
      target = pick(FOODS);
      targetImg.src = ASSET(target.file);
      targetName.textContent = target.label;
    }

    function loadStats(){
      bestAll = parseInt(localStorage.getItem(LS_BEST) || '0', 10) || 0;

      const dailyObj = safeLoadJSON(LS_DAILY, { day: DAY_KEY(), done: 0 });
      dailyDone = (dailyObj.day === DAY_KEY()) ? (dailyObj.done || 0) : 0;
      localStorage.setItem(LS_DAILY, JSON.stringify({ day: DAY_KEY(), done: dailyDone }));

      const dbObj = safeLoadJSON(LS_DAILYBEST, { day: DAY_KEY(), best: 0 });
      dailyBest = (dbObj.day === DAY_KEY()) ? (dbObj.best || 0) : 0;
      localStorage.setItem(LS_DAILYBEST, JSON.stringify({ day: DAY_KEY(), best: dailyBest }));

      bestEl.textContent = bestAll;
      dailyEl.textContent = dailyDone;
      dailyBestEl.textContent = dailyBest;
      goalEl.textContent = DAILY_GOAL;
    }

    function saveBests(){
      if(runCorrect > bestAll){
        bestAll = runCorrect;
        localStorage.setItem(LS_BEST, String(bestAll));
        bestEl.textContent = bestAll;
      }
      if(runCorrect > dailyBest){
        dailyBest = runCorrect;
        localStorage.setItem(LS_DAILYBEST, JSON.stringify({ day: DAY_KEY(), best: dailyBest }));
        dailyBestEl.textContent = dailyBest;
      }
    }

    function addDaily(){
      dailyDone = Math.min(DAILY_GOAL, dailyDone + 1);
      localStorage.setItem(LS_DAILY, JSON.stringify({ day: DAY_KEY(), done: dailyDone }));
      dailyEl.textContent = dailyDone;
    }

    function secondsToHMS(s){
      const hh = String(Math.floor(s / 3600)).padStart(2,'0');
      const mm = String(Math.floor((s % 3600) / 60)).padStart(2,'0');
      const ss = String(Math.floor(s % 60)).padStart(2,'0');
      return `${hh}:${mm}:${ss}`;
    }

    function updateResetTimer(){
      const now = new Date();
      const next = new Date(now);
      next.setHours(24,0,0,0);
      const diff = Math.max(0, Math.floor((next - now) / 1000));
      resetInEl.textContent = secondsToHMS(diff);
    }

    function placeFoodEl(f){
      f.el.style.left = f.x + 'px';
      f.el.style.top = f.y + 'px';
    }

    function spawnFood(){
      if(foods.length >= maxFoods) return;

      const r = stage.getBoundingClientRect();
      const dir = Math.random() < 0.5 ? 1 : -1;
      const startX = dir === 1 ? (r.width * 0.02) : (r.width * 0.98);

      // Chance to spawn the TARGET food so it actually appears regularly
      const isTarget = Math.random() < 0.30; // 30% are the target
      const food = isTarget ? target : pick(FOODS);

      const img = document.createElement('img');
      img.className = 'foodItem';
      img.src = ASSET(food.file);
      img.alt = food.label;
      img.draggable = false;

      const obj = {
        id: nextId++,
        food,
        isTarget,
        dir,
        x: startX,
        y: laneY,
        el: img
      };

      img.addEventListener('pointerdown', (e)=>pointerDown(e, obj), { passive:false });

      stage.appendChild(img);
      foods.push(obj);
      placeFoodEl(obj);
    }

    function removeFood(obj){
      obj.el.remove();
      foods = foods.filter(f => f.id !== obj.id);
      if(dragging && dragging.id === obj.id) dragging = null;
    }

    function missTarget(){
      // only called when a TARGET food escapes untouched
      streak = 0;
      streakEl.textContent = streak;
      setDifficulty();
      showBanner('MISSED');
    }

    function wrongSnack(){
      streak = 0;
      streakEl.textContent = streak;
      setDifficulty();
      showBanner('WRONG');
    }

    function munch(perfect){
      const base = perfect ? 2 : 1;
      const gained = Math.round(base * mult);

      runCorrect += gained;
      streak += 1;

      runCorrectEl.textContent = runCorrect;
      streakEl.textContent = streak;

      addDaily();
      setDifficulty();
      saveBests();

      showBanner(perfect ? `PERFECT +${gained}` : `NICE +${gained}`);

      // rotate target sometimes to keep it fresh
      if(Math.random() < 0.42) setTarget();
    }

    function hitTestMouth(clientX, clientY){
      const mh = mouthHit.getBoundingClientRect();
      const inside = (clientX >= mh.left && clientX <= mh.right && clientY >= mh.top && clientY <= mh.bottom);
      if(!inside) return { inside:false, perfect:false };

      const cx = (mh.left + mh.right)/2;
      const cy = (mh.top + mh.bottom)/2;
      const dx = clientX - cx, dy = clientY - cy;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const perfect = dist < Math.min(mh.width, mh.height) * 0.22;
      return { inside:true, perfect };
    }

    function pointerDown(e, obj){
      e.preventDefault();
      dragging = obj;
      obj.el.setPointerCapture?.(e.pointerId);

      const fr = obj.el.getBoundingClientRect();
      dragOffset.x = e.clientX - (fr.left + fr.width/2);
      dragOffset.y = e.clientY - (fr.top + fr.height/2);
    }

    function pointerMove(e){
      if(!dragging) return;
      e.preventDefault();

      const sr = stage.getBoundingClientRect();
      dragging.x = (e.clientX - sr.left) - dragOffset.x;
      dragging.y = (e.clientY - sr.top) - dragOffset.y;
      placeFoodEl(dragging);
    }

    function pointerUp(e){
      if(!dragging) return;
      e.preventDefault();

      const dropped = dragging;
      dragging = null;

      const ht = hitTestMouth(e.clientX, e.clientY);
      if(ht.inside){
        // correct?
        if(dropped.food.file === target.file){
          munch(ht.perfect);
          removeFood(dropped);
        }else{
          wrongSnack();
          // snap it back to belt lane (donâ€™t delete)
          dropped.y = laneY;
          placeFoodEl(dropped);
        }
        return;
      }

      // not dropped in mouth -> snap back to belt lane
      dropped.y = laneY;
      placeFoodEl(dropped);
    }

    async function shareScore(){
      const text =
`$PHAT Conveyor Munch
âœ… Correct: ${runCorrect}
ðŸ”¥ Streak: ${streak}
ðŸŽ¯ Daily: ${dailyDone}/${DAILY_GOAL}
Play: planetfatness.fit/stack`;

      try{
        if(navigator.share){
          await navigator.share({ title: '$PHAT â€” Conveyor Munch', text });
          toastMsg('Shared');
        }else{
          await navigator.clipboard.writeText(text);
          toastMsg('Copied');
        }
      }catch{
        try{ await navigator.clipboard.writeText(text); toastMsg('Copied'); }
        catch{ toastMsg('Share blocked'); }
      }
    }

    function resetRun(){
      // wipe belt items
      for(const f of foods){ f.el.remove(); }
      foods = [];
      dragging = null;

      runCorrect = 0;
      streak = 0;
      mult = 1.0;

      runCorrectEl.textContent = runCorrect;
      streakEl.textContent = streak;
      multEl.textContent = mult.toFixed(2) + 'x';

      setTarget();
      setDifficulty();

      spawnTimer = 0;
      lastTime = performance.now();

      // start with a few foods already rolling
      for(let i=0;i<5;i++) spawnFood();
    }

    function tick(now){
      const dt = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;

      spawnTimer += dt * 1000;
      while(spawnTimer >= spawnEvery){
        spawnTimer -= spawnEvery;
        spawnFood();
      }

      const r = stage.getBoundingClientRect();

      for(const f of foods){
        // if not dragging this one, move it
        if(!(dragging && dragging.id === f.id)){
          f.x += (beltSpeed * dt) * f.dir;
          f.y = laneY;
          placeFoodEl(f);
        }

        // escaped?
        const escapedLeft = f.x < r.width * 0.00;
        const escapedRight = f.x > r.width * 1.00;
        if(escapedLeft || escapedRight){
          // only MISS if the escaping one was the TARGET food
          if(f.food.file === target.file){
            missTarget();
          }
          removeFood(f);
          break; // foods array changed, loop safely
        }
      }

      requestAnimationFrame(tick);
    }

    (function boot(){
      // fix character image path
      characterEl.src = CHARACTER_SRC;

      loadMouth();
      loadStats();
      updateResetTimer();
      setInterval(updateResetTimer, 250);

      const onResize = () => {
        stageMetrics();
        setMouth();
        // snap all foods to new lane
        for(const f of foods){
          if(!(dragging && dragging.id === f.id)){
            f.y = laneY;
            placeFoodEl(f);
          }
        }
      };
      window.addEventListener('resize', onResize, { passive:true });
      onResize();

      // global pointer listeners
      window.addEventListener('pointermove', pointerMove, { passive:false });
      window.addEventListener('pointerup', pointerUp, { passive:false });
      window.addEventListener('pointercancel', pointerUp, { passive:false });

      restartBtn.addEventListener('click', () => { saveBests(); resetRun(); toastMsg('Run reset'); });
      shareBtn.addEventListener('click', shareScore);

      // debug toggle: tap title 7 times
      el('titleTap').addEventListener('click', () => {
        tapCount++;
        if(tapCount >= 7){
          tapCount = 0;
          setDebugMode(!debug);
          toastMsg(debug ? 'Debug ON' : 'Debug OFF');
        }
      });

      // debug move chips
      document.querySelectorAll('.chip[data-move]').forEach(chip=>{
        chip.addEventListener('click', ()=>{
          const [dx,dy] = chip.getAttribute('data-move').split(',').map(n=>parseInt(n,10));
          mouth.x += dx; mouth.y += dy;
          setMouth();
        });
      });
      el('saveMouth').addEventListener('click', saveMouth);

      resetRun();
      requestAnimationFrame(tick);
    })();
  </script>
</body>
</html>