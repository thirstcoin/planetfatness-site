<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>$PHAT â€” Conveyor Munch</title>

  <style>
    :root{
      --bg1:#2b0b4a;
      --bg2:#14051f;
      --glass: rgba(255,255,255,.08);
      --stroke: rgba(255,255,255,.14);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.66);
      --accent:#ffd400;
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --radius: 22px;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--text);
      background:
        radial-gradient(1100px 700px at 50% -100px, rgba(192,114,255,.35), transparent 60%),
        radial-gradient(900px 600px at 20% 10%, rgba(255,212,0,.14), transparent 55%),
        radial-gradient(900px 600px at 80% 20%, rgba(90,255,200,.10), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow-x:hidden;
      padding: env(safe-area-inset-top) 14px env(safe-area-inset-bottom) 14px;
    }
    .wrap{ max-width: 980px; margin: 0 auto; padding: 12px 0 28px; }

    .topRow{
      display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      margin-bottom: 12px;
    }
    .pillTitle{
      display:flex; align-items:center; gap:10px;
      padding: 10px 14px; border-radius: 999px;
      background: var(--glass); border: 1px solid var(--stroke);
      box-shadow: 0 12px 40px rgba(0,0,0,.22);
      user-select:none;
    }
    .subPill{
      flex: 1 1 420px; min-width: 280px;
      padding: 10px 14px; border-radius: 999px;
      background: var(--glass); border: 1px solid var(--stroke);
      color: var(--muted);
    }
    .btn{
      border:0; padding: 12px 16px; border-radius: 999px;
      font-weight: 900; cursor:pointer; user-select:none;
      box-shadow: var(--shadow); background: var(--accent); color: rgba(0,0,0,.85);
    }
    .btn.secondary{ background: rgba(255,255,255,.10); border: 1px solid var(--stroke); color: var(--text); box-shadow:none; }
    .btn:active{ transform: translateY(1px); }

    .statsRow{
      display:grid; grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px; margin-top: 10px; margin-bottom: 14px;
    }
    @media (max-width: 780px){ .statsRow{ grid-template-columns: 1fr; } .subPill{ flex:1 1 100%; } }

    .card{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: var(--radius);
      padding: 14px 14px;
      box-shadow: 0 18px 60px rgba(0,0,0,.22);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .kicker{ color: var(--muted); font-weight: 800; letter-spacing: .8px; font-size: 12px; }
    .big{ font-size: 34px; font-weight: 950; line-height: 1.0; margin-top: 4px; }
    .mini{ color: var(--muted); margin-top: 4px; font-weight: 700; }

    .stageCard{ padding: 12px; }
    .stage{
      position: relative;
      width: 100%;
      height: min(66vh, 620px);
      min-height: 520px;
      border-radius: calc(var(--radius) + 6px);
      overflow: hidden;
      background:
        radial-gradient(900px 500px at 50% 15%, rgba(255,255,255,.08), transparent 60%),
        radial-gradient(600px 340px at 60% 30%, rgba(255,212,0,.10), transparent 60%),
        linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.40));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 30px 90px rgba(0,0,0,.35);
    }

    /* Bubble (with fallback background so it never disappears) */
    .thought{
      position:absolute;
      left: 50%;
      top: 3%;
      transform: translateX(-50%);
      width: min(520px, 92%);
      height: 200px;
      z-index: 90;
      pointer-events:none;
    }
    .thought .bubbleImg{
      width:100%;
      height:100%;
      object-fit:contain;
      filter: drop-shadow(0 18px 40px rgba(0,0,0,.35));
      display:block;
    }
    .thought.fallback{
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .thought.fallback::before{
      content:"";
      position:absolute;
      inset: 20px 36px 36px 36px;
      border-radius: 60px;
      background: rgba(255,255,255,.18);
      border: 2px solid rgba(255,255,255,.22);
      filter: drop-shadow(0 18px 40px rgba(0,0,0,.35));
    }

    /* Target inside bubble */
    .thoughtTarget{
      position:absolute;
      left: 50%;
      top: 48%;
      transform: translate(-50%, -50%);
      width: 140px;
      height: 140px;
      display:grid;
      place-items:center;
      z-index: 95;
    }
    .thoughtTarget img{
      width: 112px;
      height: 112px;
      object-fit: contain;
      filter: drop-shadow(0 18px 40px rgba(0,0,0,.35));
    }
    .thoughtLabel{
      position:absolute;
      left: 50%;
      top: 80%;
      transform: translate(-50%, -50%);
      font-weight: 950;
      letter-spacing:.6px;
      color: rgba(255,255,255,.92);
      text-shadow: 0 10px 28px rgba(0,0,0,.55);
      font-size: 13px;
      white-space: nowrap;
      z-index: 96;
    }

    /* Character + belt LOWER than before */
    .character{
      position:absolute;
      left: 50%;
      top: 40%;
      transform: translateX(-50%);
      width: min(560px, 96%);
      z-index: 30;
      pointer-events:none;
      filter: drop-shadow(0 22px 60px rgba(0,0,0,.55));
      user-select:none;
    }
    .belt{
      position:absolute;
      left: 50%;
      bottom: -2%;
      transform: translateX(-50%);
      width: min(900px, 130%);
      z-index: 60;
      pointer-events:none;
      opacity: .98;
      filter: drop-shadow(0 26px 70px rgba(0,0,0,.55));
      user-select:none;
    }

    /* Food ON TOP of belt */
    .foodItem{
      position:absolute;
      width: 82px;
      height: 82px;
      transform: translate(-50%, -50%);
      z-index: 70;
      touch-action:none;
      user-select:none;
      cursor:grab;
      filter: drop-shadow(0 18px 40px rgba(0,0,0,.42));
    }
    .foodItem:active{ cursor:grabbing; }

    .floatingBanner{
      position:absolute;
      left:50%; top: 56%;
      transform: translate(-50%, -50%);
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.18);
      font-weight: 950;
      letter-spacing: .6px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .16s ease, transform .16s ease;
      text-align:center;
      z-index: 110;
    }
    .floatingBanner.show{ opacity: 1; transform: translate(-50%, -58%); }

    .mouthHit{
      position:absolute;
      left: 50%; top: 46%;
      width: 92px; height: 72px;
      transform: translate(-50%, -50%);
      border-radius: 999px;
      opacity: 0;
      pointer-events:none;
      background: rgba(51,255,154,.12);
      border: 2px solid rgba(51,255,154,.55);
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
      z-index: 105;
    }
    body.debug .mouthHit{ opacity: 1; }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      padding: 10px 14px;
      background: rgba(0,0,0,.65);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 999px;
      color: rgba(255,255,255,.92);
      font-weight: 900;
      opacity: 0;
      pointer-events:none;
      transition: opacity .16s ease, transform .16s ease;
      z-index: 9999;
      text-align:center;
      max-width: 92vw;
    }
    .toast.show{ opacity: 1; transform: translateX(-50%) translateY(-6px); }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topRow">
      <div class="pillTitle" id="titleTap">
        <b>$PHAT â€” Conveyor Munch</b>
      </div>
      <div class="subPill">Bubble shows what he wants. Belt runs nonstop. Drag the correct one into his mouth.</div>
      <button class="btn" id="restartBtn">Run it back</button>
      <button class="btn secondary" id="shareBtn">Share score</button>
    </div>

    <div class="statsRow">
      <div class="card">
        <div class="kicker">RUN</div>
        <div class="big"><span id="runCorrect">0</span> <span style="font-size:14px; font-weight:950; opacity:.7;">correct</span></div>
        <div class="mini">Streak: <span id="streak">0</span> â€¢ Mult: <span id="mult">1.00x</span></div>
      </div>
      <div class="card">
        <div class="kicker">BEST</div>
        <div class="big"><span id="best">0</span> <span style="font-size:14px; font-weight:950; opacity:.7;">correct</span></div>
        <div class="mini">Daily best: <span id="dailyBest">0</span></div>
      </div>
      <div class="card">
        <div class="kicker">DAILY GOAL</div>
        <div class="big"><span id="daily">0</span><span style="opacity:.7;"> / </span><span id="goal">30</span></div>
        <div class="mini">Resets in <span id="resetIn">--:--:--</span></div>
      </div>
    </div>

    <div class="card stageCard">
      <div class="stage" id="stage">
        <div class="thought" id="thought">
          <img class="bubbleImg" id="bubbleImg" src="../assets/thought-bubble.png" alt="Thought bubble" draggable="false">
          <div class="thoughtTarget">
            <img id="targetImg" src="../assets/food_burger.png" alt="Target food" draggable="false">
          </div>
          <div class="thoughtLabel" id="targetName">BURGER</div>
        </div>

        <img class="character" id="character" src="../assets/stack_base.png" alt="Seated character" draggable="false">
        <div class="mouthHit" id="mouthHit"></div>

        <img class="belt" id="belt" src="../assets/conveyor.png" alt="Conveyor belt" draggable="false">

        <div class="floatingBanner" id="banner">MISSED</div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast">Saved</div>

  <script>
    const ASSET = (p) => `../assets/${p}`;

    // Foods (must match your /assets list)
    const FOODS = [
      { file:'food_brownies.png', label:'BROWNIES' },
      { file:'food_burger.png', label:'BURGER' },
      { file:'food_cake.png', label:'CAKE' },
      { file:'food_chinese_takeout.png', label:'TAKEOUT' },
      { file:'food_cookie_pizza.png', label:'COOKIE PIZZA' },
      { file:'food_donut_stack.png', label:'DONUT STACK' },
      { file:'food_fried_chicken.png', label:'FRIED CHICKEN' },
      { file:'food_fries.png', label:'FRIES' },
      { file:'food_grilledcheese.png', label:'GRILLED CHEESE' },
      { file:'food_hotdogs.png', label:'HOTDOGS' },
      { file:'food_icecream_cone.png', label:'ICE CREAM' },
      { file:'food_milkshake_chocolate.png', label:'CHOC SHAKE' },
      { file:'food_milkshake_strawberry.png', label:'STRAW SHAKE' },
      { file:'food_milkshake_vanilla.png', label:'VANILLA SHAKE' },
      { file:'food_onion_rings.png', label:'ONION RINGS' },
    ];

    const DAILY_GOAL = 30;

    // PLAYABILITY TUNING (less chaos, no stacking)
    const MAX_FOODS = 9;             // ~7-9 on screen
    const START_FOODS = 6;
    const ITEM_SPACING = 110;        // min px gap between items

    let beltSpeed = 110;             // px/sec (slower)
    let spawnEvery = 520;            // ms (slower)
    const TARGET_GUARANTEE_MS = 1800;

    // Lane is computed from the belt position (fixes "food below belt")
    let laneY = 0;
    let leftX = 0, rightX = 0;

    // Mouth hitbox offsets from stage center (px)
    const MOUTH_STORAGE_KEY = 'phat_mouth_v4';
    let mouth = { x: 0, y: -8, w: 92, h: 72 };

    const el = (id) => document.getElementById(id);
    const stage = el('stage');
    const beltEl = el('belt');
    const thoughtEl = el('thought');
    const bubbleImg = el('bubbleImg');

    const targetImg = el('targetImg');
    const targetName = el('targetName');
    const banner = el('banner');
    const toast = el('toast');

    const runCorrectEl = el('runCorrect');
    const streakEl = el('streak');
    const multEl = el('mult');
    const bestEl = el('best');
    const dailyBestEl = el('dailyBest');
    const dailyEl = el('daily');
    const goalEl = el('goal');
    const resetInEl = el('resetIn');

    const restartBtn = el('restartBtn');
    const shareBtn = el('shareBtn');
    const mouthHit = el('mouthHit');

    // Stats
    let runCorrect = 0;
    let streak = 0;
    let mult = 1.0;

    // Daily / best
    const DAY_KEY = () => new Date().toISOString().slice(0,10);
    const LS_BEST = 'phat_conv_best_v4';
    const LS_DAILY = 'phat_conv_daily_v4';
    const LS_DAILYBEST = 'phat_conv_dailybest_v4';

    let dailyDone = 0;
    let dailyBest = 0;
    let bestAll = 0;

    // Target
    let target = null;

    // Foods on belt
    let foods = [];
    let nextId = 1;

    // Drag
    let dragging = null;
    let dragOffset = {x:0,y:0};

    // Timing
    let lastTime = performance.now();
    let spawnTimer = 0;
    let timeSinceTargetSpawn = 0;

    // Spacing tracking (prevents stacking)
    let lastSpawnX = -9999;

    function shuffle(a){
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
      }
      return a;
    }
    let deck = [];
    function nextFromDeck(){
      if(deck.length === 0) deck = shuffle([...FOODS]);
      return deck.pop();
    }

    function safeLoadJSON(key, fallback){
      try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; }
      catch{ return fallback; }
    }

    function toastMsg(msg){
      toast.textContent = msg;
      toast.classList.add('show');
      setTimeout(()=>toast.classList.remove('show'), 1100);
    }

    function showBanner(msg){
      banner.textContent = msg;
      banner.classList.add('show');
      setTimeout(()=>banner.classList.remove('show'), 650);
    }

    function stageMetrics(){
      const sr = stage.getBoundingClientRect();
      leftX = sr.width * 0.02;
      rightX = sr.width * 0.98;
    }

    function computeLaneFromBelt(){
      const sr = stage.getBoundingClientRect();
      const br = beltEl.getBoundingClientRect();

      // Convert belt rect to stage-local coords
      const beltTop = br.top - sr.top;
      const beltH = br.height;

      // Pick a point on the belt surface (tweakable but stable)
      laneY = beltTop + beltH * 0.62;

      // Clamp safety
      laneY = Math.max(0, Math.min(sr.height, laneY));
    }

    function setMouth(){
      const r = stage.getBoundingClientRect();
      const cx = r.width/2;
      const cy = r.height/2;

      mouthHit.style.width = mouth.w + 'px';
      mouthHit.style.height = mouth.h + 'px';
      mouthHit.style.left = (cx + mouth.x) + 'px';
      mouthHit.style.top  = (cy + mouth.y) + 'px';
    }

    function loadMouth(){
      const saved = safeLoadJSON(MOUTH_STORAGE_KEY, null);
      if(saved && typeof saved.x === 'number') mouth = { ...mouth, ...saved };
    }

    function setTarget(){
      target = nextFromDeck();
      targetImg.src = ASSET(target.file);
      targetName.textContent = target.label;
    }

    function loadStats(){
      bestAll = parseInt(localStorage.getItem(LS_BEST) || '0', 10) || 0;

      const dailyObj = safeLoadJSON(LS_DAILY, { day: DAY_KEY(), done: 0 });
      dailyDone = (dailyObj.day === DAY_KEY()) ? (dailyObj.done || 0) : 0;
      localStorage.setItem(LS_DAILY, JSON.stringify({ day: DAY_KEY(), done: dailyDone }));

      const dbObj = safeLoadJSON(LS_DAILYBEST, { day: DAY_KEY(), best: 0 });
      dailyBest = (dbObj.day === DAY_KEY()) ? (dbObj.best || 0) : 0;
      localStorage.setItem(LS_DAILYBEST, JSON.stringify({ day: DAY_KEY(), best: dailyBest }));

      bestEl.textContent = bestAll;
      dailyEl.textContent = dailyDone;
      dailyBestEl.textContent = dailyBest;
      goalEl.textContent = DAILY_GOAL;
    }

    function saveBests(){
      if(runCorrect > bestAll){
        bestAll = runCorrect;
        localStorage.setItem(LS_BEST, String(bestAll));
        bestEl.textContent = bestAll;
      }
      if(runCorrect > dailyBest){
        dailyBest = runCorrect;
        localStorage.setItem(LS_DAILYBEST, JSON.stringify({ day: DAY_KEY(), best: dailyBest }));
        dailyBestEl.textContent = dailyBest;
      }
    }

    function addDaily(){
      dailyDone = Math.min(DAILY_GOAL, dailyDone + 1);
      localStorage.setItem(LS_DAILY, JSON.stringify({ day: DAY_KEY(), done: dailyDone }));
      dailyEl.textContent = dailyDone;
    }

    function secondsToHMS(s){
      const hh = String(Math.floor(s / 3600)).padStart(2,'0');
      const mm = String(Math.floor((s % 3600) / 60)).padStart(2,'0');
      const ss = String(Math.floor(s % 60)).padStart(2,'0');
      return `${hh}:${mm}:${ss}`;
    }

    function updateResetTimer(){
      const now = new Date();
      const next = new Date(now);
      next.setHours(24,0,0,0);
      const diff = Math.max(0, Math.floor((next - now) / 1000));
      resetInEl.textContent = secondsToHMS(diff);
    }

    function placeFoodEl(f){
      f.el.style.left = f.x + 'px';
      f.el.style.top = f.y + 'px';
    }

    function spawnFood(forceTarget=false){
      if(foods.length >= MAX_FOODS) return;

      const sr = stage.getBoundingClientRect();

      // Spawn only if there is spacing from the last spawn (prevents stacking)
      const startX = leftX - 60;
      if(Math.abs(startX - lastSpawnX) < ITEM_SPACING && foods.length > 0) return;
      lastSpawnX = startX;

      const food = forceTarget ? target : nextFromDeck();

      const img = document.createElement('img');
      img.className = 'foodItem';
      img.src = ASSET(food.file);
      img.alt = food.label;
      img.draggable = false;

      const obj = {
        id: nextId++,
        food,
        x: startX,
        y: laneY,
        el: img
      };

      img.addEventListener('pointerdown', (e)=>pointerDown(e, obj), { passive:false });

      stage.appendChild(img);
      foods.push(obj);
      placeFoodEl(obj);
    }

    function removeFood(obj){
      obj.el.remove();
      foods = foods.filter(f => f.id !== obj.id);
      if(dragging && dragging.id === obj.id) dragging = null;
    }

    function missTarget(){
      streak = 0;
      streakEl.textContent = streak;
      mult = 1.0;
      multEl.textContent = mult.toFixed(2) + 'x';
      showBanner('MISSED');
    }

    function wrongSnack(){
      streak = 0;
      streakEl.textContent = streak;
      mult = 1.0;
      multEl.textContent = mult.toFixed(2) + 'x';
      showBanner('WRONG');
    }

    function munch(perfect){
      const gained = perfect ? 2 : 1;

      runCorrect += gained;
      streak += 1;

      // Mild multiplier only
      mult = 1 + Math.min(1.0, Math.floor(streak / 8) * 0.25);

      runCorrectEl.textContent = runCorrect;
      streakEl.textContent = streak;
      multEl.textContent = mult.toFixed(2) + 'x';

      addDaily();
      saveBests();

      showBanner(perfect ? `PERFECT +${gained}` : `NICE +${gained}`);

      // New target often to keep it fresh
      if(Math.random() < 0.65) setTarget();
    }

    function hitTestMouth(clientX, clientY){
      const mh = mouthHit.getBoundingClientRect();
      const inside = (clientX >= mh.left && clientX <= mh.right && clientY >= mh.top && clientY <= mh.bottom);
      if(!inside) return { inside:false, perfect:false };

      const cx = (mh.left + mh.right)/2;
      const cy = (mh.top + mh.bottom)/2;
      const dx = clientX - cx, dy = clientY - cy;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const perfect = dist < Math.min(mh.width, mh.height) * 0.22;
      return { inside:true, perfect };
    }

    function pointerDown(e, obj){
      e.preventDefault();
      dragging = obj;
      obj.el.setPointerCapture?.(e.pointerId);

      const fr = obj.el.getBoundingClientRect();
      dragOffset.x = e.clientX - (fr.left + fr.width/2);
      dragOffset.y = e.clientY - (fr.top + fr.height/2);
    }

    function pointerMove(e){
      if(!dragging) return;
      e.preventDefault();

      const sr = stage.getBoundingClientRect();
      dragging.x = (e.clientX - sr.left) - dragOffset.x;
      dragging.y = (e.clientY - sr.top) - dragOffset.y;
      placeFoodEl(dragging);
    }

    function pointerUp(e){
      if(!dragging) return;
      e.preventDefault();

      const dropped = dragging;
      dragging = null;

      const ht = hitTestMouth(e.clientX, e.clientY);
      if(ht.inside){
        if(dropped.food.file === target.file){
          munch(ht.perfect);
          removeFood(dropped);
        }else{
          wrongSnack();
          dropped.y = laneY;
          placeFoodEl(dropped);
        }
        return;
      }

      // Snap back to belt lane
      dropped.y = laneY;
      placeFoodEl(dropped);
    }

    async function shareScore(){
      const text =
`$PHAT Conveyor Munch
âœ… Correct: ${runCorrect}
ðŸ”¥ Streak: ${streak}
ðŸŽ¯ Daily: ${dailyDone}/${DAILY_GOAL}
Play: planetfatness.fit/stack`;

      try{
        if(navigator.share){
          await navigator.share({ title: '$PHAT â€” Conveyor Munch', text });
          toastMsg('Shared');
        }else{
          await navigator.clipboard.writeText(text);
          toastMsg('Copied');
        }
      }catch{
        try{ await navigator.clipboard.writeText(text); toastMsg('Copied'); }
        catch{ toastMsg('Share blocked'); }
      }
    }

    function resetRun(){
      for(const f of foods){ f.el.remove(); }
      foods = [];
      dragging = null;

      runCorrect = 0;
      streak = 0;
      mult = 1.0;

      runCorrectEl.textContent = runCorrect;
      streakEl.textContent = streak;
      multEl.textContent = mult.toFixed(2) + 'x';

      deck = [];
      setTarget();

      spawnTimer = 0;
      timeSinceTargetSpawn = 0;
      lastSpawnX = -9999;
      lastTime = performance.now();

      // Start with a few, not a flood
      for(let i=0;i<START_FOODS;i++){
        spawnFood(i === 2);
      }
    }

    function tick(now){
      const dt = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;

      spawnTimer += dt * 1000;
      timeSinceTargetSpawn += dt * 1000;

      const shouldForceTarget = timeSinceTargetSpawn >= TARGET_GUARANTEE_MS;

      while(spawnTimer >= spawnEvery){
        spawnTimer -= spawnEvery;

        if(shouldForceTarget){
          spawnFood(true);
          timeSinceTargetSpawn = 0;
        }else{
          spawnFood(false);
        }
      }

      const sr = stage.getBoundingClientRect();

      for(const f of foods){
        if(!(dragging && dragging.id === f.id)){
          f.x += (beltSpeed * dt);
          f.y = laneY;
          placeFoodEl(f);
        }

        // remove offscreen
        if(f.x > sr.width + 120){
          if(f.food.file === target.file){
            missTarget();
          }
          removeFood(f);
          break;
        }
      }

      requestAnimationFrame(tick);
    }

    function refreshLayout(){
      stageMetrics();
      computeLaneFromBelt();
      setMouth();

      for(const f of foods){
        if(!(dragging && dragging.id === f.id)){
          f.y = laneY;
          placeFoodEl(f);
        }
      }
    }

    (function boot(){
      // Bubble fallback if image fails to load
      bubbleImg.addEventListener('error', ()=>{
        thoughtEl.classList.add('fallback');
        bubbleImg.style.display = 'none';
      });

      loadMouth();
      loadStats();
      updateResetTimer();
      setInterval(updateResetTimer, 250);

      window.addEventListener('resize', refreshLayout, { passive:true });

      // Wait a tick so images have dimensions, then compute lane from belt
      setTimeout(refreshLayout, 60);
      beltEl.addEventListener('load', refreshLayout);

      window.addEventListener('pointermove', pointerMove, { passive:false });
      window.addEventListener('pointerup', pointerUp, { passive:false });
      window.addEventListener('pointercancel', pointerUp, { passive:false });

      restartBtn.addEventListener('click', () => { saveBests(); resetRun(); toastMsg('Run reset'); });
      shareBtn.addEventListener('click', shareScore);

      resetRun();
      requestAnimationFrame(tick);
    })();
  </script>
</body>
</html>