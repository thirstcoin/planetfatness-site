<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>$PHAT — Conveyor Munch</title>
  <style>
    :root{
      --bg1:#2b0f3d;
      --bg2:#13001e;
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --yellow:#f6d84a;
      --yellow2:#f0c92e;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      color:var(--text);
      background:
        radial-gradient(1200px 900px at 35% 10%, rgba(140,86,255,.35), transparent 60%),
        radial-gradient(900px 700px at 70% 40%, rgba(255,92,205,.18), transparent 55%),
        linear-gradient(180deg,var(--bg1),var(--bg2));
      min-height:100vh;
      padding:14px 12px 28px;
    }
    .wrap{max-width:820px;margin:0 auto}
    .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;margin-bottom:12px}
    .pill{
      padding:10px 14px;border-radius:999px;
      background:rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(8px);
      font-weight:800; letter-spacing:.3px;
    }
    .cta{
      background:linear-gradient(180deg,var(--yellow),var(--yellow2));
      color:#160018;border:0;border-radius:14px;
      padding:12px 14px;font-weight:1000;min-width:120px;
      box-shadow:0 10px 26px rgba(0,0,0,.35);
      cursor:pointer;
    }
    .subrow{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:12px}
    .hint{
      flex:1;min-width:220px;
      padding:12px 14px;border-radius:18px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(8px);
      color:var(--muted); line-height:1.25; font-weight:650;
    }
    .btn{
      padding:12px 14px;border-radius:14px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      color:var(--text);font-weight:900;cursor:pointer;min-width:120px;
    }
    .cards{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap:12px;
      margin-bottom:12px;
    }
    .card{
      padding:14px;border-radius:18px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
    }
    .card .k{font-size:12px;color:var(--muted);letter-spacing:.18em;font-weight:1000}
    .card .v{margin-top:6px;font-size:40px;font-weight:1000;line-height:1}
    .card .s{margin-top:6px;color:var(--muted);font-weight:750}
    .gamepanel{
      padding:14px;border-radius:22px;
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
    }
    .stage{
      position:relative;
      width:100%;
      aspect-ratio: 9 / 11;
      max-height: 640px;
      margin:0 auto;
      border-radius:22px;
      overflow:hidden;
      background:
        radial-gradient(900px 700px at 50% 0%, rgba(255,255,255,.08), transparent 55%),
        radial-gradient(700px 600px at 35% 65%, rgba(255,255,255,.05), transparent 60%),
        rgba(0,0,0,.12);
      border:1px solid rgba(255,255,255,.12);
    }

    /* Thought bubble */
    .bubbleWrap{
      position:absolute;
      left:50%;
      top:7%;
      transform:translateX(-50%);
      width:min(62%, 340px);
      z-index:6;
      pointer-events:none;
      text-align:center;
    }
    .bubbleImg{
      width:100%;
      height:auto;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.35));
      opacity:.98;
    }
    .bubbleFood{
      position:absolute;
      left:50%;
      top:48%;
      transform:translate(-50%,-50%);
      width:36%;
      height:auto;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.35));
    }
    .wantLabel{
      margin-top:10px;
      font-weight:1000;
      letter-spacing:.22em;
      opacity:.92;
      text-transform:uppercase;
      text-shadow:0 6px 14px rgba(0,0,0,.45);
    }

    /* Base (your PNG already includes table + plate + seated character) */
    .base{
      position:absolute;
      left:50%;
      top:44%;
      transform:translateX(-50%);
      width:min(78%, 520px);
      height:auto;
      z-index:2;
      filter: drop-shadow(0 18px 26px rgba(0,0,0,.35));
      user-select:none;
      -webkit-user-drag:none;
    }

    /* Belt overlay (slightly lower so food can sit ON it) */
    .belt{
      position:absolute;
      left:50%;
      top:66%;
      transform:translateX(-50%);
      width:min(92%, 650px);
      height:auto;
      z-index:3;
      user-select:none;
      -webkit-user-drag:none;
      pointer-events:none;
      filter: drop-shadow(0 14px 20px rgba(0,0,0,.35));
    }

    .foodsLayer{position:absolute; inset:0; z-index:4; pointer-events:none;}

    .food{
      position:absolute;
      width:66px;
      height:66px;
      object-fit:contain;
      transform:translate(-50%,-50%);
      filter: drop-shadow(0 10px 14px rgba(0,0,0,.35));
      pointer-events:auto;          /* allow drag */
      touch-action:none;
      user-select:none;
      -webkit-user-drag:none;
      cursor:grab;
      will-change: transform, left, top;
    }
    .food.dragging{cursor:grabbing; filter: drop-shadow(0 18px 22px rgba(0,0,0,.45));}

    .toast{
      position:absolute;
      left:50%;
      top:52%;
      transform:translate(-50%,-50%);
      z-index:7;
      padding:10px 14px;
      border-radius:999px;
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.18);
      backdrop-filter: blur(8px);
      font-weight:1000;
      letter-spacing:.14em;
      text-transform:uppercase;
      opacity:0;
      pointer-events:none;
      transition:opacity .15s ease, transform .15s ease;
    }
    .toast.show{opacity:1; transform:translate(-50%,-54%);}

    .how{
      margin-top:12px;
      padding:14px;
      border-radius:18px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      color:var(--muted);
      line-height:1.35;
      font-weight:650;
    }
    .how b{color:rgba(255,255,255,.9)}
    @media (max-width:520px){
      .cards{grid-template-columns:1fr}
      .stage{aspect-ratio: 9/12}
      .food{width:58px;height:58px}
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="pill">$PHAT — Conveyor Munch</div>
    <button class="cta" id="btnReset">Run it back</button>
  </div>

  <div class="subrow">
    <div class="hint">Drag the snack into his mouth. Miss = pain. Streak = glory.</div>
    <button class="btn" id="btnShare">Share score</button>
  </div>

  <div class="cards">
    <div class="card">
      <div class="k">RUN</div>
      <div class="v"><span id="runCorrect">0</span></div>
      <div class="s">Streak: <span id="streak">0</span> · Mult: <span id="mult">1.0x</span></div>
    </div>
    <div class="card">
      <div class="k">BEST</div>
      <div class="v"><span id="best">0</span></div>
      <div class="s">Daily best: <span id="dailyBest">0</span></div>
    </div>
    <div class="card">
      <div class="k">DAILY GOAL</div>
      <div class="v"><span id="goalNow">0</span> / <span id="goalMax">30</span></div>
      <div class="s">Resets in <span id="resetIn">--:--:--</span></div>
    </div>
  </div>

  <div class="gamepanel">
    <div class="stage" id="stage">
      <div class="bubbleWrap" id="bubbleWrap">
        <img class="bubbleImg" src="../assets/thought-bubble.png" alt="thought bubble" draggable="false" />
        <img class="bubbleFood" id="bubbleFood" src="" alt="wanted food" draggable="false" />
        <div class="wantLabel" id="wantLabel">—</div>
      </div>

      <img class="base" id="base" src="../assets/stack_base.png" alt="base" draggable="false" />
      <img class="belt" id="belt" src="../assets/conveyor.png" alt="conveyor" draggable="false" />
      <div class="foodsLayer" id="foodsLayer"></div>

      <div class="toast" id="toast">MISSED</div>
    </div>

    <div class="how">
      <b>How it plays:</b> The thought bubble shows what he wants. The belt feeds a nonstop stream of snacks.
      Grab the correct one <b>between the wrong choices</b> and drag it to his mouth before it rolls away.
    </div>
  </div>
</div>

<script>
(() => {
  const stage = document.getElementById('stage');
  const foodsLayer = document.getElementById('foodsLayer');
  const beltEl = document.getElementById('belt');
  const baseEl = document.getElementById('base');
  const bubbleFoodEl = document.getElementById('bubbleFood');
  const wantLabelEl = document.getElementById('wantLabel');
  const toastEl = document.getElementById('toast');

  const runCorrectEl = document.getElementById('runCorrect');
  const streakEl = document.getElementById('streak');
  const multEl = document.getElementById('mult');
  const bestEl = document.getElementById('best');
  const dailyBestEl = document.getElementById('dailyBest');
  const goalNowEl = document.getElementById('goalNow');
  const goalMaxEl = document.getElementById('goalMax');
  const resetInEl = document.getElementById('resetIn');

  const btnReset = document.getElementById('btnReset');
  const btnShare = document.getElementById('btnShare');

  // Food assets (matches your /assets filenames)
  const FOODS = [
    {key:'brownies', label:'Brownies', src:'../assets/food_brownies.png'},
    {key:'burger', label:'Burger', src:'../assets/food_burger.png'},
    {key:'cake', label:'Cake', src:'../assets/food_cake.png'},
    {key:'chinese_takeout', label:'Takeout', src:'../assets/food_chinese_takeout.png'},
    {key:'cookie_pizza', label:'Cookie Pizza', src:'../assets/food_cookie_pizza.png'},
    {key:'donut_stack', label:'Donut Stack', src:'../assets/food_donut_stack.png'},
    {key:'fried_chicken', label:'Fried Chicken', src:'../assets/food_fried_chicken.png'},
    {key:'fries', label:'Fries', src:'../assets/food_fries.png'},
    {key:'grilledcheese', label:'Grilled Cheese', src:'../assets/food_grilledcheese.png'},
    {key:'hotdogs', label:'Hotdogs', src:'../assets/food_hotdogs.png'},
    {key:'icecream_cone', label:'Ice Cream', src:'../assets/food_icecream_cone.png'},
    {key:'milkshake_chocolate', label:'Choco Shake', src:'../assets/food_milkshake_chocolate.png'},
    {key:'milkshake_strawberry', label:'Strawberry Shake', src:'../assets/food_milkshake_strawberry.png'},
    {key:'milkshake_vanilla', label:'Vanilla Shake', src:'../assets/food_milkshake_vanilla.png'},
    {key:'onion_rings', label:'Onion Rings', src:'../assets/food_onion_rings.png'},
  ];

  // Pressure (tuned so it feels hectic but playable)
  const GOAL_MAX = 30;
  goalMaxEl.textContent = GOAL_MAX;

  const MAX_FOODS_ON_SCREEN = 10;
  const START_FOODS_ON_SCREEN = 7;
  const ITEM_SPACING_PX = 110;
  let beltSpeed = 165;           // px/sec
  let spawnEveryMs = 320;        // ms
  const TARGET_GUARANTEE_MS = 1400;

  // State
  let foods = []; // {id, foodIndex, x, y, el}
  let nextId = 1;

  let laneY = 0;              // where food rides on belt
  let mouth = {x:0,y:0,r:56}; // mouth hit circle

  let lastSpawn = 0;
  let lastTargetSeen = 0;

  let runCorrect = 0;
  let streak = 0;
  let best = 0;

  const LS_KEY = 'phat_conveyor_munch_v4';
  let daily = { day:'', dailyBest:0, goalNow:0, bestAll:0 };

  let targetIndex = 0;

  // Drag state (fixes the “jump up 2 inches”)
  let dragging = null; // {foodObj, offsetX, offsetY, pointerId}

  let raf = 0;
  let lastT = performance.now();

  // Helpers
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function pickRandomIndex(){ return Math.floor(Math.random()*FOODS.length); }

  function getLocalDayKey(){
    const d = new Date();
    return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
  }
  function msUntilMidnight(){
    const n = new Date();
    const t = new Date(n);
    t.setHours(24,0,0,0);
    return t.getTime() - n.getTime();
  }
  function fmtCountdown(ms){
    ms = Math.max(0, ms);
    const s = Math.floor(ms/1000);
    const hh = String(Math.floor(s/3600)).padStart(2,'0');
    const mm = String(Math.floor((s%3600)/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return `${hh}:${mm}:${ss}`;
  }

  function saveDaily(){ localStorage.setItem(LS_KEY, JSON.stringify(daily)); }
  function loadDaily(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(raw) daily = JSON.parse(raw);
    }catch(e){}
    const today = getLocalDayKey();
    if(daily.day !== today){
      daily.day = today;
      daily.dailyBest = 0;
      daily.goalNow = 0;
      daily.bestAll = daily.bestAll || 0;
      saveDaily();
    }
    best = daily.bestAll || 0;
    bestEl.textContent = best;
    dailyBestEl.textContent = daily.dailyBest || 0;
    goalNowEl.textContent = daily.goalNow || 0;
  }

  function showToast(text){
    toastEl.textContent = text;
    toastEl.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toastEl.classList.remove('show'), 520);
  }

  function updateHUD(){
    runCorrectEl.textContent = runCorrect;
    streakEl.textContent = streak;
    const mult = (1 + Math.min(9, Math.floor(streak/5)) * 0.2);
    multEl.textContent = mult.toFixed(1) + 'x';

    if(runCorrect > (daily.dailyBest||0)){
      daily.dailyBest = runCorrect;
      dailyBestEl.textContent = daily.dailyBest;
      saveDaily();
    }
    if(runCorrect > best){
      best = runCorrect;
      daily.bestAll = best;
      bestEl.textContent = best;
      saveDaily();
    }
  }

  // Convert pointer client coords -> stage-local coords
  function pointerToStage(e){
    const sr = stage.getBoundingClientRect();
    return { x: e.clientX - sr.left, y: e.clientY - sr.top, w: sr.width, h: sr.height };
  }

  // Geometry (belt lane + mouth hit)
  function computeLaneFromBelt(){
    const sr = stage.getBoundingClientRect();
    const br = beltEl.getBoundingClientRect();

    const beltTop = br.top - sr.top;
    const beltH = br.height;

    // Food should ride ON the belt surface (lower than before)
    const SURFACE_RATIO = 0.62; // <- pushes items DOWN onto belt
    const SURFACE_NUDGE = -8;

    laneY = beltTop + beltH * SURFACE_RATIO + SURFACE_NUDGE;
    laneY = clamp(laneY, 20, sr.height - 20);
  }

  function computeMouthFromBase(){
    const sr = stage.getBoundingClientRect();
    const br = baseEl.getBoundingClientRect();

    const baseLeft = br.left - sr.left;
    const baseTop = br.top - sr.top;
    const baseW = br.width;
    const baseH = br.height;

    mouth.x = baseLeft + baseW * 0.50;
    mouth.y = baseTop + baseH * 0.30;
    mouth.r = Math.max(42, baseW * 0.08);
  }

  function recomputeAll(){
    computeLaneFromBelt();
    computeMouthFromBase();
    // snap non-dragged foods back onto lane
    foods.forEach(f => { if(!dragging || dragging.foodObj !== f) f.y = laneY; });
  }

  // Target
  function setNewTarget(){
    targetIndex = pickRandomIndex();
    const t = FOODS[targetIndex];
    bubbleFoodEl.src = t.src;
    wantLabelEl.textContent = t.label.toUpperCase();
    lastTargetSeen = performance.now();
  }

  function isTargetOnBelt(){
    return foods.some(f => f.foodIndex === targetIndex);
  }

  // Food
  function renderFood(obj){
    obj.el.style.left = obj.x + 'px';
    obj.el.style.top = obj.y + 'px';
  }

  function removeFood(id){
    const idx = foods.findIndex(f => f.id === id);
    if(idx >= 0){
      const [f] = foods.splice(idx,1);
      try{ f.el.remove(); }catch(e){}
    }
  }

  function spawnFood(forceTarget=false){
    const sr = stage.getBoundingClientRect();
    const spawnX = sr.width + 40;

    // Spacing against rightmost
    if(foods.length){
      const maxX = Math.max(...foods.map(f => f.x));
      if(maxX > spawnX - ITEM_SPACING_PX) return;
    }

    let foodIndex = forceTarget ? targetIndex : pickRandomIndex();

    // avoid repeats
    if(!forceTarget && foods.length){
      const rightmost = foods.slice().sort((a,b)=>a.x-b.x).slice(-1)[0];
      if(rightmost && rightmost.foodIndex === foodIndex) foodIndex = pickRandomIndex();
    }

    const img = document.createElement('img');
    img.className = 'food';
    img.src = FOODS[foodIndex].src;
    img.alt = FOODS[foodIndex].label;
    img.draggable = false;

    const obj = { id: nextId++, foodIndex, x: spawnX, y: laneY, el: img };
    img.dataset.id = obj.id;

    // DRAG (fixed: no jump — offsets are stage-local)
    img.addEventListener('pointerdown', (e) => {
      if(dragging) return;

      const p = pointerToStage(e);
      dragging = {
        foodObj: obj,
        offsetX: obj.x - p.x,
        offsetY: obj.y - p.y,
        pointerId: e.pointerId
      };

      img.classList.add('dragging');
      img.setPointerCapture(e.pointerId);
      e.preventDefault();
      e.stopPropagation();
    });

    img.addEventListener('pointermove', (e) => {
      if(!dragging || dragging.foodObj !== obj) return;
      const p = pointerToStage(e);
      obj.x = clamp(p.x + dragging.offsetX, 10, p.w - 10);
      obj.y = clamp(p.y + dragging.offsetY, 10, p.h - 10);
      renderFood(obj);
      e.preventDefault();
      e.stopPropagation();
    });

    img.addEventListener('pointerup', (e) => {
      if(!dragging || dragging.foodObj !== obj) return;

      img.classList.remove('dragging');
      dragging = null;

      // mouth hit test
      const dx = obj.x - mouth.x;
      const dy = obj.y - mouth.y;
      const dist = Math.hypot(dx,dy);

      if(dist <= mouth.r){
        if(obj.foodIndex === targetIndex){
          runCorrect++;
          streak++;
          daily.goalNow = Math.min(GOAL_MAX, (daily.goalNow||0) + 1);
          goalNowEl.textContent = daily.goalNow;
          saveDaily();
          showToast('NICE');
          removeFood(obj.id);
          setNewTarget();
        }else{
          streak = 0;
          showToast('MISSED');
          obj.y = laneY; // back to belt
        }
        updateHUD();
      }else{
        // snap back to belt lane if dropped elsewhere
        obj.y = laneY;
      }

      renderFood(obj);
      e.preventDefault();
      e.stopPropagation();
    });

    foodsLayer.appendChild(img);
    foods.push(obj);
    renderFood(obj);
  }

  // Loop
  function tick(t){
    const dt = Math.min(0.05, (t - lastT) / 1000);
    lastT = t;

    // Keep lane accurate (belt is image-based; this keeps it aligned after load/scroll/phone UI changes)
    if((t|0) % 400 < 16) recomputeAll();

    // Spawn
    if(t - lastSpawn >= spawnEveryMs){
      lastSpawn = t;

      const needTarget = !isTargetOnBelt() && (t - lastTargetSeen >= TARGET_GUARANTEE_MS);

      if(foods.length < MAX_FOODS_ON_SCREEN){
        spawnFood(needTarget);
        if(needTarget) lastTargetSeen = t;
      }
    }

    // Start pressure quickly
    if(foods.length < START_FOODS_ON_SCREEN){
      for(let i=0;i<2;i++){
        if(foods.length < START_FOODS_ON_SCREEN) spawnFood(false);
      }
    }

    // Move foods along belt (unless dragging)
    for(const f of foods){
      if(dragging && dragging.foodObj === f) continue;
      f.x -= beltSpeed * dt;
      f.y = laneY;
      renderFood(f);
    }

    // Offscreen removal + punish if target slipped away
    const leftKill = -80;
    for(let i=foods.length-1;i>=0;i--){
      const f = foods[i];
      if(f.x < leftKill){
        const wasTarget = (f.foodIndex === targetIndex);
        removeFood(f.id);
        if(wasTarget){
          streak = 0;
          showToast('MISSED');
          updateHUD();
          lastTargetSeen = 0; // bring target back ASAP
        }
      }
    }

    raf = requestAnimationFrame(tick);
  }

  // Reset / Share
  function resetRun(){
    runCorrect = 0;
    streak = 0;
    updateHUD();

    foods.forEach(f => { try{ f.el.remove(); }catch(e){} });
    foods = [];
    dragging = null;

    setNewTarget();

    // IMPORTANT: recompute multiple times to catch iOS layout/image-load timing
    recomputeAll();
    setTimeout(recomputeAll, 150);
    setTimeout(recomputeAll, 600);
    setTimeout(recomputeAll, 1200);

    lastSpawn = 0;
    lastTargetSeen = 0;
  }

  async function shareScore(){
    const text = `$PHAT Conveyor Munch — Run: ${runCorrect} • Streak: ${streak} • Daily: ${daily.goalNow||0}/${GOAL_MAX}\n${location.href}`;
    try{
      if(navigator.share){
        await navigator.share({text});
      }else{
        await navigator.clipboard.writeText(text);
        showToast('COPIED');
      }
    }catch(e){
      try{ await navigator.clipboard.writeText(text); showToast('COPIED'); }catch(_){}
    }
  }

  // Boot
  loadDaily();
  resetRun();

  btnReset.addEventListener('click', resetRun);
  btnShare.addEventListener('click', shareScore);

  function updateCountdown(){
    resetInEl.textContent = fmtCountdown(msUntilMidnight());
    requestAnimationFrame(updateCountdown);
  }
  updateCountdown();

  window.addEventListener('resize', recomputeAll, {passive:true});
  window.addEventListener('orientationchange', () => setTimeout(recomputeAll, 250), {passive:true});
  baseEl.addEventListener('load', recomputeAll);
  beltEl.addEventListener('load', recomputeAll);

  cancelAnimationFrame(raf);
  lastT = performance.now();
  raf = requestAnimationFrame(tick);
})();
</script>
</body>
</html>