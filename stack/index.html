<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>$PHAT — Conveyor Munch</title>
  <style>
    :root{
      --bg1:#1b0b2a;
      --bg2:#3b145c;
      --card: rgba(255,255,255,.06);
      --card2: rgba(255,255,255,.10);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --good:#79ffb0;
      --bad:#ff6a7a;
      --accent:#ffd84d;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--text);
      background: radial-gradient(1000px 600px at 50% 0%, rgba(255,255,255,.10), transparent 60%),
                  linear-gradient(180deg, var(--bg2), var(--bg1));
      min-height:100vh;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
    }
    .wrap{
      max-width: 560px;
      margin: 0 auto;
      padding: 18px 16px 28px;
    }
    .top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom: 12px;
    }
    .pill{
      padding: 10px 14px;
      border-radius: 999px;
      background: var(--card);
      border: 1px solid var(--stroke);
      backdrop-filter: blur(10px);
      font-weight: 700;
      letter-spacing:.3px;
    }
    .btn{
      border:0;
      padding: 10px 14px;
      border-radius: 999px;
      background: var(--accent);
      color: #2a1b00;
      font-weight: 900;
      cursor:pointer;
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    .sub{
      margin: 10px 0 14px;
      padding: 14px 14px;
      border-radius: 18px;
      background: var(--card);
      border: 1px solid var(--stroke);
      backdrop-filter: blur(10px);
      color: var(--muted);
      line-height: 1.25;
    }
    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin-bottom: 14px;
    }
    .stat{
      padding: 12px 12px;
      border-radius: 18px;
      background: var(--card);
      border: 1px solid var(--stroke);
      backdrop-filter: blur(10px);
      min-height: 76px;
    }
    .stat .label{
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 1px;
      font-weight: 800;
    }
    .stat .big{
      font-size: 28px;
      font-weight: 950;
      margin-top: 6px;
      line-height: 1;
    }
    .stat .small{
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    /* Game card */
    .gameCard{
      position:relative;
      border-radius: 26px;
      overflow:hidden;
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border: 1px solid var(--stroke);
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
      padding: 14px;
    }
    .arena{
      position:relative;
      width:100%;
      aspect-ratio: 9 / 13;
      border-radius: 22px;
      overflow:hidden;
      background: radial-gradient(900px 700px at 50% 0%, rgba(255,255,255,.10), transparent 60%),
                  linear-gradient(180deg, rgba(0,0,0,.20), rgba(0,0,0,.45));
      border: 1px solid rgba(255,255,255,.10);
      touch-action: none; /* critical for pointer dragging on mobile */
    }

    /* Scene (your merged character+table+belt image) */
    #scene{
      position:absolute;
      left:50%;
      bottom:0%;
      transform: translateX(-50%);
      width: 132%;
      max-width:none;
      height:auto;
      user-select:none;
      pointer-events:none;
      image-rendering: auto;
    }

    /* Thought bubble + label */
    .thoughtWrap{
      position:absolute;
      left:50%;
      top: 8%;
      transform: translateX(-50%);
      width: 52%;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 6px;
      pointer-events:none;
      user-select:none;
    }
    #thoughtBubble{
      width:100%;
      height:auto;
      display:block;
      filter: drop-shadow(0 12px 18px rgba(0,0,0,.25));
    }
    #thoughtFood{
      position:absolute;
      /* centered inside bubble */
      left:50%;
      top: 46%;
      transform: translate(-50%, -50%);
      width: 42%;
      height:auto;
      filter: drop-shadow(0 10px 14px rgba(0,0,0,.25));
    }
    #thoughtLabel{
      font-weight: 950;
      letter-spacing: 3px;
      font-size: 20px;
      text-align:center;
      text-shadow: 0 10px 18px rgba(0,0,0,.35);
    }

    /* Floating status */
    #toast{
      position:absolute;
      left:50%;
      top: 54%;
      transform: translateX(-50%);
      padding: 10px 16px;
      border-radius: 999px;
      font-weight: 950;
      letter-spacing: 1px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.15);
      backdrop-filter: blur(10px);
      opacity:0;
      transition: opacity .18s ease, transform .18s ease;
      pointer-events:none;
      user-select:none;
    }
    #toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-4px);
    }
    #toast.good{ color: var(--good); }
    #toast.bad{ color: var(--bad); }

    /* Food items */
    .food{
      position:absolute;
      left:0;
      top:0;
      width: 56px;
      height: 56px;
      transform: translate3d(-9999px,-9999px,0);
      will-change: transform;
      user-select:none;
      -webkit-user-drag:none;
      touch-action:none;
      cursor: grab;
      filter: drop-shadow(0 12px 18px rgba(0,0,0,.35));
    }
    .food.dragging{
      cursor: grabbing;
      filter: drop-shadow(0 18px 26px rgba(0,0,0,.45));
      z-index: 50;
    }

    /* Debug overlays (optional) */
    .debugLine{
      position:absolute;
      left:0;
      width:100%;
      height:2px;
      background: rgba(0,255,160,.65);
      pointer-events:none;
      display:none;
    }
    .debugMouth{
      position:absolute;
      border: 2px dashed rgba(0,255,160,.75);
      pointer-events:none;
      display:none;
    }
    .debugOn .debugLine,
    .debugOn .debugMouth{
      display:block;
    }

    .how{
      margin-top: 12px;
      padding: 14px 14px;
      border-radius: 18px;
      background: var(--card);
      border: 1px solid var(--stroke);
      color: var(--muted);
      line-height: 1.35;
    }
    .how b{ color: var(--text); }
    .row{
      display:flex;
      gap:10px;
      margin-top: 10px;
    }
    .ghostBtn{
      flex:1;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.12);
      color: var(--text);
      font-weight: 800;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="pill">$PHAT — Conveyor Munch</div>
      <button class="btn" id="restartBtn">Run it back</button>
    </div>

    <div class="sub">
      Drag the snack into his mouth. Miss = pain. Streak = glory.
    </div>

    <div class="stats">
      <div class="stat">
        <div class="label">RUN</div>
        <div class="big"><span id="runCorrect">0</span></div>
        <div class="small">Streak: <span id="streak">0</span> · Mult: <span id="mult">1.0x</span></div>
      </div>
      <div class="stat">
        <div class="label">BEST</div>
        <div class="big"><span id="best">0</span></div>
        <div class="small">Daily best: <span id="dailyBest">0</span></div>
      </div>
      <div class="stat">
        <div class="label">DAILY GOAL</div>
        <div class="big"><span id="dailyCount">0</span> / 30</div>
        <div class="small">Resets in <span id="resetIn">--:--:--</span></div>
      </div>
    </div>

    <div class="gameCard">
      <div class="arena" id="arena">
        <!-- Thought bubble -->
        <div class="thoughtWrap" id="thoughtWrap">
          <img id="thoughtBubble" src="../assets/thought-bubble.png" alt="thought" />
          <img id="thoughtFood" src="" alt="wanted" />
          <div id="thoughtLabel">---</div>
        </div>

        <!-- Scene (merged character+table+belt) -->
        <img id="scene" src="../assets/stack_scene.png" alt="scene" />

        <!-- Toast -->
        <div id="toast">MISSED</div>

        <!-- Debug overlays -->
        <div class="debugLine" id="debugLine"></div>
        <div class="debugMouth" id="debugMouth"></div>
      </div>

      <div class="row">
        <button class="ghostBtn" id="shareBtn">Share score</button>
        <button class="ghostBtn" id="debugBtn">Toggle debug</button>
      </div>

      <div class="how">
        <b>How it plays:</b> The thought bubble shows what he wants. The belt feeds a nonstop stream of snacks.
        Grab the correct one <b>between the wrong choices</b> and drag it to his mouth before it rolls away.
      </div>
    </div>
  </div>

<script>
(() => {
  /**
   * IMPORTANT PATHS (based on your folder screenshot):
   * stack/index.html  -> uses ../assets/...
   * If you moved the game, update these 3 constants only.
   */
  const PATH_SCENE = "../assets/stack_scene.png";
  const PATH_BUBBLE = "../assets/thought-bubble.png";

  // Your food files (add/remove freely; this is the full pool used).
  const FOODS = [
    { key:"brownies",  label:"BROWNIES",        src:"../assets/food_brownies.png" },
    { key:"burger",    label:"BURGER",          src:"../assets/food_burger.png" },
    { key:"cake",      label:"CAKE",            src:"../assets/food_cake.png" },
    { key:"takeout",   label:"TAKEOUT",         src:"../assets/food_chinese_takeout.png" },
    { key:"cookiepz",  label:"COOKIE PIZZA",    src:"../assets/food_cookie_pizza.png" },
    { key:"donuts",    label:"DONUT STACK",     src:"../assets/food_donut_stack.png" },
    { key:"chicken",   label:"FRIED CHICKEN",   src:"../assets/food_fried_chicken.png" },
    { key:"fries",     label:"FRIES",           src:"../assets/food_fries.png" },
    { key:"grilled",   label:"GRILLED CHEESE",  src:"../assets/food_grilledcheese.png" },
    { key:"hotdogs",   label:"HOTDOGS",         src:"../assets/food_hotdogs.png" },
    { key:"icecream",  label:"ICE CREAM",       src:"../assets/food_icecream_cone.png" },
    { key:"shakechoc", label:"CHOC SHAKE",      src:"../assets/food_milkshake_chocolate.png" },
    { key:"shakestr",  label:"STRAWBERRY SHAKE",src:"../assets/food_milkshake_strawberry.png" },
    { key:"shakevan",  label:"VANILLA SHAKE",   src:"../assets/food_milkshake_vanilla.png" },
    { key:"onion",     label:"ONION RINGS",     src:"../assets/food_onion_rings.png" },
  ];

  // ---- Tunables (these are the “feel” knobs) ----
  // Belt lane and mouth box are percent-based ON THE ARENA (not the whole page).
  // You can toggle Debug and tweak these two values if needed.
  let BELT_Y_PCT = 0.735;      // where foods should ride (top surface of belt)
  let MOUTH = { x: 0.50, y: 0.535, w: 0.17, h: 0.12 }; // drop zone (percent-based)

  // Pressure mode
  const MAX_ONSCREEN = 8;      // ~6–10 feels good
  const SPAWN_EVERY_MS = 720;  // how often new foods appear
  const MIN_SPACING_PX = 56;   // prevents huge overlap on belt
  const DESPAWN_PAD = 120;     // offscreen cleanup

  // Speed (px/sec)
  const BASE_SPEED = 150;
  const SPEED_PER_STREAK = 6;  // ramps pressure
  const MAX_SPEED = 260;

  // Food size relative to arena width
  const FOOD_SIZE_PCT = 0.085; // 0.07–0.10

  // ---- DOM ----
  const arena = document.getElementById("arena");
  const sceneImg = document.getElementById("scene");
  const thoughtFood = document.getElementById("thoughtFood");
  const thoughtLabel = document.getElementById("thoughtLabel");
  const toast = document.getElementById("toast");
  const restartBtn = document.getElementById("restartBtn");
  const shareBtn = document.getElementById("shareBtn");
  const debugBtn = document.getElementById("debugBtn");
  const debugLine = document.getElementById("debugLine");
  const debugMouth = document.getElementById("debugMouth");

  const runCorrectEl = document.getElementById("runCorrect");
  const streakEl = document.getElementById("streak");
  const multEl = document.getElementById("mult");
  const bestEl = document.getElementById("best");
  const dailyBestEl = document.getElementById("dailyBest");
  const dailyCountEl = document.getElementById("dailyCount");
  const resetInEl = document.getElementById("resetIn");

  sceneImg.src = PATH_SCENE;

  // ---- State ----
  let arenaRect = null;
  let beltY = 0;
  let foodSize = 56;
  let mouthRect = null;

  let runCorrect = 0;
  let streak = 0;
  let best = 0;

  let target = null; // current wanted food object

  // foods on belt
  let items = [];
  let lastSpawnAt = 0;
  let lastFrame = performance.now();

  // dragging
  let dragging = null; // { item, offsetX, offsetY }
  let debugOn = false;

  // ---- Storage keys (daily reset) ----
  const todayKey = () => {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${day}`;
  };
  const LS = {
    dailyKey: "phat_stack_daily_key",
    dailyBest: "phat_stack_daily_best",
    dailyCount: "phat_stack_daily_count",
  };

  function loadDaily() {
    const k = localStorage.getItem(LS.dailyKey);
    const t = todayKey();
    if (k !== t) {
      localStorage.setItem(LS.dailyKey, t);
      localStorage.setItem(LS.dailyBest, "0");
      localStorage.setItem(LS.dailyCount, "0");
    }
    dailyBestEl.textContent = Number(localStorage.getItem(LS.dailyBest) || "0");
    dailyCountEl.textContent = Number(localStorage.getItem(LS.dailyCount) || "0");
  }

  function bumpDailyCount() {
    const v = Number(localStorage.getItem(LS.dailyCount) || "0") + 1;
    localStorage.setItem(LS.dailyCount, String(v));
    dailyCountEl.textContent = v;
    const db = Number(localStorage.getItem(LS.dailyBest) || "0");
    if (v > db) {
      localStorage.setItem(LS.dailyBest, String(v));
      dailyBestEl.textContent = v;
    }
  }

  function updateResetTimer() {
    const now = new Date();
    const next = new Date(now);
    next.setHours(24,0,0,0);
    const ms = next - now;
    const s = Math.max(0, Math.floor(ms/1000));
    const hh = String(Math.floor(s/3600)).padStart(2,"0");
    const mm = String(Math.floor((s%3600)/60)).padStart(2,"0");
    const ss = String(s%60).padStart(2,"0");
    resetInEl.textContent = `${hh}:${mm}:${ss}`;
  }

  // ---- Geometry ----
  function recalc() {
    arenaRect = arena.getBoundingClientRect();
    beltY = arenaRect.height * BELT_Y_PCT;

    // food size scales with arena width
    foodSize = Math.max(44, Math.min(84, Math.floor(arenaRect.width * FOOD_SIZE_PCT)));

    // Mouth rect based on arena
    mouthRect = {
      left: arenaRect.left + arenaRect.width * (MOUTH.x - MOUTH.w/2),
      top:  arenaRect.top  + arenaRect.height * (MOUTH.y - MOUTH.h/2),
      width: arenaRect.width * MOUTH.w,
      height: arenaRect.height * MOUTH.h
    };

    // Debug visuals
    debugLine.style.top = `${beltY}px`;
    debugMouth.style.left = `${arenaRect.width * (MOUTH.x - MOUTH.w/2)}px`;
    debugMouth.style.top  = `${arenaRect.height * (MOUTH.y - MOUTH.h/2)}px`;
    debugMouth.style.width  = `${arenaRect.width * MOUTH.w}px`;
    debugMouth.style.height = `${arenaRect.height * MOUTH.h}px`;

    // Resize existing items to new foodSize and snap them to belt lane
    for (const it of items) {
      it.el.style.width = `${foodSize}px`;
      it.el.style.height = `${foodSize}px`;
      if (!it.dragging) {
        it.y = beltY - foodSize * 0.62; // sits on belt surface (tweak if needed)
      }
      renderItem(it);
    }
  }

  // ---- Target selection ----
  function pickTarget() {
    target = FOODS[Math.floor(Math.random() * FOODS.length)];
    thoughtFood.src = target.src;
    thoughtLabel.textContent = target.label;

    // Nudge food slightly up inside bubble (fix “sits low”)
    // (kept in CSS, but this ensures consistent load sizing on mobile)
    thoughtFood.onload = () => { /* no-op */ };
  }

  // ---- Item creation ----
  function createFoodItem(food) {
    const el = document.createElement("img");
    el.className = "food";
    el.draggable = false;
    el.src = food.src;
    el.alt = food.label;

    arena.appendChild(el);

    const it = {
      id: crypto.randomUUID ? crypto.randomUUID() : String(Math.random()),
      food,
      el,
      x: arenaRect.width + 30,
      y: beltY - foodSize * 0.62,
      vx: -getSpeed(),
      dragging: false,
      grabbedAt: 0,
    };

    el.style.width = `${foodSize}px`;
    el.style.height = `${foodSize}px`;

    // Pointer events
    el.addEventListener("pointerdown", (e) => onPointerDown(e, it), { passive: false });
    return it;
  }

  function getSpeed() {
    const s = Math.min(MAX_SPEED, BASE_SPEED + streak * SPEED_PER_STREAK);
    return s;
  }

  // Keep items from stacking on top of each other too much
  function canSpawnAtX(x) {
    for (const it of items) {
      if (it.dragging) continue;
      if (Math.abs(it.x - x) < MIN_SPACING_PX) return false;
    }
    return true;
  }

  // ---- Rendering ----
  function renderItem(it) {
    it.el.style.transform = `translate3d(${it.x}px, ${it.y}px, 0)`;
  }

  // ---- Toast ----
  let toastTimer = null;
  function showToast(text, good) {
    toast.textContent = text;
    toast.classList.remove("good","bad","show");
    toast.classList.add(good ? "good" : "bad");
    // force reflow
    void toast.offsetWidth;
    toast.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toast.classList.remove("show"), 520);
  }

  // ---- Hit testing ----
  function rectsOverlap(a, b) {
    return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);
  }

  function itemRectOnScreen(it) {
    // item's current rect in viewport
    const left = arenaRect.left + it.x;
    const top  = arenaRect.top + it.y;
    return {
      left, top,
      right: left + foodSize,
      bottom: top + foodSize,
      width: foodSize,
      height: foodSize
    };
  }

  // ---- Dragging (fixes “jump up 2 inches”) ----
  function onPointerDown(e, it) {
    e.preventDefault();
    e.stopPropagation();

    // lock geometry
    recalc();

    it.dragging = true;
    it.el.classList.add("dragging");
    it.el.setPointerCapture(e.pointerId);

    const r = itemRectOnScreen(it);
    const offsetX = e.clientX - r.left;
    const offsetY = e.clientY - r.top;

    dragging = { it, offsetX, offsetY, pointerId: e.pointerId };

    // stop belt movement while dragging this one
    it.vx = 0;

    it.el.addEventListener("pointermove", onPointerMove, { passive:false });
    it.el.addEventListener("pointerup", onPointerUp, { passive:false });
    it.el.addEventListener("pointercancel", onPointerUp, { passive:false });
  }

  function onPointerMove(e) {
    if (!dragging) return;
    e.preventDefault();

    // Keep item under finger WITHOUT snapping
    const it = dragging.it;

    const x = e.clientX - arenaRect.left - dragging.offsetX;
    const y = e.clientY - arenaRect.top  - dragging.offsetY;

    it.x = x;
    it.y = y;

    renderItem(it);
  }

  function onPointerUp(e) {
    if (!dragging) return;
    e.preventDefault();

    const it = dragging.it;

    // release listeners
    it.el.removeEventListener("pointermove", onPointerMove);
    it.el.removeEventListener("pointerup", onPointerUp);
    it.el.removeEventListener("pointercancel", onPointerUp);

    it.el.classList.remove("dragging");
    it.dragging = false;

    // Check mouth overlap
    recalc();
    const r = itemRectOnScreen(it);

    const mouth = {
      left: mouthRect.left,
      top: mouthRect.top,
      right: mouthRect.left + mouthRect.width,
      bottom: mouthRect.top + mouthRect.height
    };

    const hit = rectsOverlap(r, mouth);

    if (hit) {
      // Correct if matches target
      if (it.food.key === target.key) {
        runCorrect++;
        streak++;
        best = Math.max(best, runCorrect);
        bumpDailyCount();

        showToast("CHOMP!", true);
        pickTarget();

        // Remove the item
        removeItem(it);
      } else {
        // Wrong food into mouth
        streak = 0;
        showToast("WRONG SNACK", false);
        // Toss it (remove)
        removeItem(it);
      }
    } else {
      // Not dropped on mouth: snap it back onto belt lane at its current x
      it.y = beltY - foodSize * 0.62;
      it.vx = -getSpeed();
      renderItem(it);
    }

    dragging = null;
    updateHUD();
  }

  function removeItem(it) {
    const idx = items.indexOf(it);
    if (idx >= 0) items.splice(idx, 1);
    it.el.remove();
  }

  // ---- Miss logic (when correct target scrolls off screen untouched) ----
  function handleMiss(it) {
    // If the target food goes offscreen without being eaten: miss
    if (it.food.key === target.key) {
      streak = 0;
      showToast("MISSED", false);
      pickTarget();
    }
    removeItem(it);
    updateHUD();
  }

  // ---- HUD ----
  function updateHUD() {
    runCorrectEl.textContent = runCorrect;
    streakEl.textContent = streak;
    const mult = (1 + Math.min(0.9, streak * 0.05)).toFixed(1);
    multEl.textContent = `${mult}x`;
    bestEl.textContent = best;
  }

  // ---- Main loop ----
  function tick(now) {
    const dt = Math.min(0.05, (now - lastFrame) / 1000);
    lastFrame = now;

    // update geometry occasionally (handles iOS UI bar changes)
    // lightweight: just read rect every frame only if needed
    if (!arenaRect) recalc();

    // spawn
    if (!lastSpawnAt) lastSpawnAt = now;
    const canSpawnMore = items.length < MAX_ONSCREEN;

    if (canSpawnMore && now - lastSpawnAt >= SPAWN_EVERY_MS) {
      lastSpawnAt = now;

      // Choose random food. Slightly bias to include target sometimes, but not always.
      const roll = Math.random();
      let f = null;
      if (roll < 0.22) f = target; // 22% chance spawn is the target
      else f = FOODS[Math.floor(Math.random() * FOODS.length)];

      // Spawn at right edge with spacing guard
      const spawnX = arenaRect.width + 24;
      if (canSpawnAtX(spawnX)) {
        const it = createFoodItem(f);
        items.push(it);
      }
    }

    // move items
    for (let i = items.length - 1; i >= 0; i--) {
      const it = items[i];
      if (it.dragging) continue;

      it.vx = -getSpeed();
      it.x += it.vx * dt;

      // lock on belt lane always
      it.y = beltY - foodSize * 0.62;

      renderItem(it);

      // despawn left
      if (it.x < -DESPAWN_PAD) {
        handleMiss(it);
      }
    }

    requestAnimationFrame(tick);
  }

  // ---- Controls ----
  function restart() {
    // clear belt
    for (const it of items) it.el.remove();
    items = [];
    dragging = null;

    runCorrect = 0;
    streak = 0;
    best = 0;

    pickTarget();
    updateHUD();
    showToast("RUN IT", true);
  }

  restartBtn.addEventListener("click", restart);

  shareBtn.addEventListener("click", async () => {
    const daily = Number(localStorage.getItem(LS.dailyCount) || "0");
    const text = `$PHAT Conveyor Munch — Run: ${runCorrect} | Daily: ${daily}/30`;
    try{
      if (navigator.share) await navigator.share({ text });
      else {
        await navigator.clipboard.writeText(text);
        showToast("COPIED", true);
      }
    } catch(_) {}
  });

  debugBtn.addEventListener("click", () => {
    debugOn = !debugOn;
    arena.classList.toggle("debugOn", debugOn);
    showToast(debugOn ? "DEBUG ON" : "DEBUG OFF", true);
  });

  window.addEventListener("resize", () => {
    // iOS can resize when bars collapse/expand
    recalc();
  });

  // Prevent page scroll while playing inside arena
  arena.addEventListener("touchmove", (e) => e.preventDefault(), { passive:false });

  // ---- Init ----
  function preloadImages() {
    const urls = [PATH_SCENE, PATH_BUBBLE, ...FOODS.map(f => f.src)];
    for (const u of urls) {
      const img = new Image();
      img.src = u;
    }
  }

  loadDaily();
  updateResetTimer();
  setInterval(updateResetTimer, 1000);

  preloadImages();
  pickTarget();
  updateHUD();

  // Ensure scene loads then calc
  sceneImg.onload = () => recalc();
  sceneImg.onerror = () => {
    // If scene path is wrong, show a loud toast
    showToast("SCENE PATH WRONG", false);
  };

  // If bubble path wrong, you’ll see broken icon; still playable
  requestAnimationFrame(() => {
    recalc();
    requestAnimationFrame(tick);
  });

})();
</script>
</body>
</html>