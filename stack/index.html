<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>$PHAT — Conveyor Munch</title>
  <style>
    :root{
      --bg1:#2b0f3d;
      --bg2:#13001e;
      --panel:rgba(255,255,255,.06);
      --panel2:rgba(255,255,255,.08);
      --stroke:rgba(255,255,255,.10);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --yellow:#f6d84a;
      --yellow2:#f0c92e;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      color:var(--text);
      background:
        radial-gradient(1200px 900px at 35% 10%, rgba(140,86,255,.35), transparent 60%),
        radial-gradient(900px 700px at 70% 40%, rgba(255,92,205,.18), transparent 55%),
        linear-gradient(180deg,var(--bg1),var(--bg2));
      min-height:100vh;
      padding:14px 12px 28px;
    }
    .wrap{max-width:820px;margin:0 auto}
    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px; flex-wrap:wrap;
      margin-bottom:12px;
    }
    .pill{
      padding:10px 14px; border-radius:999px;
      background:rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(8px);
      font-weight:700;
      letter-spacing:.3px;
    }
    .cta{
      background:linear-gradient(180deg,var(--yellow),var(--yellow2));
      color:#160018;
      border:0;
      border-radius:14px;
      padding:12px 14px;
      font-weight:900;
      min-width:120px;
      box-shadow:0 10px 26px rgba(0,0,0,.35);
      cursor:pointer;
    }
    .subrow{
      display:flex; gap:12px; flex-wrap:wrap;
      margin-bottom:12px;
    }
    .hint{
      flex:1;
      min-width:220px;
      padding:12px 14px;
      border-radius:18px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(8px);
      color:var(--muted);
      line-height:1.25;
    }
    .btn{
      padding:12px 14px;
      border-radius:14px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      color:var(--text);
      font-weight:800;
      cursor:pointer;
      min-width:120px;
    }
    .cards{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap:12px;
      margin-bottom:12px;
    }
    .card{
      padding:14px;
      border-radius:18px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
    }
    .card .k{font-size:12px;color:var(--muted);letter-spacing:.18em;font-weight:900}
    .card .v{margin-top:6px;font-size:40px;font-weight:900;line-height:1}
    .card .s{margin-top:6px;color:var(--muted);font-weight:700}
    .gamepanel{
      padding:14px;
      border-radius:22px;
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
    }
    .stage{
      position:relative;
      width:100%;
      aspect-ratio: 9 / 11;
      max-height: 640px;
      margin:0 auto;
      border-radius:22px;
      overflow:hidden;
      background:
        radial-gradient(900px 700px at 50% 0%, rgba(255,255,255,.08), transparent 55%),
        radial-gradient(700px 600px at 35% 65%, rgba(255,255,255,.05), transparent 60%),
        rgba(0,0,0,.12);
      border:1px solid rgba(255,255,255,.12);
    }
    /* Layers */
    .bubbleWrap{
      position:absolute;
      left:50%;
      top:7%;
      transform:translateX(-50%);
      width:min(62%, 340px);
      z-index:6;
      pointer-events:none;
      text-align:center;
    }
    .bubbleImg{
      width:100%;
      height:auto;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.35));
      opacity:.98;
    }
    .bubbleFood{
      position:absolute;
      left:50%;
      top:48%;
      transform:translate(-50%,-50%);
      width:36%;
      height:auto;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.35));
    }
    .wantLabel{
      margin-top:10px;
      font-weight:1000;
      letter-spacing:.22em;
      opacity:.92;
      text-transform:uppercase;
      text-shadow:0 6px 14px rgba(0,0,0,.45);
    }

    .base{
      position:absolute;
      left:50%;
      top:44%;
      transform:translateX(-50%);
      width:min(78%, 520px);
      height:auto;
      z-index:2;
      filter: drop-shadow(0 18px 26px rgba(0,0,0,.35));
      user-select:none;
      -webkit-user-drag:none;
    }

    .belt{
      position:absolute;
      left:50%;
      top:59%;
      transform:translateX(-50%);
      width:min(92%, 650px);
      height:auto;
      z-index:3;
      user-select:none;
      -webkit-user-drag:none;
      pointer-events:none;
      filter: drop-shadow(0 14px 20px rgba(0,0,0,.35));
    }

    .foodsLayer{
      position:absolute;
      inset:0;
      z-index:4;
      pointer-events:none;
    }
    .food{
      position:absolute;
      width:68px;
      height:68px;
      object-fit:contain;
      transform:translate(-50%,-50%);
      filter: drop-shadow(0 10px 14px rgba(0,0,0,.35));
      pointer-events:auto; /* allow drag */
      touch-action:none;
      user-select:none;
      -webkit-user-drag:none;
      cursor:grab;
    }
    .food.dragging{
      cursor:grabbing;
      filter: drop-shadow(0 18px 22px rgba(0,0,0,.45));
    }

    .toast{
      position:absolute;
      left:50%;
      top:52%;
      transform:translate(-50%,-50%);
      z-index:7;
      padding:10px 14px;
      border-radius:999px;
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.18);
      backdrop-filter: blur(8px);
      font-weight:1000;
      letter-spacing:.14em;
      text-transform:uppercase;
      opacity:0;
      pointer-events:none;
      transition:opacity .15s ease, transform .15s ease;
    }
    .toast.show{
      opacity:1;
      transform:translate(-50%,-54%);
    }

    .how{
      margin-top:12px;
      padding:14px;
      border-radius:18px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      color:var(--muted);
      line-height:1.35;
      font-weight:650;
    }
    .how b{color:rgba(255,255,255,.9)}
    @media (max-width:520px){
      .cards{grid-template-columns:1fr}
      .stage{aspect-ratio: 9/12}
      .food{width:60px;height:60px}
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="pill">$PHAT — Conveyor Munch</div>
    <button class="cta" id="btnReset">Run it back</button>
  </div>

  <div class="subrow">
    <div class="hint">Drag the snack into his mouth. Miss = pain. Streak = glory.</div>
    <button class="btn" id="btnShare">Share score</button>
  </div>

  <div class="cards">
    <div class="card">
      <div class="k">RUN</div>
      <div class="v"><span id="runCorrect">0</span></div>
      <div class="s">Streak: <span id="streak">0</span> · Mult: <span id="mult">1.0x</span></div>
    </div>
    <div class="card">
      <div class="k">BEST</div>
      <div class="v"><span id="best">0</span></div>
      <div class="s">Daily best: <span id="dailyBest">0</span></div>
    </div>
    <div class="card">
      <div class="k">DAILY GOAL</div>
      <div class="v"><span id="goalNow">0</span> / <span id="goalMax">30</span></div>
      <div class="s">Resets in <span id="resetIn">--:--:--</span></div>
    </div>
  </div>

  <div class="gamepanel">
    <div class="stage" id="stage">
      <div class="bubbleWrap" id="bubbleWrap">
        <img class="bubbleImg" src="../assets/thought-bubble.png" alt="thought bubble" draggable="false" />
        <img class="bubbleFood" id="bubbleFood" src="" alt="wanted food" draggable="false" />
        <div class="wantLabel" id="wantLabel">—</div>
      </div>

      <!-- Your base PNG already includes table + plate + seated character -->
      <img class="base" id="base" src="../assets/stack_base.png" alt="base" draggable="false" />

      <!-- Conveyor belt overlay -->
      <img class="belt" id="belt" src="../assets/conveyor.png" alt="conveyor" draggable="false" />

      <div class="foodsLayer" id="foodsLayer"></div>

      <div class="toast" id="toast">MISSED</div>
    </div>

    <div class="how">
      <b>How it plays:</b> The thought bubble shows what he wants. The belt feeds a nonstop stream of snacks.
      Grab the correct one <b>between the wrong choices</b> and drag it to his mouth before it rolls away.
    </div>
  </div>
</div>

<script>
(() => {
  const stage = document.getElementById('stage');
  const foodsLayer = document.getElementById('foodsLayer');
  const beltEl = document.getElementById('belt');
  const baseEl = document.getElementById('base');
  const bubbleFoodEl = document.getElementById('bubbleFood');
  const wantLabelEl = document.getElementById('wantLabel');
  const toastEl = document.getElementById('toast');

  const runCorrectEl = document.getElementById('runCorrect');
  const streakEl = document.getElementById('streak');
  const multEl = document.getElementById('mult');
  const bestEl = document.getElementById('best');
  const dailyBestEl = document.getElementById('dailyBest');
  const goalNowEl = document.getElementById('goalNow');
  const goalMaxEl = document.getElementById('goalMax');
  const resetInEl = document.getElementById('resetIn');

  const btnReset = document.getElementById('btnReset');
  const btnShare = document.getElementById('btnShare');

  // -------------------------
  // ASSETS (auto from /assets list naming)
  // -------------------------
  // This list matches your assets naming style: food_*.png
  const FOODS = [
    {key:'brownies', label:'Brownies', src:'../assets/food_brownies.png'},
    {key:'burger', label:'Burger', src:'../assets/food_burger.png'},
    {key:'cake', label:'Cake', src:'../assets/food_cake.png'},
    {key:'chinese_takeout', label:'Takeout', src:'../assets/food_chinese_takeout.png'},
    {key:'cookie_pizza', label:'Cookie Pizza', src:'../assets/food_cookie_pizza.png'},
    {key:'donut_stack', label:'Donut Stack', src:'../assets/food_donut_stack.png'},
    {key:'fried_chicken', label:'Fried Chicken', src:'../assets/food_fried_chicken.png'},
    {key:'fries', label:'Fries', src:'../assets/food_fries.png'},
    {key:'grilledcheese', label:'Grilled Cheese', src:'../assets/food_grilledcheese.png'},
    {key:'hotdogs', label:'Hotdogs', src:'../assets/food_hotdogs.png'},
    {key:'icecream_cone', label:'Ice Cream', src:'../assets/food_icecream_cone.png'},
    {key:'milkshake_chocolate', label:'Choco Shake', src:'../assets/food_milkshake_chocolate.png'},
    {key:'milkshake_strawberry', label:'Strawberry Shake', src:'../assets/food_milkshake_strawberry.png'},
    {key:'milkshake_vanilla', label:'Vanilla Shake', src:'../assets/food_milkshake_vanilla.png'},
    {key:'onion_rings', label:'Onion Rings', src:'../assets/food_onion_rings.png'},
  ];

  // -------------------------
  // PRESSURE SETTINGS (no manual tweaking required)
  // -------------------------
  const GOAL_MAX = 30;
  goalMaxEl.textContent = GOAL_MAX;

  const MAX_FOODS_ON_SCREEN = 12;    // pressure
  const START_FOODS_ON_SCREEN = 9;   // starts hot
  const ITEM_SPACING_PX = 92;        // keeps them dense without stacking
  let beltSpeed = 185;               // px/sec
  let spawnEveryMs = 240;            // spawn cadence
  const TARGET_GUARANTEE_MS = 1400;  // target appears often enough

  // -------------------------
  // State
  // -------------------------
  let foods = []; // {id, foodIndex, x, y, el, isTarget}
  let nextId = 1;

  let laneY = 0;              // computed from belt surface
  let mouth = {x:0,y:0,r:56}; // computed from base image
  let lastSpawn = 0;
  let lastTargetSeen = 0;

  let runCorrect = 0;
  let streak = 0;
  let best = 0;

  // daily persistence
  const LS_KEY = 'phat_conveyor_munch_v3';
  let daily = { day:'', dailyBest:0, goalNow:0, bestAll:0 };

  // current target
  let targetIndex = 0;

  // drag state
  let dragging = null; // {foodObj, dx, dy}
  let raf = 0;
  let lastT = performance.now();

  // -------------------------
  // Helpers
  // -------------------------
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function pickRandomIndex(){ return Math.floor(Math.random()*FOODS.length); }
  function nowMs(){ return Date.now(); }

  function getLocalDayKey(){
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const da = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${da}`;
  }

  function msUntilMidnight(){
    const n = new Date();
    const t = new Date(n);
    t.setHours(24,0,0,0);
    return t.getTime() - n.getTime();
  }

  function fmtCountdown(ms){
    ms = Math.max(0, ms);
    const s = Math.floor(ms/1000);
    const hh = String(Math.floor(s/3600)).padStart(2,'0');
    const mm = String(Math.floor((s%3600)/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return `${hh}:${mm}:${ss}`;
  }

  function saveDaily(){
    localStorage.setItem(LS_KEY, JSON.stringify(daily));
  }

  function loadDaily(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(raw) daily = JSON.parse(raw);
    }catch(e){}
    const today = getLocalDayKey();
    if(daily.day !== today){
      daily.day = today;
      daily.dailyBest = 0;
      daily.goalNow = 0;
      daily.bestAll = daily.bestAll || 0;
      saveDaily();
    }
    best = daily.bestAll || 0;
    bestEl.textContent = best;
    dailyBestEl.textContent = daily.dailyBest || 0;
    goalNowEl.textContent = daily.goalNow || 0;
  }

  function showToast(text){
    toastEl.textContent = text;
    toastEl.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toastEl.classList.remove('show'), 520);
  }

  function updateHUD(){
    runCorrectEl.textContent = runCorrect;
    streakEl.textContent = streak;
    const mult = (1 + Math.min(9, Math.floor(streak/5)) * 0.2);
    multEl.textContent = mult.toFixed(1) + 'x';

    if(runCorrect > (daily.dailyBest||0)){
      daily.dailyBest = runCorrect;
      dailyBestEl.textContent = daily.dailyBest;
      saveDaily();
    }
    if(runCorrect > best){
      best = runCorrect;
      daily.bestAll = best;
      bestEl.textContent = best;
      saveDaily();
    }
  }

  // -------------------------
  // Geometry: belt lane + mouth hitbox
  // -------------------------
  function computeLaneFromBelt(){
    const sr = stage.getBoundingClientRect();
    const br = beltEl.getBoundingClientRect();

    // Convert belt rect to stage-local coords
    const beltTop = br.top - sr.top;
    const beltH = br.height;

    // Food rides on the TOP surface of the belt.
    // Tuned for your conveyor art so items sit correctly (no manual edits needed).
    const SURFACE_RATIO = 0.30;
    const SURFACE_NUDGE = -6;

    laneY = beltTop + beltH * SURFACE_RATIO + SURFACE_NUDGE;
    laneY = clamp(laneY, 0, sr.height);
  }

  function computeMouthFromBase(){
    const sr = stage.getBoundingClientRect();
    const br = baseEl.getBoundingClientRect();

    const baseLeft = br.left - sr.left;
    const baseTop = br.top - sr.top;
    const baseW = br.width;
    const baseH = br.height;

    // Mouth center relative to the seated character in stack_base.png
    // (Works even if your PNG scale changes.)
    mouth.x = baseLeft + baseW * 0.50;
    mouth.y = baseTop + baseH * 0.30;  // face area above belt
    mouth.r = Math.max(42, baseW * 0.08);
  }

  function recomputeAll(){
    computeLaneFromBelt();
    computeMouthFromBase();
    // snap foods to lane on resize
    foods.forEach(f => { f.y = laneY; });
  }

  // -------------------------
  // Target selection (bubble)
  // -------------------------
  function setNewTarget(){
    targetIndex = pickRandomIndex();
    const t = FOODS[targetIndex];
    bubbleFoodEl.src = t.src;
    wantLabelEl.textContent = t.label.toUpperCase();
    lastTargetSeen = performance.now();
  }

  function isTargetOnBelt(){
    return foods.some(f => f.foodIndex === targetIndex);
  }

  // -------------------------
  // Food spawning / movement
  // -------------------------
  function spawnFood(forceTarget=false){
    const sr = stage.getBoundingClientRect();
    const spawnX = sr.width + 40;

    // Enforce spacing: last item must be far enough left
    if(foods.length){
      const maxX = Math.max(...foods.map(f => f.x));
      if(maxX > spawnX - ITEM_SPACING_PX) return;
    }

    let foodIndex = forceTarget ? targetIndex : pickRandomIndex();

    // Avoid endless repeats (slight bias)
    if(!forceTarget && foods.length >= 2){
      const last1 = foods[foods.length-1].foodIndex;
      const last2 = // approximate: find rightmost two
        foods.slice().sort((a,b)=>a.x-b.x).slice(-2)[0]?.foodIndex;
      if(foodIndex === last1 || foodIndex === last2) foodIndex = pickRandomIndex();
    }

    const img = document.createElement('img');
    img.className = 'food';
    img.src = FOODS[foodIndex].src;
    img.alt = FOODS[foodIndex].label;
    img.draggable = false;

    const obj = {
      id: nextId++,
      foodIndex,
      x: spawnX,
      y: laneY,
      el: img,
    };

    img.dataset.id = obj.id;

    // Drag handlers
    img.addEventListener('pointerdown', (e) => {
      // capture drag
      if(dragging) return;
      img.setPointerCapture(e.pointerId);

      dragging = { foodObj: obj, dx: obj.x - e.clientX, dy: obj.y - e.clientY };
      img.classList.add('dragging');
      e.preventDefault();
      e.stopPropagation();
    });

    img.addEventListener('pointermove', (e) => {
      if(!dragging || dragging.foodObj !== obj) return;
      const sr = stage.getBoundingClientRect();
      const x = (e.clientX - sr.left) + (dragging.dx || 0);
      const y = (e.clientY - sr.top) + (dragging.dy || 0);
      obj.x = clamp(x, 10, sr.width - 10);
      obj.y = clamp(y, 10, sr.height - 10);
      renderFood(obj);
      e.preventDefault();
      e.stopPropagation();
    });

    img.addEventListener('pointerup', (e) => {
      if(!dragging || dragging.foodObj !== obj) return;
      img.classList.remove('dragging');
      dragging = null;

      // check mouth hit
      const dx = obj.x - mouth.x;
      const dy = obj.y - mouth.y;
      const dist = Math.hypot(dx,dy);

      if(dist <= mouth.r){
        // Eaten attempt
        if(obj.foodIndex === targetIndex){
          // correct
          runCorrect++;
          streak++;
          daily.goalNow = Math.min(GOAL_MAX, (daily.goalNow||0) + 1);
          goalNowEl.textContent = daily.goalNow;
          saveDaily();
          showToast('NICE');
          removeFood(obj.id);
          setNewTarget();
        }else{
          // wrong
          streak = 0;
          showToast('MISSED');
          // snap back to lane so it keeps moving
          obj.y = laneY;
        }
        updateHUD();
      }else{
        // not dropped in mouth -> snap back to lane for smooth belt
        obj.y = laneY;
      }

      e.preventDefault();
      e.stopPropagation();
    });

    foodsLayer.appendChild(img);
    foods.push(obj);
    renderFood(obj);
  }

  function renderFood(obj){
    obj.el.style.left = obj.x + 'px';
    obj.el.style.top = obj.y + 'px';
  }

  function removeFood(id){
    const idx = foods.findIndex(f => f.id === id);
    if(idx >= 0){
      const [f] = foods.splice(idx,1);
      try{ f.el.remove(); }catch(e){}
    }
  }

  function tick(t){
    const dt = Math.min(0.05, (t - lastT) / 1000);
    lastT = t;

    const sr = stage.getBoundingClientRect();
    const leftKill = -80;

    // Recompute lane/mouth occasionally (images load async)
    // plus if user rotates phone
    if((t|0) % 1200 < 16) recomputeAll();

    // Spawn logic (keep pressure steady)
    if(t - lastSpawn >= spawnEveryMs){
      lastSpawn = t;

      // Guarantee target appears frequently
      const needTarget = !isTargetOnBelt() && (t - lastTargetSeen >= TARGET_GUARANTEE_MS);

      if(foods.length < MAX_FOODS_ON_SCREEN){
        spawnFood(needTarget);
        if(needTarget) lastTargetSeen = t;
      }
    }

    // Keep initial pressure
    if(foods.length < START_FOODS_ON_SCREEN){
      for(let i=0;i<2;i++){
        if(foods.length < START_FOODS_ON_SCREEN) spawnFood(false);
      }
    }

    // Move belt foods (unless dragging)
    for(const f of foods){
      if(dragging && dragging.foodObj === f) continue;
      f.x -= beltSpeed * dt;
      f.y = laneY; // stay on belt lane
      renderFood(f);
    }

    // Remove offscreen + punish if target slipped away
    for(let i=foods.length-1;i>=0;i--){
      const f = foods[i];
      if(f.x < leftKill){
        const wasTarget = (f.foodIndex === targetIndex);
        removeFood(f.id);
        if(wasTarget){
          streak = 0;
          showToast('MISSED');
          updateHUD();
          // Make sure target comes back quickly
          lastTargetSeen = 0;
        }
      }
    }

    raf = requestAnimationFrame(tick);
  }

  // -------------------------
  // Reset / Share
  // -------------------------
  function resetRun(){
    runCorrect = 0;
    streak = 0;
    updateHUD();

    // clear foods
    foods.forEach(f => { try{ f.el.remove(); }catch(e){} });
    foods = [];
    dragging = null;

    setNewTarget();
    recomputeAll();

    // kickstart spawns
    lastSpawn = 0;
    lastTargetSeen = 0;
  }

  async function shareScore(){
    const text = `$PHAT Conveyor Munch — Run: ${runCorrect} • Streak: ${streak} • Daily: ${daily.goalNow||0}/${GOAL_MAX}\n${location.href}`;
    try{
      if(navigator.share){
        await navigator.share({text});
      }else{
        await navigator.clipboard.writeText(text);
        showToast('COPIED');
      }
    }catch(e){
      try{
        await navigator.clipboard.writeText(text);
        showToast('COPIED');
      }catch(_){}
    }
  }

  // -------------------------
  // Boot
  // -------------------------
  loadDaily();
  resetRun();

  btnReset.addEventListener('click', resetRun);
  btnShare.addEventListener('click', shareScore);

  // countdown
  function updateCountdown(){
    resetInEl.textContent = fmtCountdown(msUntilMidnight());
    requestAnimationFrame(updateCountdown);
  }
  updateCountdown();

  // Wait for images to load then compute exact geometry
  function onReady(){
    recomputeAll();
  }
  window.addEventListener('resize', recomputeAll, {passive:true});
  window.addEventListener('orientationchange', () => setTimeout(recomputeAll, 250), {passive:true});
  baseEl.addEventListener('load', onReady);
  beltEl.addEventListener('load', onReady);

  // start loop
  cancelAnimationFrame(raf);
  lastT = performance.now();
  raf = requestAnimationFrame(tick);
})();
</script>
</body>
</html>