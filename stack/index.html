<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>$PHAT â€” Conveyor Munch</title>
  <style>
    :root{
      --bg1:#2a0a4a;
      --bg2:#0a0612;
      --glass: rgba(255,255,255,0.08);
      --glass2: rgba(255,255,255,0.12);
      --stroke: rgba(255,255,255,0.18);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --yellow:#ffd400;
      --good:#2cff7a;
      --bad:#ff3b57;
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    body{
      margin:0;
      font-family: ui-sans-serif, -apple-system, system-ui, Segoe UI, Roboto, Arial;
      color:var(--text);
      background: radial-gradient(1200px 900px at 30% 0%, #4b1a77 0%, var(--bg1) 35%, var(--bg2) 100%);
      overflow:hidden;
    }

    .wrap{
      width: min(980px, 100vw);
      margin: 0 auto;
      padding: 14px 12px 18px;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:10px 14px;
      border-radius:999px;
      background: var(--glass);
      border:1px solid var(--stroke);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 12px 38px rgba(0,0,0,0.35);
    }
    .title{
      font-weight:800;
      letter-spacing:0.2px;
    }
    .sub{
      margin-top:10px;
      width:100%;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .tagline{
      flex:1;
      min-width: 240px;
      padding:12px 14px;
      border-radius:999px;
      background: var(--glass);
      border:1px solid var(--stroke);
      color:var(--muted);
      font-weight:650;
    }
    .btn{
      appearance:none;
      border:0;
      border-radius:16px;
      padding:12px 14px;
      font-weight:900;
      cursor:pointer;
      background: linear-gradient(180deg, #ffe45a, var(--yellow));
      color:#1a1200;
      box-shadow: 0 18px 40px rgba(0,0,0,0.35);
    }
    .btn.secondary{
      background: var(--glass2);
      color:var(--text);
      border:1px solid var(--stroke);
      box-shadow:none;
    }

    .hud{
      margin-top:12px;
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
    }
    .card{
      padding:12px 12px;
      border-radius:18px;
      background: rgba(0,0,0,0.20);
      border:1px solid rgba(255,255,255,0.14);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: 0 18px 50px rgba(0,0,0,0.25);
      min-height:76px;
    }
    .k{ color:var(--muted); font-weight:800; font-size:12px; letter-spacing:0.35px; }
    .v{ font-weight:950; font-size:18px; margin-top:6px; }
    .small{ font-size:12px; color:var(--muted); margin-top:4px; font-weight:700; }

    /* GAME STAGE */
    .stageCard{
      margin-top:12px;
      border-radius:22px;
      background: rgba(0,0,0,0.18);
      border:1px solid rgba(255,255,255,0.14);
      overflow:hidden;
      position:relative;
      box-shadow: 0 22px 70px rgba(0,0,0,0.34);
    }

    /* Keep it BIG on mobile */
    .stage{
      position:relative;
      width:100%;
      height: min(70vh, 640px);
      min-height: 520px;
      display:block;
      background: radial-gradient(900px 550px at 50% 0%, rgba(255,255,255,0.06) 0%, rgba(0,0,0,0) 55%);
    }

    .img{
      position:absolute;
      pointer-events:none;
      user-select:none;
      -webkit-user-drag:none;
    }

    /* base character is large and centered */
    #base{
      left:50%;
      bottom:-8px;
      transform: translateX(-50%);
      width: min(92%, 720px);
      max-width: 820px;
      z-index: 1;
      filter: drop-shadow(0 20px 40px rgba(0,0,0,0.35));
    }

    /* conveyor floats in front of table */
    #conveyor{
      left:50%;
      top: 46%;
      transform: translateX(-50%);
      width: min(96%, 840px);
      z-index: 3;
      opacity:0.98;
      filter: drop-shadow(0 16px 38px rgba(0,0,0,0.30));
    }

    /* thought bubble near head */
    #bubble{
      left:50%;
      top: 6%;
      transform: translateX(-50%);
      width: min(72%, 620px);
      z-index: 5;
      opacity:0.98;
    }

    /* mouth target aligns to stack-base mouth area */
    #mouth{
      left:50%;
      top: 38%;
      transform: translateX(-50%);
      width: min(22%, 190px);
      z-index: 6;
      pointer-events:none;
      opacity:0.92;
      filter: drop-shadow(0 10px 25px rgba(0,0,0,0.25));
    }

    /* Food element (draggable) */
    .food{
      position:absolute;
      z-index: 7;
      width: min(18vw, 150px);
      max-width: 150px;
      min-width: 86px;
      cursor: grab;
      touch-action: none;
      user-select:none;
      -webkit-user-drag:none;
      filter: drop-shadow(0 16px 28px rgba(0,0,0,0.30));
      transition: transform 120ms ease;
    }
    .food:active{ cursor: grabbing; transform: scale(1.03); }

    /* Food preview inside bubble */
    #bubblePreview{
      position:absolute;
      left:50%;
      top: 14%;
      transform: translateX(-50%);
      width: min(16vw, 140px);
      max-width: 140px;
      min-width: 80px;
      z-index: 6;
      pointer-events:none;
      filter: drop-shadow(0 12px 22px rgba(0,0,0,0.22));
    }

    /* Toast */
    .toast{
      position:absolute;
      left:50%;
      bottom:14px;
      transform: translateX(-50%);
      z-index: 50;
      background: rgba(0,0,0,0.35);
      border:1px solid rgba(255,255,255,0.16);
      padding:10px 12px;
      border-radius:14px;
      font-weight:900;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      opacity:0;
      transition: opacity 180ms ease, transform 180ms ease;
      pointer-events:none;
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-6px);
    }
    .toast.good{ color: var(--good); }
    .toast.bad{ color: var(--bad); }

    /* Bottom actions */
    .bar{
      margin-top:10px;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .bar .pill{ flex:1; min-width: 220px; justify-content:space-between; }
    .bar .pill b{ font-size:14px; }
    .bar .pill span{ color:var(--muted); font-weight:800; }

    /* Responsive tweaks */
    @media (max-width: 420px){
      .stage{ height: 72vh; min-height: 540px; }
      #conveyor{ top: 47%; }
      #mouth{ top: 37.2%; width: 26%; }
      #bubble{ width: 86%; }
      #bubblePreview{ width: 18vw; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="pill"><span class="title">$PHAT â€” Conveyor Munch</span></div>

    <div class="sub">
      <div class="tagline">Drag the snack into his mouth. Miss = pain. Streak = glory.</div>
      <button class="btn" id="btnRestart">Run it back</button>
      <button class="btn secondary" id="btnShare">Share score</button>
    </div>

    <div class="hud">
      <div class="card">
        <div class="k">RUN</div>
        <div class="v"><span id="score">0</span> correct</div>
        <div class="small">Streak: <b id="streak">0</b> â€¢ Mult: <b id="mult">1.0x</b></div>
      </div>
      <div class="card">
        <div class="k">BEST</div>
        <div class="v"><span id="best">0</span> correct</div>
        <div class="small">Daily best: <b id="dailyBest">0</b></div>
      </div>
      <div class="card">
        <div class="k">DAILY GOAL</div>
        <div class="v"><span id="daily">0</span> / <span id="dailyGoal">30</span></div>
        <div class="small">Resets in <b id="resetIn">--:--:--</b></div>
      </div>
    </div>

    <div class="stageCard">
      <div class="stage" id="stage">
        <!-- ART LAYERS -->
        <img class="img" id="bubble" src="assets/thought-bubble.png" alt="thought bubble" />
        <img class="img" id="bubblePreview" src="" alt="" style="display:none;" />
        <img class="img" id="mouth" src="assets/mouth.png" alt="mouth target" />
        <img class="img" id="conveyor" src="assets/conveyor.png" alt="conveyor" />
        <img class="img" id="base" src="assets/stack-base.png" alt="base character" />

        <div class="toast" id="toast"></div>
      </div>
    </div>

    <div class="bar">
      <div class="pill">
        <b>Mode</b>
        <span id="modeLabel">Classic</span>
      </div>
      <div class="pill">
        <b>Belt speed</b>
        <span id="speedLabel">1.0x</span>
      </div>
      <div class="pill">
        <b>Spawns</b>
        <span id="spawnLabel">2 on belt</span>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * CONFIG â€” EDIT THIS  *
     ***********************/
    // Put ALL your food filenames here (in assets/foods/)
    const FOODS = [
      "burger.png",
      "fries.png",
      "donut-stack.png",
      "brownie-stack.png",
      "cake.png",
      "milkshake-strawberry.png",
      "milkshake-chocolate.png",
      "milkshake-vanilla.png",
      "pizza-stack.png",
      "pancake-stack.png",
      "icecream-cone.png",
      "onion-rings.png",
      "sub.png",
      "fried-chicken.png"
      // add the rest...
    ].map(f => `assets/foods/${f}`);

    // Gameplay tuning
    const DAILY_GOAL = 30;
    const BASE_BELT_SPEED = 110;      // px/sec
    const SPEED_RAMP_EVERY = 5;       // every N correct, increase speed
    const SPEED_RAMP_AMOUNT = 18;     // px/sec added
    const SPAWN_COUNT = 2;            // snacks visible on belt at once
    const ROUND_TIME_LIMIT = 0;       // 0 = endless, else seconds (e.g. 45)

    // Mouth hitbox tuning (percent of mouth image box)
    const MOUTH_HIT_SCALE = 0.58;     // smaller = stricter
    const DRAG_SNAP_DISTANCE = 90;    // px threshold to count as "close"

    /***********************
     * STATE + STORAGE     *
     ***********************/
    const $ = (id) => document.getElementById(id);
    const stage = $("stage");
    const toast = $("toast");
    const bubblePreview = $("bubblePreview");

    let score = 0;
    let streak = 0;
    let mult = 1.0;
    let beltSpeed = BASE_BELT_SPEED;
    let running = true;

    // Daily reset key
    function dayKey(){
      const d = new Date();
      return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    }
    const BEST_KEY = "phat_munch_best";
    const DAILY_KEY = () => `phat_munch_daily_${dayKey()}`;
    const DAILYBEST_KEY = () => `phat_munch_dailybest_${dayKey()}`;

    function getNum(k, def=0){
      const v = localStorage.getItem(k);
      const n = v===null ? def : Number(v);
      return Number.isFinite(n) ? n : def;
    }
    function setNum(k, v){ localStorage.setItem(k, String(v)); }

    /***********************
     * UTIL                *
     ***********************/
    function pickFood(excludeSet = new Set()){
      const options = FOODS.filter(f => !excludeSet.has(f));
      const pool = options.length ? options : FOODS;
      return pool[Math.floor(Math.random()*pool.length)];
    }

    function showToast(msg, kind="good"){
      toast.textContent = msg;
      toast.className = `toast show ${kind}`;
      setTimeout(()=> toast.className = "toast", 520);
    }

    function haptic(kind="light"){
      // iOS/Android browsers: best-effort
      if (navigator.vibrate){
        navigator.vibrate(kind==="bad" ? [30,30,30] : 18);
      }
    }

    function rectCenter(r){
      return { x: r.left + r.width/2, y: r.top + r.height/2 };
    }

    /***********************
     * MOUTH TARGET        *
     ***********************/
    function getMouthRect(){
      const mouth = $("mouth");
      const r = mouth.getBoundingClientRect();
      const w = r.width * MOUTH_HIT_SCALE;
      const h = r.height * MOUTH_HIT_SCALE;
      return {
        left: r.left + (r.width - w)/2,
        top: r.top + (r.height - h)/2,
        width: w,
        height: h
      };
    }

    function isNearMouth(foodEl){
      const fr = foodEl.getBoundingClientRect();
      const fc = rectCenter(fr);
      const mr = getMouthRect();
      const mc = rectCenter(mr);
      const dx = fc.x - mc.x;
      const dy = fc.y - mc.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      return dist <= DRAG_SNAP_DISTANCE;
    }

    /***********************
     * ROUND / REQUESTED    *
     ***********************/
    let requestedFood = null;

    function setRequested(foodSrc){
      requestedFood = foodSrc;
      bubblePreview.src = foodSrc;
      bubblePreview.style.display = "block";
    }

    /***********************
     * FOOD SPAWNING + BELT *
     ***********************/
    let foodEls = [];
    let beltLeftEdge = 0;
    let beltRightEdge = 0;
    let beltY = 0;

    function computeBeltLane(){
      const belt = $("conveyor").getBoundingClientRect();
      beltLeftEdge = belt.left + belt.width * 0.08;
      beltRightEdge = belt.left + belt.width * 0.92;
      beltY = belt.top + belt.height * 0.32;
    }

    function createFoodEl(src, x){
      const el = document.createElement("img");
      el.className = "food";
      el.src = src;
      el.alt = "food";
      stage.appendChild(el);

      // place near belt lane
      const stageRect = stage.getBoundingClientRect();
      const px = x - stageRect.left;
      const py = beltY - stageRect.top;

      el.style.left = `${px}px`;
      el.style.top = `${py}px`;

      enableDrag(el);

      return el;
    }

    function spawnInitial(){
      cleanupFoods();
      computeBeltLane();

      const used = new Set();
      // choose requested first
      const req = pickFood();
      setRequested(req);
      used.add(req);

      const stageRect = stage.getBoundingClientRect();
      const laneWidth = beltRightEdge - beltLeftEdge;

      // spawn N items spaced apart
      for (let i=0;i<SPAWN_COUNT;i++){
        const src = (i===0) ? req : pickFood(used);
        used.add(src);

        const x = beltLeftEdge + (laneWidth * (0.15 + 0.6*(i/(Math.max(1,SPAWN_COUNT-1))))) ;
        const el = createFoodEl(src, x);
        // start slightly offscreen stagger for motion feel
        el.dataset.vx = String(beltSpeed);
        el.dataset.dragging = "0";
        el.dataset.good = (src===req) ? "1" : "0";
        foodEls.push(el);
      }
    }

    function cleanupFoods(){
      foodEls.forEach(el => el.remove());
      foodEls = [];
    }

    function respawnOne(replaceEl){
      computeBeltLane();

      // ensure there is always 1 correct target somewhere
      const hasCorrect = foodEls.some(el => el.dataset.good==="1");
      let makeCorrect = !hasCorrect;

      // if we just ate correct, next request changes
      // (handled in awardCorrect)

      const src = makeCorrect ? requestedFood : pickFood(new Set([requestedFood]));
      replaceEl.src = src;
      replaceEl.dataset.good = (src===requestedFood) ? "1" : "0";
      replaceEl.dataset.dragging = "0";
      replaceEl.dataset.vx = String(beltSpeed);

      // reposition at left edge
      const stageRect = stage.getBoundingClientRect();
      const px = (beltLeftEdge - stageRect.left) - 180; // spawn off-left
      const py = beltY - stageRect.top;

      replaceEl.style.left = `${px}px`;
      replaceEl.style.top = `${py}px`;
      replaceEl.style.opacity = "1";
      replaceEl.style.transform = "scale(1)";
    }

    /***********************
     * DRAG + DROP          *
     ***********************/
    function enableDrag(el){
      let pointerId = null;
      let startX = 0, startY = 0;
      let elStartLeft = 0, elStartTop = 0;

      function onDown(e){
        if (!running) return;

        pointerId = e.pointerId;
        el.setPointerCapture(pointerId);
        el.dataset.dragging = "1";

        const r = el.getBoundingClientRect();
        const s = stage.getBoundingClientRect();
        startX = e.clientX;
        startY = e.clientY;

        elStartLeft = parseFloat(el.style.left || "0");
        elStartTop  = parseFloat(el.style.top  || "0");

        el.style.transition = "none";
      }

      function onMove(e){
        if (pointerId === null || e.pointerId !== pointerId) return;

        const dx = e.clientX - startX;
        const dy = e.clientY - startY;

        el.style.left = `${elStartLeft + dx}px`;
        el.style.top  = `${elStartTop  + dy}px`;
      }

      function onUp(e){
        if (pointerId === null || e.pointerId !== pointerId) return;
        pointerId = null;
        el.dataset.dragging = "0";
        el.style.transition = "";

        // check drop near mouth
        if (isNearMouth(el)){
          const isCorrect = el.dataset.good === "1";
          if (isCorrect) awardCorrect(el);
          else awardWrong(el);
        } else {
          // snap back to belt lane (feels polished)
          snapBackToBelt(el);
        }
      }

      el.addEventListener("pointerdown", onDown);
      window.addEventListener("pointermove", onMove, {passive:false});
      window.addEventListener("pointerup", onUp);
      window.addEventListener("pointercancel", onUp);
    }

    function snapBackToBelt(el){
      computeBeltLane();
      const stageRect = stage.getBoundingClientRect();
      const x = Math.min(Math.max(parseFloat(el.style.left||"0"), 0), stageRect.width - 140);
      const y = (beltY - stageRect.top);

      el.style.left = `${x}px`;
      el.style.top = `${y}px`;
    }

    /***********************
     * SCORING / PROGRESSION*
     ***********************/
    function updateHud(){
      $("score").textContent = score;
      $("streak").textContent = streak;
      $("mult").textContent = `${mult.toFixed(1)}x`;
      $("best").textContent = getNum(BEST_KEY, 0);
      $("daily").textContent = getNum(DAILY_KEY(), 0);
      $("dailyBest").textContent = getNum(DAILYBEST_KEY(), 0);

      $("speedLabel").textContent = `${(beltSpeed/BASE_BELT_SPEED).toFixed(1)}x`;
      $("spawnLabel").textContent = `${SPAWN_COUNT} on belt`;
    }

    function awardCorrect(el){
      // juice: shrink into mouth
      el.style.transform = "scale(0.15)";
      el.style.opacity = "0.2";

      haptic("light");
      showToast(`+1  (x${mult.toFixed(1)})`, "good");

      // score math
      score += 1;
      streak += 1;

      // multiplier ramps with streak
      mult = 1 + Math.min(2.5, streak * 0.10); // caps at 3.5x feel
      // belt speed ramps with score
      if (score % SPEED_RAMP_EVERY === 0){
        beltSpeed += SPEED_RAMP_AMOUNT;
      }

      // update bests
      const best = getNum(BEST_KEY, 0);
      if (score > best) setNum(BEST_KEY, score);

      const daily = getNum(DAILY_KEY(), 0) + 1;
      setNum(DAILY_KEY(), daily);

      const dailyBest = getNum(DAILYBEST_KEY(), 0);
      if (score > dailyBest) setNum(DAILYBEST_KEY(), score);

      // Next request: change bubble target after correct
      const next = pickFood();
      setRequested(next);

      // ensure at least one food becomes correct now
      setTimeout(()=>{
        // respawn eaten element with new mix
        // respawnOne will make it correct if none exist
        respawnOne(el);
        // force one correct somewhere if needed
        if (!foodEls.some(f => f.dataset.good==="1")){
          // choose a random food element and set it correct
          const pick = foodEls[Math.floor(Math.random()*foodEls.length)];
          pick.src = requestedFood;
          pick.dataset.good = "1";
        }
        updateHud();
        checkGoal();
      }, 160);
    }

    function awardWrong(el){
      haptic("bad");
      showToast("WRONG SNACK ðŸ’€ streak nuked", "bad");

      // penalty: reset streak/mult, slight score penalty (optional)
      streak = 0;
      mult = 1.0;

      // small â€œfailâ€ animation
      el.style.transform = "scale(0.92) rotate(-3deg)";
      setTimeout(()=> el.style.transform = "", 180);

      // respawn wrong snack so belt stays moving
      setTimeout(()=> respawnOne(el), 120);

      updateHud();
    }

    function checkGoal(){
      const daily = getNum(DAILY_KEY(), 0);
      if (daily >= DAILY_GOAL){
        $("modeLabel").textContent = "Daily complete âœ…";
      } else {
        $("modeLabel").textContent = "Classic";
      }
      $("dailyGoal").textContent = DAILY_GOAL;
    }

    /***********************
     * LOOP: belt movement  *
     ***********************/
    let lastT = 0;

    function tick(t){
      if (!running) return;
      if (!lastT) lastT = t;
      const dt = Math.min(0.04, (t - lastT)/1000);
      lastT = t;

      computeBeltLane();
      const stageRect = stage.getBoundingClientRect();

      for (const el of foodEls){
        // if dragging, don't move it
        if (el.dataset.dragging === "1") continue;

        const vx = Number(el.dataset.vx || beltSpeed);
        const x = parseFloat(el.style.left || "0");
        const nx = x + vx * dt;

        el.style.left = `${nx}px`;

        // if off right side, wrap/respawn
        const globalX = stageRect.left + nx;
        if (globalX > beltRightEdge + 220){
          respawnOne(el);
        }
      }

      requestAnimationFrame(tick);
    }

    /***********************
     * DAILY RESET TIMER    *
     ***********************/
    function secondsToMidnight(){
      const now = new Date();
      const nxt = new Date(now);
      nxt.setHours(24,0,0,0);
      return Math.max(0, Math.floor((nxt-now)/1000));
    }
    function fmtTime(s){
      const h = Math.floor(s/3600);
      const m = Math.floor((s%3600)/60);
      const ss = s%60;
      return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
    }
    setInterval(()=>{
      $("resetIn").textContent = fmtTime(secondsToMidnight());
      updateHud();
      checkGoal();
    }, 500);

    /***********************
     * BUTTONS / SHARE      *
     ***********************/
    function restart(){
      score = 0;
      streak = 0;
      mult = 1.0;
      beltSpeed = BASE_BELT_SPEED;
      running = true;
      lastT = 0;
      spawnInitial();
      updateHud();
      checkGoal();
      requestAnimationFrame(tick);
    }

    $("btnRestart").addEventListener("click", restart);

    $("btnShare").addEventListener("click", async ()=>{
      const daily = getNum(DAILY_KEY(), 0);
      const best = getNum(BEST_KEY, 0);
      const msg =
        `ðŸ” $PHAT Conveyor Munch\n` +
        `Run: ${score} correct | Best: ${best}\n` +
        `Daily: ${daily}/${DAILY_GOAL}\n` +
        `planetfatness.fit`;
      try{
        await navigator.clipboard.writeText(msg);
        showToast("Copied flex to clipboard âœ…", "good");
      } catch {
        showToast("Copy failed â€” select and copy manually", "bad");
        alert(msg);
      }
    });

    /***********************
     * INIT                 *
     ***********************/
    // Preload images for smooth feel
    function preloadAll(){
      const srcs = [
        "assets/stack-base.png",
        "assets/conveyor.png",
        "assets/thought-bubble.png",
        "assets/mouth.png",
        ...FOODS
      ];
      srcs.forEach(s=>{
        const i = new Image();
        i.src = s;
      });
    }

    // Create belt foods and start loop
    preloadAll();
    spawnInitial();
    updateHud();
    checkGoal();
    requestAnimationFrame(tick);
  </script>
</body>
</html>