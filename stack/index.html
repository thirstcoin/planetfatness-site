<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>$PHAT ‚Äî Conveyor Munch</title>

  <style>
    :root{
      --bg1:#2b0b4a;
      --bg2:#14051f;
      --glass: rgba(255,255,255,.08);
      --stroke: rgba(255,255,255,.14);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.66);
      --accent:#ffd400;
      --ok:#33ff9a;
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --radius: 22px;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--text);
      background:
        radial-gradient(1100px 700px at 50% -100px, rgba(192,114,255,.35), transparent 60%),
        radial-gradient(900px 600px at 20% 10%, rgba(255,212,0,.14), transparent 55%),
        radial-gradient(900px 600px at 80% 20%, rgba(90,255,200,.10), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow-x:hidden;
      padding: env(safe-area-inset-top) 14px env(safe-area-inset-bottom) 14px;
    }
    .wrap{ max-width: 980px; margin: 0 auto; padding: 12px 0 28px; }

    .topRow{
      display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      margin-bottom: 12px;
    }
    .pillTitle{
      display:flex; align-items:center; gap:10px;
      padding: 10px 14px; border-radius: 999px;
      background: var(--glass); border: 1px solid var(--stroke);
      box-shadow: 0 12px 40px rgba(0,0,0,.22);
      user-select:none;
    }
    .subPill{
      flex: 1 1 420px; min-width: 280px;
      padding: 10px 14px; border-radius: 999px;
      background: var(--glass); border: 1px solid var(--stroke);
      color: var(--muted);
    }
    .btn{
      border:0; padding: 12px 16px; border-radius: 999px;
      font-weight: 900; cursor:pointer; user-select:none;
      box-shadow: var(--shadow); background: var(--accent); color: rgba(0,0,0,.85);
    }
    .btn.secondary{ background: rgba(255,255,255,.10); border: 1px solid var(--stroke); color: var(--text); box-shadow:none; }
    .btn:active{ transform: translateY(1px); }

    .statsRow{
      display:grid; grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px; margin-top: 10px; margin-bottom: 14px;
    }
    @media (max-width: 780px){ .statsRow{ grid-template-columns: 1fr; } .subPill{ flex:1 1 100%; } }

    .card{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: var(--radius);
      padding: 14px 14px;
      box-shadow: 0 18px 60px rgba(0,0,0,.22);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .kicker{ color: var(--muted); font-weight: 800; letter-spacing: .8px; font-size: 12px; }
    .big{ font-size: 34px; font-weight: 950; line-height: 1.0; margin-top: 4px; }
    .mini{ color: var(--muted); margin-top: 4px; font-weight: 700; }

    .stageCard{ padding: 12px; }
    .stage{
      position: relative;
      width: 100%;
      height: min(66vh, 620px);
      min-height: 520px;
      border-radius: calc(var(--radius) + 6px);
      overflow: hidden;
      background:
        radial-gradient(900px 500px at 50% 15%, rgba(255,255,255,.08), transparent 60%),
        radial-gradient(600px 340px at 60% 30%, rgba(255,212,0,.10), transparent 60%),
        linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.40));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 30px 90px rgba(0,0,0,.35);
    }

    /* LAYERING FIXES */
    .thought{ position:absolute; left: 50%; top: 7%; transform: translateX(-50%); width: min(500px, 90%); height: 190px; z-index: 60; pointer-events:none; }
    .character{ position:absolute; left: 50%; top: 33%; transform: translateX(-50%); width: min(520px, 92%); z-index: 30; pointer-events:none; filter: drop-shadow(0 22px 60px rgba(0,0,0,.55)); user-select:none; }
    .belt{ position:absolute; left: 50%; bottom: 5%; transform: translateX(-50%); width: min(860px, 120%); z-index: 40; pointer-events:none; opacity: .98; filter: drop-shadow(0 26px 70px rgba(0,0,0,.55)); user-select:none; }
    .foodItem{ position:absolute; width: 86px; height: 86px; transform: translate(-50%, -50%); z-index: 55; touch-action:none; user-select:none; cursor:grab; filter: drop-shadow(0 18px 40px rgba(0,0,0,.42)); }
    .foodItem:active{ cursor:grabbing; }

    .thought img{ width:100%; height:100%; object-fit: contain; filter: drop-shadow(0 18px 40px rgba(0,0,0,.35)); }

    /* Target INSIDE bubble */
    .thoughtTarget{
      position:absolute;
      left: 50%;
      top: 46%;
      transform: translate(-50%, -50%);
      width: 140px;
      height: 140px;
      display:grid;
      place-items:center;
      z-index: 70;
    }
    .thoughtTarget img{
      width: 118px;
      height: 118px;
      object-fit: contain;
      filter: drop-shadow(0 18px 40px rgba(0,0,0,.35));
    }
    .thoughtLabel{
      position:absolute;
      left: 50%;
      top: 78%;
      transform: translate(-50%, -50%);
      font-weight: 950;
      letter-spacing:.6px;
      color: rgba(255,255,255,.92);
      text-shadow: 0 10px 28px rgba(0,0,0,.55);
      font-size: 13px;
      white-space: nowrap;
      z-index: 70;
    }

    .floatingBanner{
      position:absolute;
      left:50%; top: 52%;
      transform: translate(-50%, -50%);
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.18);
      font-weight: 950;
      letter-spacing: .6px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .16s ease, transform .16s ease;
      text-align:center;
      z-index: 80;
    }
    .floatingBanner.show{ opacity: 1; transform: translate(-50%, -58%); }

    .mouthHit{
      position:absolute;
      left: 50%; top: 44%;
      width: 92px; height: 72px;
      transform: translate(-50%, -50%);
      border-radius: 999px;
      opacity: 0;
      pointer-events:none;
      background: rgba(51,255,154,.12);
      border: 2px solid rgba(51,255,154,.55);
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
      z-index: 75;
    }
    body.debug .mouthHit{ opacity: 1; }

    .debugPanel{
      margin-top: 12px;
      display:none;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
    }
    body.debug .debugPanel{ display:flex; }
    .tiny{ font-size: 12px; color: var(--muted); font-weight: 800; }
    .chip{
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.14);
      cursor:pointer;
      user-select:none;
      font-weight: 950;
    }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      padding: 10px 14px;
      background: rgba(0,0,0,.65);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 999px;
      color: rgba(255,255,255,.92);
      font-weight: 900;
      opacity: 0;
      pointer-events:none;
      transition: opacity .16s ease, transform .16s ease;
      z-index: 9999;
      text-align:center;
      max-width: 92vw;
    }
    .toast.show{ opacity: 1; transform: translateX(-50%) translateY(-6px); }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topRow">
      <div class="pillTitle" id="titleTap">
        <b>$PHAT ‚Äî Conveyor Munch</b>
        <span class="tiny" id="modeTag" style="margin-left:6px; opacity:.7;"></span>
      </div>
      <div class="subPill">Bubble shows what he wants. Belt runs nonstop. Drag the correct one into his mouth.</div>
      <button class="btn" id="restartBtn">Run it back</button>
      <button class="btn secondary" id="shareBtn">Share score</button>
    </div>

    <div class="statsRow">
      <div class="card">
        <div class="kicker">RUN</div>
        <div class="big"><span id="runCorrect">0</span> <span style="font-size:14px; font-weight:950; opacity:.7;">correct</span></div>
        <div class="mini">Streak: <span id="streak">0</span> ‚Ä¢ Mult: <span id="mult">1.00x</span></div>
      </div>
      <div class="card">
        <div class="kicker">BEST</div>
        <div class="big"><span id="best">0</span> <span style="font-size:14px; font-weight:950; opacity:.7;">correct</span></div>
        <div class="mini">Daily best: <span id="dailyBest">0</span></div>
      </div>
      <div class="card">
        <div class="kicker">DAILY GOAL</div>
        <div class="big"><span id="daily">0</span><span style="opacity:.7;"> / </span><span id="goal">30</span></div>
        <div class="mini">Resets in <span id="resetIn">--:--:--</span></div>
      </div>
    </div>

    <div class="card stageCard">
      <div class="stage" id="stage">
        <div class="thought">
          <img src="../assets/thought-bubble.png" alt="Thought bubble" draggable="false">
          <div class="thoughtTarget">
            <img id="targetImg" src="../assets/food_burger.png" alt="Target food" draggable="false">
          </div>
          <div class="thoughtLabel" id="targetName">BURGER</div>
        </div>

        <img class="character" id="character" src="../assets/stack_base.png" alt="Seated character" draggable="false">
        <div class="mouthHit" id="mouthHit"></div>

        <img class="belt" id="belt" src="../assets/conveyor.png" alt="Conveyor belt" draggable="false">

        <div class="floatingBanner" id="banner">MISSED</div>
      </div>

      <div class="debugPanel">
        <span class="tiny">Debug mouth align:</span>
        <span class="chip" data-move="-2,0">‚óÄ</span>
        <span class="chip" data-move="2,0">‚ñ∂</span>
        <span class="chip" data-move="0,-2">‚ñ≤</span>
        <span class="chip" data-move="0,2">‚ñº</span>
        <span class="chip" id="saveMouth">Save</span>
        <span class="tiny" id="mouthPos"></span>
      </div>
    </div>
  </div>

  <div class="toast" id="toast">Saved</div>

  <script>
    const ASSET = (p) => `../assets/${p}`;

    // Your actual file is stack_base.png (underscore)
    const CHARACTER_SRC = ASSET('stack_base.png');

    // Foods (must match your /assets list)
    const FOODS = [
      { file:'food_brownies.png', label:'BROWNIES' },
      { file:'food_burger.png', label:'BURGER' },
      { file:'food_cake.png', label:'CAKE' },
      { file:'food_chinese_takeout.png', label:'TAKEOUT' },
      { file:'food_cookie_pizza.png', label:'COOKIE PIZZA' },
      { file:'food_donut_stack.png', label:'DONUT STACK' },
      { file:'food_fried_chicken.png', label:'FRIED CHICKEN' },
      { file:'food_fries.png', label:'FRIES' },
      { file:'food_grilledcheese.png', label:'GRILLED CHEESE' },
      { file:'food_hotdogs.png', label:'HOTDOGS' },
      { file:'food_icecream_cone.png', label:'ICE CREAM' },
      { file:'food_milkshake_chocolate.png', label:'CHOC SHAKE' },
      { file:'food_milkshake_strawberry.png', label:'STRAW SHAKE' },
      { file:'food_milkshake_vanilla.png', label:'VANILLA SHAKE' },
      { file:'food_onion_rings.png', label:'ONION RINGS' },
    ];

    const DAILY_GOAL = 30;

    // CONVEYOR FEEL SETTINGS (more chaos, more variety)
    const MAX_FOODS = 14;            // aim ~10+ visible
    const START_FOODS = 10;          // load the belt immediately
    let beltSpeed = 165;             // px/sec baseline
    let spawnEvery = 240;            // ms baseline (fast)
    let laneY = 0;                   // computed
    let leftX = 0, rightX = 0;

    // Guarantee the target shows up regularly
    const TARGET_GUARANTEE_MS = 1200;
    let timeSinceTargetSpawn = 0;

    // Mouth hitbox offsets from stage center (px)
    const MOUTH_STORAGE_KEY = 'phat_mouth_v3';
    let mouth = { x: 0, y: -10, w: 92, h: 72 };

    const el = (id) => document.getElementById(id);
    const stage = el('stage');
    const targetImg = el('targetImg');
    const targetName = el('targetName');
    const banner = el('banner');
    const toast = el('toast');

    const runCorrectEl = el('runCorrect');
    const streakEl = el('streak');
    const multEl = el('mult');
    const bestEl = el('best');
    const dailyBestEl = el('dailyBest');
    const dailyEl = el('daily');
    const goalEl = el('goal');
    const resetInEl = el('resetIn');

    const restartBtn = el('restartBtn');
    const shareBtn = el('shareBtn');
    const characterEl = el('character');
    const mouthHit = el('mouthHit');

    // Game stats
    let runCorrect = 0;
    let streak = 0;
    let mult = 1.0;

    // Daily / best
    const DAY_KEY = () => new Date().toISOString().slice(0,10);
    const LS_BEST = 'phat_conv_best_v3';
    const LS_DAILY = 'phat_conv_daily_v3';
    const LS_DAILYBEST = 'phat_conv_dailybest_v3';

    let dailyDone = 0;
    let dailyBest = 0;
    let bestAll = 0;

    // Target food
    let target = null;

    // Food objects on belt
    // { id, food, x, y, dir, el }
    let foods = [];
    let nextId = 1;

    // Dragging
    let dragging = null;
    let dragOffset = {x:0,y:0};

    // Timing
    let lastTime = performance.now();
    let spawnTimer = 0;

    // Debug mode
    let tapCount = 0;
    let debug = false;

    // Variety ‚Äúdeck‚Äù so we don‚Äôt repeat 4 items forever
    let deck = [];
    function shuffle(a){
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
      }
      return a;
    }
    function nextFromDeck(){
      if(deck.length === 0){
        deck = shuffle([...FOODS]);
      }
      return deck.pop();
    }

    function safeLoadJSON(key, fallback){
      try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; }
      catch{ return fallback; }
    }

    function toastMsg(msg){
      toast.textContent = msg;
      toast.classList.add('show');
      setTimeout(()=>toast.classList.remove('show'), 1100);
    }

    function showBanner(msg){
      banner.textContent = msg;
      banner.classList.add('show');
      setTimeout(()=>banner.classList.remove('show'), 650);
    }

    function stageMetrics(){
      const r = stage.getBoundingClientRect();

      // Raise lane so food rides ‚Äúon‚Äù the conveyor, not below it
      laneY = r.height * 0.70;

      leftX = r.width * 0.06;
      rightX = r.width * 0.94;
    }

    function setMouth(){
      const r = stage.getBoundingClientRect();
      const cx = r.width/2;
      const cy = r.height/2;

      mouthHit.style.width = mouth.w + 'px';
      mouthHit.style.height = mouth.h + 'px';
      mouthHit.style.left = (cx + mouth.x) + 'px';
      mouthHit.style.top  = (cy + mouth.y) + 'px';

      el('mouthPos').textContent = `x:${mouth.x} y:${mouth.y}`;
    }

    function loadMouth(){
      const saved = safeLoadJSON(MOUTH_STORAGE_KEY, null);
      if(saved && typeof saved.x === 'number') mouth = { ...mouth, ...saved };
    }
    function saveMouth(){
      localStorage.setItem(MOUTH_STORAGE_KEY, JSON.stringify(mouth));
      toastMsg('Mouth saved');
    }

    function setDebugMode(on){
      debug = on;
      document.body.classList.toggle('debug', debug);
      el('modeTag').textContent = debug ? 'DEBUG' : '';
      setMouth();
    }

    function setDifficulty(){
      // speed up slightly with streak, but keep readable
      const s = Math.min(streak, 40);
      beltSpeed = 165 + s * 6.0;

      // keep spawns dense so ~10+ visible
      spawnEvery = Math.max(160, 240 - s * 2);

      mult = 1 + Math.floor(streak / 6) * 0.25;
      multEl.textContent = mult.toFixed(2) + 'x';
    }

    function setTarget(){
      target = nextFromDeck(); // also uses deck = more variety
      targetImg.src = ASSET(target.file);
      targetName.textContent = target.label;
    }

    function loadStats(){
      bestAll = parseInt(localStorage.getItem(LS_BEST) || '0', 10) || 0;

      const dailyObj = safeLoadJSON(LS_DAILY, { day: DAY_KEY(), done: 0 });
      dailyDone = (dailyObj.day === DAY_KEY()) ? (dailyObj.done || 0) : 0;
      localStorage.setItem(LS_DAILY, JSON.stringify({ day: DAY_KEY(), done: dailyDone }));

      const dbObj = safeLoadJSON(LS_DAILYBEST, { day: DAY_KEY(), best: 0 });
      dailyBest = (dbObj.day === DAY_KEY()) ? (dbObj.best || 0) : 0;
      localStorage.setItem(LS_DAILYBEST, JSON.stringify({ day: DAY_KEY(), best: dailyBest }));

      bestEl.textContent = bestAll;
      dailyEl.textContent = dailyDone;
      dailyBestEl.textContent = dailyBest;
      goalEl.textContent = DAILY_GOAL;
    }

    function saveBests(){
      if(runCorrect > bestAll){
        bestAll = runCorrect;
        localStorage.setItem(LS_BEST, String(bestAll));
        bestEl.textContent = bestAll;
      }
      if(runCorrect > dailyBest){
        dailyBest = runCorrect;
        localStorage.setItem(LS_DAILYBEST, JSON.stringify({ day: DAY_KEY(), best: dailyBest }));
        dailyBestEl.textContent = dailyBest;
      }
    }

    function addDaily(){
      dailyDone = Math.min(DAILY_GOAL, dailyDone + 1);
      localStorage.setItem(LS_DAILY, JSON.stringify({ day: DAY_KEY(), done: dailyDone }));
      dailyEl.textContent = dailyDone;
    }

    function secondsToHMS(s){
      const hh = String(Math.floor(s / 3600)).padStart(2,'0');
      const mm = String(Math.floor((s % 3600) / 60)).padStart(2,'0');
      const ss = String(Math.floor(s % 60)).padStart(2,'0');
      return `${hh}:${mm}:${ss}`;
    }

    function updateResetTimer(){
      const now = new Date();
      const next = new Date(now);
      next.setHours(24,0,0,0);
      const diff = Math.max(0, Math.floor((next - now) / 1000));
      resetInEl.textContent = secondsToHMS(diff);
    }

    function placeFoodEl(f){
      f.el.style.left = f.x + 'px';
      f.el.style.top = f.y + 'px';
    }

    function spawnFood(forceTarget=false){
      if(foods.length >= MAX_FOODS) return;

      const r = stage.getBoundingClientRect();
      const dir = Math.random() < 0.5 ? 1 : -1;
      const startX = dir === 1 ? (r.width * 0.02) : (r.width * 0.98);

      const food = forceTarget ? target : nextFromDeck();

      const img = document.createElement('img');
      img.className = 'foodItem';
      img.src = ASSET(food.file);
      img.alt = food.label;
      img.draggable = false;

      const obj = {
        id: nextId++,
        food,
        dir,
        x: startX,
        y: laneY,
        el: img
      };

      img.addEventListener('pointerdown', (e)=>pointerDown(e, obj), { passive:false });

      stage.appendChild(img);
      foods.push(obj);
      placeFoodEl(obj);
    }

    function removeFood(obj){
      obj.el.remove();
      foods = foods.filter(f => f.id !== obj.id);
      if(dragging && dragging.id === obj.id) dragging = null;
    }

    function missTarget(){
      streak = 0;
      streakEl.textContent = streak;
      setDifficulty();
      showBanner('MISSED');
    }

    function wrongSnack(){
      streak = 0;
      streakEl.textContent = streak;
      setDifficulty();
      showBanner('WRONG');
    }

    function munch(perfect){
      const base = perfect ? 2 : 1;
      const gained = Math.round(base * mult);

      runCorrect += gained;
      streak += 1;

      runCorrectEl.textContent = runCorrect;
      streakEl.textContent = streak;

      addDaily();
      setDifficulty();
      saveBests();

      showBanner(perfect ? `PERFECT +${gained}` : `NICE +${gained}`);

      // rotate target more often so it feels like a ‚Äúnew order‚Äù
      if(Math.random() < 0.60) setTarget();
    }

    function hitTestMouth(clientX, clientY){
      const mh = mouthHit.getBoundingClientRect();
      const inside = (clientX >= mh.left && clientX <= mh.right && clientY >= mh.top && clientY <= mh.bottom);
      if(!inside) return { inside:false, perfect:false };

      const cx = (mh.left + mh.right)/2;
      const cy = (mh.top + mh.bottom)/2;
      const dx = clientX - cx, dy = clientY - cy;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const perfect = dist < Math.min(mh.width, mh.height) * 0.22;
      return { inside:true, perfect };
    }

    function pointerDown(e, obj){
      e.preventDefault();
      dragging = obj;
      obj.el.setPointerCapture?.(e.pointerId);

      const fr = obj.el.getBoundingClientRect();
      dragOffset.x = e.clientX - (fr.left + fr.width/2);
      dragOffset.y = e.clientY - (fr.top + fr.height/2);
    }

    function pointerMove(e){
      if(!dragging) return;
      e.preventDefault();

      const sr = stage.getBoundingClientRect();
      dragging.x = (e.clientX - sr.left) - dragOffset.x;
      dragging.y = (e.clientY - sr.top) - dragOffset.y;
      placeFoodEl(dragging);
    }

    function pointerUp(e){
      if(!dragging) return;
      e.preventDefault();

      const dropped = dragging;
      dragging = null;

      const ht = hitTestMouth(e.clientX, e.clientY);
      if(ht.inside){
        if(dropped.food.file === target.file){
          munch(ht.perfect);
          removeFood(dropped);
        }else{
          wrongSnack();
          dropped.y = laneY;
          placeFoodEl(dropped);
        }
        return;
      }

      dropped.y = laneY;
      placeFoodEl(dropped);
    }

    async function shareScore(){
      const text =
`$PHAT Conveyor Munch
‚úÖ Correct: ${runCorrect}
üî• Streak: ${streak}
üéØ Daily: ${dailyDone}/${DAILY_GOAL}
Play: planetfatness.fit/stack`;

      try{
        if(navigator.share){
          await navigator.share({ title: '$PHAT ‚Äî Conveyor Munch', text });
          toastMsg('Shared');
        }else{
          await navigator.clipboard.writeText(text);
          toastMsg('Copied');
        }
      }catch{
        try{ await navigator.clipboard.writeText(text); toastMsg('Copied'); }
        catch{ toastMsg('Share blocked'); }
      }
    }

    function resetRun(){
      for(const f of foods){ f.el.remove(); }
      foods = [];
      dragging = null;

      runCorrect = 0;
      streak = 0;
      mult = 1.0;

      runCorrectEl.textContent = runCorrect;
      streakEl.textContent = streak;
      multEl.textContent = mult.toFixed(2) + 'x';

      // rebuild deck and set a fresh target
      deck = [];
      setTarget();
      setDifficulty();

      spawnTimer = 0;
      timeSinceTargetSpawn = 0;
      lastTime = performance.now();

      // Start with lots already visible
      for(let i=0;i<START_FOODS;i++){
        spawnFood(i === 2); // make sure at least one early target appears
      }
    }

    function tick(now){
      const dt = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;

      spawnTimer += dt * 1000;
      timeSinceTargetSpawn += dt * 1000;

      // Force the target to appear regularly so ‚ÄúMISSED‚Äù is fair/visible
      const shouldForceTarget = timeSinceTargetSpawn >= TARGET_GUARANTEE_MS;

      while(spawnTimer >= spawnEvery){
        spawnTimer -= spawnEvery;

        if(shouldForceTarget){
          spawnFood(true);
          timeSinceTargetSpawn = 0;
        }else{
          spawnFood(false);
        }
      }

      const r = stage.getBoundingClientRect();

      for(const f of foods){
        if(!(dragging && dragging.id === f.id)){
          f.x += (beltSpeed * dt) * f.dir;
          f.y = laneY;
          placeFoodEl(f);
        }

        const escapedLeft = f.x < r.width * -0.10;
        const escapedRight = f.x > r.width * 1.10;

        if(escapedLeft || escapedRight){
          // Only miss if the TARGET escaped
          if(f.food.file === target.file){
            missTarget();
          }
          removeFood(f);
          break;
        }
      }

      requestAnimationFrame(tick);
    }

    (function boot(){
      characterEl.src = CHARACTER_SRC;

      loadMouth();
      loadStats();
      updateResetTimer();
      setInterval(updateResetTimer, 250);

      const onResize = () => {
        stageMetrics();
        setMouth();
        for(const f of foods){
          if(!(dragging && dragging.id === f.id)){
            f.y = laneY;
            placeFoodEl(f);
          }
        }
      };
      window.addEventListener('resize', onResize, { passive:true });
      onResize();

      window.addEventListener('pointermove', pointerMove, { passive:false });
      window.addEventListener('pointerup', pointerUp, { passive:false });
      window.addEventListener('pointercancel', pointerUp, { passive:false });

      restartBtn.addEventListener('click', () => { saveBests(); resetRun(); toastMsg('Run reset'); });
      shareBtn.addEventListener('click', shareScore);

      // debug toggle: tap title 7 times
      el('titleTap').addEventListener('click', () => {
        tapCount++;
        if(tapCount >= 7){
          tapCount = 0;
          setDebugMode(!debug);
          toastMsg(debug ? 'Debug ON' : 'Debug OFF');
        }
      });

      document.querySelectorAll('.chip[data-move]').forEach(chip=>{
        chip.addEventListener('click', ()=>{
          const [dx,dy] = chip.getAttribute('data-move').split(',').map(n=>parseInt(n,10));
          mouth.x += dx; mouth.y += dy;
          setMouth();
        });
      });
      el('saveMouth').addEventListener('click', saveMouth);

      resetRun();
      requestAnimationFrame(tick);
    })();
  </script>
</body>
</html>