<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>$PHAT — Conveyor Munch</title>
  <style>
    :root{
      --bg1:#1b0b2a;
      --bg2:#3b145c;
      --card: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --good:#79ffb0;
      --bad:#ff6a7a;
      --accent:#ffd84d;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--text);
      background: radial-gradient(1000px 600px at 50% 0%, rgba(255,255,255,.10), transparent 60%),
                  linear-gradient(180deg, var(--bg2), var(--bg1));
      min-height:100vh;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
    }
    .wrap{
      max-width: 560px;
      margin: 0 auto;
      padding: 18px 16px 28px;
    }
    .top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom: 12px;
    }
    .pill{
      padding: 10px 14px;
      border-radius: 999px;
      background: var(--card);
      border: 1px solid var(--stroke);
      backdrop-filter: blur(10px);
      font-weight: 700;
      letter-spacing:.3px;
    }
    .btn{
      border:0;
      padding: 10px 14px;
      border-radius: 999px;
      background: var(--accent);
      color: #2a1b00;
      font-weight: 900;
      cursor:pointer;
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    .sub{
      margin: 10px 0 14px;
      padding: 14px 14px;
      border-radius: 18px;
      background: var(--card);
      border: 1px solid var(--stroke);
      backdrop-filter: blur(10px);
      color: var(--muted);
      line-height: 1.25;
    }
    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin-bottom: 14px;
    }
    .stat{
      padding: 12px 12px;
      border-radius: 18px;
      background: var(--card);
      border: 1px solid var(--stroke);
      backdrop-filter: blur(10px);
      min-height: 76px;
    }
    .stat .label{
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 1px;
      font-weight: 800;
    }
    .stat .big{
      font-size: 28px;
      font-weight: 950;
      margin-top: 6px;
      line-height: 1;
    }
    .stat .small{
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .gameCard{
      position:relative;
      border-radius: 26px;
      overflow:hidden;
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border: 1px solid var(--stroke);
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
      padding: 14px;
    }
    .arena{
      position:relative;
      width:100%;
      aspect-ratio: 9 / 13;
      border-radius: 22px;
      overflow:hidden;
      background: radial-gradient(900px 700px at 50% 0%, rgba(255,255,255,.10), transparent 60%),
                  linear-gradient(180deg, rgba(0,0,0,.20), rgba(0,0,0,.45));
      border: 1px solid rgba(255,255,255,.10);
      touch-action: none;
    }

    /* Scene */
    #scene{
      position:absolute;
      left:50%;
      bottom:0%;
      transform: translateX(-50%);
      width: 132%;
      max-width:none;
      height:auto;
      user-select:none;
      pointer-events:none;
      z-index: 10;
    }

    /* Thought bubble: sit right on top of head */
    .thoughtWrap{
      position:absolute;
      left:50%;
      top: 19%;                 /* ✅ head-top placement */
      transform: translateX(-50%);
      width: 54%;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 8px;
      pointer-events:none;
      user-select:none;
      z-index: 60;
    }

    /* ✅ food name ABOVE bubble */
    #thoughtLabel{
      padding: 7px 14px;
      border-radius: 999px;
      background: rgba(0,0,0,.26);
      border: 1px solid rgba(255,255,255,.16);
      backdrop-filter: blur(10px);
      font-weight: 950;
      letter-spacing: 4px;
      font-size: 18px;
      text-align:center;
      text-shadow: 0 10px 18px rgba(0,0,0,.45);
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .bubbleBox{
      position:relative;
      width:100%;
      display:block;
      filter: drop-shadow(0 12px 18px rgba(0,0,0,.25));
    }
    #thoughtBubble{
      width:100%;
      height:auto;
      display:block;
    }
    #thoughtFood{
      position:absolute;
      left:50%;
      top: 46%;
      transform: translate(-50%, -50%);
      width: 46%;
      height:auto;
      filter: drop-shadow(0 10px 14px rgba(0,0,0,.25));
    }

    /* Toast */
    #toast{
      position:absolute;
      left:50%;
      top: 56%;
      transform: translateX(-50%);
      padding: 10px 16px;
      border-radius: 999px;
      font-weight: 950;
      letter-spacing: 1px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.15);
      backdrop-filter: blur(10px);
      opacity:0;
      transition: opacity .18s ease, transform .18s ease;
      pointer-events:none;
      user-select:none;
      z-index: 80;
    }
    #toast.show{ opacity:1; transform: translateX(-50%) translateY(-4px); }
    #toast.good{ color: var(--good); }
    #toast.bad{ color: var(--bad); }

    /* Food items */
    .food{
      position:absolute;
      left:0;
      top:0;
      transform: translate3d(-9999px,-9999px,0);
      will-change: transform;
      user-select:none;
      -webkit-user-drag:none;
      touch-action:none;
      cursor: grab;
      filter: drop-shadow(0 14px 22px rgba(0,0,0,.40));
      z-index: 30;
    }
    .food.dragging{
      cursor: grabbing;
      filter: drop-shadow(0 20px 28px rgba(0,0,0,.52));
      z-index: 95;
    }

    /* Debug */
    .debugLine{
      position:absolute;
      left:0;
      width:100%;
      height:2px;
      background: rgba(0,255,160,.65);
      pointer-events:none;
      display:none;
      z-index: 99;
    }
    .debugMouth{
      position:absolute;
      border: 2px dashed rgba(0,255,160,.75);
      pointer-events:none;
      display:none;
      z-index: 99;
    }
    .debugOn .debugLine,
    .debugOn .debugMouth{ display:block; }

    .how{
      margin-top: 12px;
      padding: 14px 14px;
      border-radius: 18px;
      background: var(--card);
      border: 1px solid var(--stroke);
      color: var(--muted);
      line-height: 1.35;
    }
    .how b{ color: var(--text); }
    .row{
      display:flex;
      gap:10px;
      margin-top: 10px;
    }
    .ghostBtn{
      flex:1;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.12);
      color: var(--text);
      font-weight: 800;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="pill">$PHAT — Conveyor Munch</div>
      <button class="btn" id="restartBtn">Run it back</button>
    </div>

    <div class="sub">
      Drag the snack into his mouth. Miss = pain. Streak = glory.
    </div>

    <div class="stats">
      <div class="stat">
        <div class="label">RUN</div>
        <div class="big"><span id="runCorrect">0</span></div>
        <div class="small">Streak: <span id="streak">0</span> · Mult: <span id="mult">1.0x</span></div>
      </div>
      <div class="stat">
        <div class="label">BEST</div>
        <div class="big"><span id="best">0</span></div>
        <div class="small">Daily best: <span id="dailyBest">0</span></div>
      </div>
      <div class="stat">
        <div class="label">DAILY GOAL</div>
        <div class="big"><span id="dailyCount">0</span> / 30</div>
        <div class="small">Resets in <span id="resetIn">--:--:--</span></div>
      </div>
    </div>

    <div class="gameCard">
      <div class="arena" id="arena">
        <div class="thoughtWrap" id="thoughtWrap">
          <div id="thoughtLabel">---</div>
          <div class="bubbleBox">
            <img id="thoughtBubble" src="../assets/thought-bubble.png" alt="thought" />
            <img id="thoughtFood" src="" alt="wanted" />
          </div>
        </div>

        <img id="scene" src="../assets/stack_scene.png" alt="scene" />

        <div id="toast">MISSED</div>

        <div class="debugLine" id="debugLine"></div>
        <div class="debugMouth" id="debugMouth"></div>
      </div>

      <div class="row">
        <button class="ghostBtn" id="shareBtn">Share score</button>
        <button class="ghostBtn" id="debugBtn">Toggle debug</button>
      </div>

      <div class="how">
        <b>How it plays:</b> The thought bubble shows what he wants. The belt feeds a nonstop stream of snacks.
        Grab the correct one <b>between the wrong choices</b> and drag it to his mouth before it rolls away.
      </div>
    </div>
  </div>

<script>
(() => {
  const PATH_SCENE  = "../assets/stack_scene.png";
  const PATH_BUBBLE = "../assets/thought-bubble.png";

  const FOODS = [
    { key:"brownies",  label:"BROWNIES",         src:"../assets/food_brownies.png" },
    { key:"burger",    label:"BURGER",           src:"../assets/food_burger.png" },
    { key:"cake",      label:"CAKE",             src:"../assets/food_cake.png" },
    { key:"takeout",   label:"TAKEOUT",          src:"../assets/food_chinese_takeout.png" },

    /* ✅ rename cookie pizza -> Pizookie */
    { key:"pizookie",  label:"PIZOOKIE",         src:"../assets/food_cookie_pizza.png" },

    { key:"donuts",    label:"DONUT STACK",      src:"../assets/food_donut_stack.png" },
    { key:"chicken",   label:"FRIED CHICKEN",    src:"../assets/food_fried_chicken.png" },
    { key:"fries",     label:"FRIES",            src:"../assets/food_fries.png" },
    { key:"grilled",   label:"GRILLED CHEESE",   src:"../assets/food_grilledcheese.png" },
    { key:"hotdogs",   label:"HOTDOGS",          src:"../assets/food_hotdogs.png" },
    { key:"icecream",  label:"ICE CREAM",        src:"../assets/food_icecream_cone.png" },
    { key:"shakechoc", label:"CHOC SHAKE",       src:"../assets/food_milkshake_chocolate.png" },
    { key:"shakestr",  label:"STRAWBERRY SHAKE", src:"../assets/food_milkshake_strawberry.png" },
    { key:"shakevan",  label:"VANILLA SHAKE",    src:"../assets/food_milkshake_vanilla.png" },
    { key:"onion",     label:"ONION RINGS",      src:"../assets/food_onion_rings.png" },
  ];

  // --- Tunables ---
  // Belt line for your current stack_scene.png (tweak only if needed later)
  let BELT_Y_PCT = 0.735;

  // ✅ FIX: make mouth hitbox larger + slightly higher so drops register reliably
  // (this is why your “completed task” stopped registering — hitbox was too low/tight vs the new scene scaling)
  let MOUTH = { x: 0.50, y: 0.515, w: 0.26, h: 0.18 };

  // Pressure
  const MAX_ONSCREEN = 7;
  const SPAWN_EVERY_MS = 720;
  const MIN_SPACING_PX = 64;
  const DESPAWN_PAD = 160;

  const BASE_SPEED = 150;
  const SPEED_PER_STREAK = 6;
  const MAX_SPEED = 260;

  // ✅ 3x bigger than what you had on-screen: hard bump + big max
  // (old was 0.12 with max ~112px. This targets ~160–220px depending on device width)
  const FOOD_SIZE_PCT = 0.34;

  const arena = document.getElementById("arena");
  const sceneImg = document.getElementById("scene");
  const thoughtFood = document.getElementById("thoughtFood");
  const thoughtLabel = document.getElementById("thoughtLabel");
  const toast = document.getElementById("toast");
  const restartBtn = document.getElementById("restartBtn");
  const shareBtn = document.getElementById("shareBtn");
  const debugBtn = document.getElementById("debugBtn");
  const debugLine = document.getElementById("debugLine");
  const debugMouth = document.getElementById("debugMouth");

  const runCorrectEl = document.getElementById("runCorrect");
  const streakEl = document.getElementById("streak");
  const multEl = document.getElementById("mult");
  const bestEl = document.getElementById("best");
  const dailyBestEl = document.getElementById("dailyBest");
  const dailyCountEl = document.getElementById("dailyCount");
  const resetInEl = document.getElementById("resetIn");

  sceneImg.src = PATH_SCENE;

  let arenaRect = null;
  let beltY = 0;
  let foodSize = 140;
  let mouthRect = null;

  let runCorrect = 0;
  let streak = 0;
  let best = 0;

  let target = null;
  let items = [];
  let lastSpawnAt = 0;
  let lastFrame = performance.now();

  let dragging = null;
  let debugOn = false;

  const todayKey = () => {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${day}`;
  };
  const LS = {
    dailyKey: "phat_stack_daily_key",
    dailyBest: "phat_stack_daily_best",
    dailyCount: "phat_stack_daily_count",
  };

  function loadDaily() {
    const k = localStorage.getItem(LS.dailyKey);
    const t = todayKey();
    if (k !== t) {
      localStorage.setItem(LS.dailyKey, t);
      localStorage.setItem(LS.dailyBest, "0");
      localStorage.setItem(LS.dailyCount, "0");
    }
    dailyBestEl.textContent = Number(localStorage.getItem(LS.dailyBest) || "0");
    dailyCountEl.textContent = Number(localStorage.getItem(LS.dailyCount) || "0");
  }

  function bumpDailyCount() {
    const v = Number(localStorage.getItem(LS.dailyCount) || "0") + 1;
    localStorage.setItem(LS.dailyCount, String(v));
    dailyCountEl.textContent = v;
    const db = Number(localStorage.getItem(LS.dailyBest) || "0");
    if (v > db) {
      localStorage.setItem(LS.dailyBest, String(v));
      dailyBestEl.textContent = v;
    }
  }

  function updateResetTimer() {
    const now = new Date();
    const next = new Date(now);
    next.setHours(24,0,0,0);
    const ms = next - now;
    const s = Math.max(0, Math.floor(ms/1000));
    const hh = String(Math.floor(s/3600)).padStart(2,"0");
    const mm = String(Math.floor((s%3600)/60)).padStart(2,"0");
    const ss = String(s%60).padStart(2,"0");
    resetInEl.textContent = `${hh}:${mm}:${ss}`;
  }

  function recalc() {
    arenaRect = arena.getBoundingClientRect();
    beltY = arenaRect.height * BELT_Y_PCT;

    // ✅ big readable food size
    foodSize = Math.max(140, Math.min(240, Math.floor(arenaRect.width * FOOD_SIZE_PCT)));

    // mouth hitbox
    mouthRect = {
      left: arenaRect.left + arenaRect.width * (MOUTH.x - MOUTH.w/2),
      top:  arenaRect.top  + arenaRect.height * (MOUTH.y - MOUTH.h/2),
      width: arenaRect.width * MOUTH.w,
      height: arenaRect.height * MOUTH.h
    };

    debugLine.style.top = `${beltY}px`;
    debugMouth.style.left = `${arenaRect.width * (MOUTH.x - MOUTH.w/2)}px`;
    debugMouth.style.top  = `${arenaRect.height * (MOUTH.y - MOUTH.h/2)}px`;
    debugMouth.style.width  = `${arenaRect.width * MOUTH.w}px`;
    debugMouth.style.height = `${arenaRect.height * MOUTH.h}px`;

    for (const it of items) {
      it.el.style.width = `${foodSize}px`;
      it.el.style.height = `${foodSize}px`;
      if (!it.dragging) it.y = beltY - foodSize * 0.66;
      renderItem(it);
    }
  }

  function pickTarget() {
    target = FOODS[Math.floor(Math.random() * FOODS.length)];
    thoughtFood.src = target.src;
    thoughtLabel.textContent = target.label;
  }

  function getSpeed() {
    return Math.min(MAX_SPEED, BASE_SPEED + streak * SPEED_PER_STREAK);
  }

  function canSpawnAtX(x) {
    for (const it of items) {
      if (it.dragging) continue;
      if (Math.abs(it.x - x) < MIN_SPACING_PX) return false;
    }
    return true;
  }

  function renderItem(it) {
    it.el.style.transform = `translate3d(${it.x}px, ${it.y}px, 0)`;
  }

  let toastTimer = null;
  function showToast(text, good) {
    toast.textContent = text;
    toast.classList.remove("good","bad","show");
    toast.classList.add(good ? "good" : "bad");
    void toast.offsetWidth;
    toast.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toast.classList.remove("show"), 520);
  }

  function rectsOverlap(a, b) {
    return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);
  }

  function itemRectOnScreen(it) {
    const left = arenaRect.left + it.x;
    const top  = arenaRect.top + it.y;
    return { left, top, right:left+foodSize, bottom:top+foodSize };
  }

  function createFoodItem(food) {
    const el = document.createElement("img");
    el.className = "food";
    el.draggable = false;
    el.src = food.src;
    el.alt = food.label;
    arena.appendChild(el);

    const it = {
      food,
      el,
      x: arenaRect.width + 30,
      y: beltY - foodSize * 0.66,
      vx: -getSpeed(),
      dragging: false,
    };

    el.style.width = `${foodSize}px`;
    el.style.height = `${foodSize}px`;

    el.addEventListener("pointerdown", (e) => onPointerDown(e, it), { passive:false });
    return it;
  }

  function onPointerDown(e, it) {
    e.preventDefault();
    e.stopPropagation();
    recalc();

    it.dragging = true;
    it.el.classList.add("dragging");
    it.el.setPointerCapture(e.pointerId);

    const r = itemRectOnScreen(it);
    const offsetX = e.clientX - r.left;
    const offsetY = e.clientY - r.top;

    dragging = { it, offsetX, offsetY, pointerId: e.pointerId };
    it.vx = 0;

    it.el.addEventListener("pointermove", onPointerMove, { passive:false });
    it.el.addEventListener("pointerup", onPointerUp, { passive:false });
    it.el.addEventListener("pointercancel", onPointerUp, { passive:false });
  }

  function onPointerMove(e) {
    if (!dragging) return;
    e.preventDefault();
    const it = dragging.it;
    it.x = e.clientX - arenaRect.left - dragging.offsetX;
    it.y = e.clientY - arenaRect.top  - dragging.offsetY;
    renderItem(it);
  }

  function removeItem(it) {
    const idx = items.indexOf(it);
    if (idx >= 0) items.splice(idx, 1);
    it.el.remove();
  }

  function updateHUD() {
    runCorrectEl.textContent = runCorrect;
    streakEl.textContent = streak;
    const mult = (1 + Math.min(0.9, streak * 0.05)).toFixed(1);
    multEl.textContent = `${mult}x`;
    bestEl.textContent = best;
  }

  function onPointerUp(e) {
    if (!dragging) return;
    e.preventDefault();

    const it = dragging.it;

    it.el.removeEventListener("pointermove", onPointerMove);
    it.el.removeEventListener("pointerup", onPointerUp);
    it.el.removeEventListener("pointercancel", onPointerUp);

    it.el.classList.remove("dragging");
    it.dragging = false;

    recalc();

    const r = itemRectOnScreen(it);
    const mouth = {
      left: mouthRect.left,
      top: mouthRect.top,
      right: mouthRect.left + mouthRect.width,
      bottom: mouthRect.top + mouthRect.height
    };

    const hit = rectsOverlap(r, mouth);

    if (hit) {
      if (it.food.key === target.key) {
        runCorrect++;
        streak++;
        best = Math.max(best, runCorrect);
        bumpDailyCount();
        showToast("CHOMP!", true);
        pickTarget();
        removeItem(it);
      } else {
        streak = 0;
        showToast("WRONG SNACK", false);
        removeItem(it);
      }
    } else {
      // snap back to belt lane
      it.y = beltY - foodSize * 0.66;
      it.vx = -getSpeed();
      renderItem(it);
    }

    dragging = null;
    updateHUD();
  }

  function handleMiss(it) {
    if (it.food.key === target.key) {
      streak = 0;
      showToast("MISSED", false);
      pickTarget();
    }
    removeItem(it);
    updateHUD();
  }

  function tick(now) {
    const dt = Math.min(0.05, (now - lastFrame) / 1000);
    lastFrame = now;

    if (!arenaRect) recalc();

    if (!lastSpawnAt) lastSpawnAt = now;
    if (items.length < MAX_ONSCREEN && now - lastSpawnAt >= SPAWN_EVERY_MS) {
      lastSpawnAt = now;

      const roll = Math.random();
      const f = (roll < 0.22) ? target : FOODS[Math.floor(Math.random() * FOODS.length)];

      const spawnX = arenaRect.width + 24;
      if (canSpawnAtX(spawnX)) items.push(createFoodItem(f));
    }

    for (let i = items.length - 1; i >= 0; i--) {
      const it = items[i];
      if (it.dragging) continue;

      it.vx = -getSpeed();
      it.x += it.vx * dt;

      it.y = beltY - foodSize * 0.66;
      renderItem(it);

      if (it.x < -DESPAWN_PAD) handleMiss(it);
    }

    requestAnimationFrame(tick);
  }

  function restart() {
    for (const it of items) it.el.remove();
    items = [];
    dragging = null;
    runCorrect = 0;
    streak = 0;
    best = 0;
    pickTarget();
    updateHUD();
    showToast("RUN IT", true);
  }

  restartBtn.addEventListener("click", restart);

  shareBtn.addEventListener("click", async () => {
    const daily = Number(localStorage.getItem(LS.dailyCount) || "0");
    const text = `$PHAT Conveyor Munch — Run: ${runCorrect} | Daily: ${daily}/30`;
    try{
      if (navigator.share) await navigator.share({ text });
      else {
        await navigator.clipboard.writeText(text);
        showToast("COPIED", true);
      }
    } catch(_) {}
  });

  debugBtn.addEventListener("click", () => {
    debugOn = !debugOn;
    arena.classList.toggle("debugOn", debugOn);
    showToast(debugOn ? "DEBUG ON" : "DEBUG OFF", true);
  });

  window.addEventListener("resize", recalc);
  arena.addEventListener("touchmove", (e) => e.preventDefault(), { passive:false });

  function preloadImages() {
    const urls = [PATH_SCENE, PATH_BUBBLE, ...FOODS.map(f => f.src)];
    for (const u of urls) { const img = new Image(); img.src = u; }
  }

  loadDaily();
  updateResetTimer();
  setInterval(updateResetTimer, 1000);

  preloadImages();
  pickTarget();
  updateHUD();

  sceneImg.onload = () => recalc();
  sceneImg.onerror = () => showToast("SCENE PATH WRONG", false);

  requestAnimationFrame(() => {
    recalc();
    requestAnimationFrame(tick);
  });
})();
</script>
</body>
</html>