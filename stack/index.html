<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"/>
<title>$PHAT — Snack Stack</title>

<style>
:root{
  --purple:#5b2cff;
  --yellow:#ffd400;
  --bg0:#07050c;
  --bg1:#140b2b;
  --panel:rgba(255,255,255,.08);
  --stroke:rgba(255,255,255,.14);
  --text:rgba(255,255,255,.95);
  --muted:rgba(255,255,255,.68);
  --shadow:0 30px 90px rgba(0,0,0,.55);
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  color:var(--text);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  background:
    radial-gradient(1100px 650px at 20% 10%, rgba(91,44,255,.35), transparent 55%),
    radial-gradient(900px 560px at 85% 20%, rgba(255,212,0,.22), transparent 60%),
    radial-gradient(900px 560px at 55% 120%, rgba(255,212,0,.10), transparent 60%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
  overflow:hidden;
}

/* Layout */
#wrap{
  height:100dvh;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:12px;
  padding:14px;
}

.row{
  width:min(980px,100%);
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
}

.pill{
  padding:10px 14px;
  border-radius:999px;
  background:var(--panel);
  border:1px solid var(--stroke);
  font-size:13px;
  font-weight:1000;
  color:var(--muted);
  backdrop-filter: blur(10px);
  user-select:none;
  white-space:nowrap;
}

.btn{
  padding:10px 16px;
  border-radius:14px;
  font-weight:1100;
  background:linear-gradient(180deg,var(--yellow),#ffbf00);
  color:#1b1400;
  border:none;
  box-shadow:0 14px 30px rgba(255,212,0,.45);
}
.btn:active{transform:scale(.98)}

#stage{
  width:min(980px,100%);
  flex:1;
  position:relative;
  display:flex;
  align-items:stretch;
}

#frame{
  position:relative;
  width:100%;
  height:100%;
  border-radius:22px;
  border:1px solid var(--stroke);
  background: rgba(0,0,0,.12);
  box-shadow:var(--shadow);
  overflow:hidden;
  touch-action:manipulation;
}

/* hero (background art) */
#heroWrap{
  position:absolute; inset:0;
  display:flex;
  align-items:flex-end;
  justify-content:center;
  pointer-events:none;
}

#hero{
  width:min(560px, 88%);
  height:auto;
  max-height:92%;
  transform-origin:center bottom;
  filter: drop-shadow(0 26px 42px rgba(0,0,0,.55));
  opacity:.98;
}

/* canvas draws foods + table line */
canvas{
  position:absolute; inset:0;
  width:100%;
  height:100%;
  display:block;
}

/* HUD inside frame */
#hud{
  position:absolute;
  left:14px; top:14px;
  display:flex;
  flex-direction:column;
  gap:6px;
  pointer-events:none;
}
#hud .tiny{
  font-size:12px;
  font-weight:1000;
  color:rgba(255,255,255,.82);
  text-shadow: 0 8px 24px rgba(0,0,0,.55);
}
#hud .muted{color:rgba(255,255,255,.62); font-weight:900}

/* calories bar overlay */
#calBar{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  bottom:58px;
  width:min(620px, 86%);
  height:18px;
  border-radius:999px;
  background:rgba(255,255,255,.12);
  border:1px solid rgba(255,255,255,.12);
  overflow:hidden;
  pointer-events:none;
}
#calFill{
  height:100%;
  width:0%;
  background:linear-gradient(180deg,#7fff7f,#3bdc7a);
  opacity:.9;
}
#calLabel{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  bottom:84px;
  padding:9px 14px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.35);
  backdrop-filter: blur(12px);
  font-size:13px;
  font-weight:1100;
  color:rgba(255,255,255,.86);
  pointer-events:none;
}

/* bottom pills */
.hint{
  width:min(980px,100%);
  display:flex;
  justify-content:space-between;
  gap:10px;
  flex-wrap:wrap;
}

/* end modal */
#modalBack{
  position:fixed; inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,.62);
  backdrop-filter: blur(10px);
  z-index:50;
}
#modal{
  width:min(760px, calc(100% - 28px));
  border-radius:24px;
  border:1px solid var(--stroke);
  background:
    radial-gradient(900px 420px at 20% 0%, rgba(91,44,255,.32), transparent 60%),
    radial-gradient(900px 520px at 80% 80%, rgba(255,212,0,.16), transparent 65%),
    rgba(255,255,255,.06);
  box-shadow:0 40px 140px rgba(0,0,0,.65);
  padding:18px;
}
.stat{
  border-radius:18px;
  border:1px solid var(--stroke);
  background:rgba(0,0,0,.25);
  padding:14px;
  margin-bottom:10px;
}
.stat .k{color:var(--muted);font-weight:1000;font-size:13px}
.stat .v{font-size:34px;font-weight:1200; letter-spacing:-.5px}
.actions{display:flex;gap:12px;flex-wrap:wrap}
.ghost{
  padding:10px 14px;border-radius:14px;
  background:rgba(0,0,0,.30);border:1px solid var(--stroke);
  color:#fff;font-weight:1100;
}
</style>
</head>

<body>
<div id="wrap">
  <div class="row">
    <div class="pill">$PHAT — Snack Stack</div>
    <div class="pill" id="status">Drop snacks. Keep it straight. Pretend it’s discipline.</div>
    <button class="btn" id="restart">Run it back</button>
  </div>

  <div id="stage">
    <div id="frame">
      <div id="heroWrap">
        <!-- Put your seated character PNG here -->
        <img id="hero" src="../assets/snack_hero.png" alt="Planet Fatness Snack Stack Hero"/>
      </div>

      <div id="hud">
        <div class="tiny">Stack: <span id="stackN">0</span></div>
        <div class="tiny muted">Perfects: <span id="perfectN">0</span></div>
        <div class="tiny muted">Calories earned: <span id="earnedN">0</span></div>
      </div>

      <div id="calLabel">Calories today</div>
      <div id="calBar"><div id="calFill"></div></div>

      <canvas id="c"></canvas>
    </div>
  </div>

  <div class="hint">
    <div class="pill">Calories today: <span id="today">0</span> / 1000</div>
    <div class="pill">Gym resets in <span id="reset">--:--:--</span></div>
    <div class="pill">Best stack: <span id="best">0</span></div>
  </div>
</div>

<div id="modalBack">
  <div id="modal">
    <div class="stat"><div class="k">Final stack</div><div class="v" id="mStack">0</div></div>
    <div class="stat"><div class="k">Calories earned</div><div class="v" id="mCal">0</div></div>
    <div class="stat"><div class="k">Status</div><div class="v" id="mLine">Folded like a napkin</div></div>
    <div class="actions">
      <button class="btn" id="again">Run it back</button>
      <button class="ghost" id="close">Close</button>
    </div>
  </div>
</div>

<script>
/* =========================
   Snack Stack — real stacking
   ========================= */

const CAP = 1000;

// Keep these filenames matching what you uploaded.
// Put foods in /assets/ with these exact names (or edit the list).
const FOOD_FILES = [
  "../assets/food_burger.png",
  "../assets/food_brownies.png",
  "../assets/food_donuts.png",
  "../assets/food_pizza_stack.png",
  "../assets/food_pancakes.png",
  "../assets/food_grilled_cheese.png",
  "../assets/food_icecream_cone.png",
  "../assets/food_chinese_takeout.png",
  "../assets/food_onion_rings.png",
  "../assets/food_popcorn.png",
  "../assets/food_soda.png",
  "../assets/food_hotdogs.png",
  "../assets/food_sub.png",
  "../assets/food_fried_chicken.png",
  "../assets/food_cookie_pizza.png",
  "../assets/food_strawberry_milkshake.png",
  "../assets/food_chocolate_milkshake.png",
  "../assets/food_vanilla_milkshake.png",
  "../assets/food_fries_bucket.png",
  "../assets/food_cake.png"
];

// DOM
const c = document.getElementById("c");
const ctx = c.getContext("2d");

const stackEl = document.getElementById("stackN");
const perfectEl = document.getElementById("perfectN");
const earnedEl = document.getElementById("earnedN");

const todayEl = document.getElementById("today");
const resetEl = document.getElementById("reset");
const bestEl = document.getElementById("best");
const calFill = document.getElementById("calFill");

const modalBack = document.getElementById("modalBack");
const mStack = document.getElementById("mStack");
const mCal = document.getElementById("mCal");
const mLine = document.getElementById("mLine");

// Local day reset
function nextResetMs(){
  const d = new Date();
  const t = new Date(d.getFullYear(), d.getMonth(), d.getDate() + 1);
  return t.getTime();
}
let resetAt = Number(localStorage.getItem("phat_reset") || nextResetMs());
let today = Number(localStorage.getItem("phat_today") || 0);
if (Date.now() > resetAt){
  today = 0;
  resetAt = nextResetMs();
  localStorage.setItem("phat_today", today);
  localStorage.setItem("phat_reset", resetAt);
}
todayEl.textContent = today;

// Best stack
let bestStack = Number(localStorage.getItem("phat_best_stack") || 0);
bestEl.textContent = bestStack;

// Canvas resize (full frame)
function resize(){
  const rect = c.getBoundingClientRect();
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  c.width  = Math.floor(rect.width * dpr);
  c.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
}
window.addEventListener("resize", resize);
resize();

// Game metrics (computed after resize)
function W(){ return c.getBoundingClientRect().width; }
function H(){ return c.getBoundingClientRect().height; }

// Table/floor line where stacks sit (tuned for the seated hero PNG)
function floorY(){
  return H() * 0.78; // adjust if you want, but this fits the hero/table look
}

// Physics
let lastT = performance.now();
let running = true;
let gameOver = false;

const placed = [];
let current = null;
let currentDropped = false;

let stackCount = 0;
let perfectCount = 0;
let earned = 0;

const GRAVITY_SCALE = 2.25; // relative to screen height
const SWAY_SPEED = 0.48;    // horizontal drift speed
const MAX_SWAY = 0.30;      // percent of width from center

// Preload images
const imgCache = new Map();
function loadImage(src){
  return new Promise((resolve,reject)=>{
    if (imgCache.has(src)) return resolve(imgCache.get(src));
    const im = new Image();
    im.onload = ()=>{ imgCache.set(src, im); resolve(im); };
    im.onerror = reject;
    im.src = src;
  });
}

async function preload(){
  // load all, but don't die if one fails — missing ones just won't spawn
  const tasks = FOOD_FILES.map(f => loadImage(f).catch(()=>null));
  const res = await Promise.all(tasks);
  return res.filter(Boolean);
}

let FOOD_IMGS = [];

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// Hitbox helpers (tight, stack-friendly)
function makeFood(im){
  const cw = W(), ch = H();
  const baseW = cw * 0.23;            // food width
  const w = clamp(baseW, 88, 170);    // good mobile range
  const ratio = im.naturalHeight / im.naturalWidth || 1;
  const h = clamp(w * ratio, 70, 150);

  // Collision box: tighter than sprite so it "touches"
  const hitW = w * 0.86;
  const hitH = h * 0.66;

  return {
    im,
    x: cw * 0.5,
    y: -h,
    w, h,
    hitW, hitH,
    vx: 0,
    vy: 0,
    placed: false,
    // used for sway before drop
    swayT: 0,
    swayDir: Math.random() < 0.5 ? -1 : 1
  };
}

function aabb(a,b){
  return !(
    a.x + a.hitW/2 < b.x - b.hitW/2 ||
    a.x - a.hitW/2 > b.x + b.hitW/2 ||
    a.y + a.hitH/2 < b.y - b.hitH/2 ||
    a.y - a.hitH/2 > b.y + b.hitW/2 // typo guard? nope, fix below
  );
}
// fix: last line should be b.hitH/2, not hitW
function aabb2(a,b){
  return !(
    a.x + a.hitW/2 < b.x - b.hitW/2 ||
    a.x - a.hitW/2 > b.x + b.hitW/2 ||
    a.y + a.hitH/2 < b.y - b.hitH/2 ||
    a.y - a.hitH/2 > b.y + b.hitH/2
  );
}

// UI update
function refreshHUD(){
  stackEl.textContent = String(stackCount);
  perfectEl.textContent = String(perfectCount);
  earnedEl.textContent = String(earned);

  todayEl.textContent = String(today);
  calFill.style.width = (today / CAP * 100).toFixed(2) + "%";
  bestEl.textContent = String(bestStack);
}

function addCalories(amount){
  if (today >= CAP) return;
  const add = Math.max(0, Math.floor(amount));
  earned += add;
  today = Math.min(CAP, today + add);
  localStorage.setItem("phat_today", String(today));
  localStorage.setItem("phat_reset", String(resetAt));
  refreshHUD();
}

function endGame(reason){
  if (gameOver) return;
  gameOver = true;

  if (stackCount > bestStack){
    bestStack = stackCount;
    localStorage.setItem("phat_best_stack", String(bestStack));
  }

  const lines = [
    "Folded like a napkin",
    "Gravity called… you answered",
    "Stack went on a diet (it quit)",
    "Plate said “nah”",
    "Respectfully… that was criminal"
  ];
  mLine.textContent = reason || lines[Math.random()*lines.length|0];

  mStack.textContent = String(stackCount);
  mCal.textContent = String(earned);

  modalBack.style.display = "flex";
  refreshHUD();
}

// Spawn next food
function spawnNext(){
  if (!FOOD_IMGS.length) return;

  const im = FOOD_IMGS[(Math.random()*FOOD_IMGS.length)|0];
  current = makeFood(im);

  // If there is a stack, spawn above it, centered, and sway starts fresh
  current.y = -current.h;
  currentDropped = false;
}

// Perfect placement logic
function placementScore(dx, w){
  // dx is absolute center offset
  const perfect = w * 0.08;
  const good = w * 0.18;

  if (dx <= perfect) return { tag:"perfect", cal: 16 };
  if (dx <= good)    return { tag:"good",    cal: 12 };
  return             { tag:"meh",     cal: 8  };
}

// Drop action: tap/click to drop the current snack
function drop(){
  if (!running || gameOver) return;
  if (!current) return;
  if (currentDropped) return;
  currentDropped = true;
  current.vy = 0;
}

// Pointer controls: tap = drop; (before drop it still sways automatically)
window.addEventListener("pointerdown", (e)=>{
  // if modal open, ignore
  if (modalBack.style.display === "flex") return;
  drop();
});

// Main update
function update(dt){
  if (gameOver) return;
  const cw = W(), ch = H();
  const floor = floorY();

  // always have one current
  if (!current) spawnNext();

  // Sway before dropping
  if (current && !currentDropped){
    current.swayT += dt * SWAY_SPEED;
    const amp = cw * MAX_SWAY;
    const center = cw * 0.5;
    // smooth wave sway
    current.x = center + Math.sin(current.swayT * Math.PI * 2) * amp;
    // keep within safe bounds
    const margin = cw * 0.12;
    current.x = clamp(current.x, margin, cw - margin);
    // keep it just above top
    current.y = -current.h * 0.85;
    return;
  }

  // Falling
  if (current && currentDropped){
    const GRAVITY = ch * GRAVITY_SCALE; // px/s^2 relative to view
    current.vy += GRAVITY * dt;
    current.y  += current.vy * dt;

    // Collision with stack top or floor
    const top = placed[placed.length - 1];

    // If no stack, collide with floor
    if (!top){
      if (current.y + current.hitH/2 >= floor){
        // land
        current.y = floor - current.hitH/2;
        current.placed = true;

        placed.push(current);
        stackCount++;

        // reward
        addCalories(10);

        spawnNext();
      }

      // miss (fell too low somehow)
      if (current.y > ch + 200){
        endGame("Snack escaped the plate");
      }
      return;
    }

    // If there is a stack: first check miss horizontally when below top
    const missMargin = cw * 0.08;
    const leftBound = missMargin;
    const rightBound = cw - missMargin;

    if (current.x < leftBound || current.x > rightBound){
      // drifting off-screen = instant shame
      endGame("Snack rolled into the void");
      return;
    }

    // If it intersects the top, snap on it
    if (aabb2(current, top) || (current.y + current.hitH/2 >= (top.y - top.hitH/2))){
      // only accept landing if the overlap isn't absurd
      const dx = Math.abs(current.x - top.x);

      // Too far off-center = fall (game over)
      const failDx = top.hitW * 0.58;
      if (dx > failDx){
        endGame("Stack said “not my problem”");
        return;
      }

      // Snap exactly onto the top
      current.y = (top.y - top.hitH/2) - current.hitH/2;
      current.vy = 0;
      current.placed = true;

      placed.push(current);
      stackCount++;

      // Perfect scoring
      const score = placementScore(dx, top.hitW);
      if (score.tag === "perfect") perfectCount++;

      // Calories scale slightly as stack grows (but still capped daily)
      const base = score.cal;
      const bonus = Math.min(10, Math.floor(stackCount / 6)); // mild ramp
      addCalories(base + bonus);

      // subtle “tighten” as you get deeper: smaller allowable failDx via top.hitW already handled by size
      spawnNext();
      return;
    }

    // Also collide with floor if somehow below floor (rare)
    if (current.y + current.hitH/2 >= floor){
      // landed on floor = only ok if stack empty; otherwise that means dropped past stack
      endGame("Snack hit the table, not the stack");
      return;
    }

    // Fell out of world
    if (current.y > ch + 240){
      endGame("Snack vanished for emotional reasons");
      return;
    }
  }
}

// Render
function draw(){
  const cw = W(), ch = H();
  ctx.clearRect(0,0,cw,ch);

  // soft vignette
  const g = ctx.createRadialGradient(cw*0.5, ch*0.45, ch*0.10, cw*0.5, ch*0.55, ch*0.75);
  g.addColorStop(0, "rgba(0,0,0,0)");
  g.addColorStop(1, "rgba(0,0,0,0.55)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,cw,ch);

  // Table line (invisible-ish but helps the brain)
  const fy = floorY();
  ctx.fillStyle = "rgba(255,255,255,0.06)";
  ctx.fillRect(cw*0.18, fy+2, cw*0.64, 2);

  // Draw placed foods
  for (const p of placed){
    drawFood(p);
  }

  // Draw current
  if (current){
    drawFood(current);
  }
}

function drawFood(o){
  // sprite centered on x, with visual y tied to hitbox center (so it visually sits tight)
  const x = o.x - o.w/2;
  const y = o.y - o.h/2 + (o.h - o.hitH) * 0.22;

  // tiny baked-in shadow (looks like it’s actually sitting)
  ctx.save();
  const shadowW = o.hitW * 0.95;
  const shadowH = Math.max(6, o.hitH * 0.10);
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.ellipse(o.x, o.y + o.hitH/2 - 2, shadowW/2, shadowH/2, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  ctx.drawImage(o.im, x, y, o.w, o.h);
}

// Loop
function frame(t){
  const dt = Math.min(0.033, (t - lastT)/1000);
  lastT = t;
  if (running){
    update(dt);
    draw();
  }
  requestAnimationFrame(frame);
}

// Reset timer text
function tick(){
  const r = Math.max(0, resetAt - Date.now());
  const h = String(Math.floor(r/36e5)).padStart(2,'0');
  const m = String(Math.floor((r%36e5)/6e4)).padStart(2,'0');
  const s = String(Math.floor((r%6e4)/1e3)).padStart(2,'0');
  resetEl.textContent = `${h}:${m}:${s}`;

  // daily reset live
  if (Date.now() > resetAt){
    today = 0;
    resetAt = nextResetMs();
    localStorage.setItem("phat_today", String(today));
    localStorage.setItem("phat_reset", String(resetAt));
    refreshHUD();
  }
}
setInterval(tick, 1000);

// Buttons
document.getElementById("restart").onclick = ()=>location.reload();
document.getElementById("again").onclick = ()=>location.reload();
document.getElementById("close").onclick = ()=>{ modalBack.style.display = "none"; };

// Start
(async function start(){
  FOOD_IMGS = await preload();

  // If you want a guaranteed “burger first” vibe, un-comment this:
  // FOOD_IMGS.sort((a,b)=> (a.src.includes("burger") ? -1 : 1));

  refreshHUD();
  tick();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>