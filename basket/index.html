<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>$PHAT ‚Äî Streak Shot</title>

  <!-- ‚úÖ Shared UI (matches your other games) -->
  <link rel="stylesheet" href="/assets/pf-ui.css">
  <script src="/assets/pf-ui.js" defer></script>

  <style>
    :root{
      --pf-purple:#6b2cff;
      --pf-yellow:#ffd400;
      --pf-ink:#0b0b12;
      --pf-muted: rgba(255,255,255,.72);
      --safe-top: env(safe-area-inset-top);
      --safe-bottom: env(safe-area-inset-bottom);
    }

    *{
      box-sizing:border-box;
      -webkit-tap-highlight-color:transparent;
      -webkit-touch-callout:none;
      user-select:none;
    }

    html,body{
      margin:0;
      min-height:100%;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1200px 900px at 50% 15%, rgba(107,44,255,.35), transparent 55%),
        radial-gradient(1000px 700px at 50% 90%, rgba(255,212,0,.18), transparent 55%),
        linear-gradient(180deg, var(--pf-ink), #05050c);
      color:#fff;
      overflow-x:hidden;
      overflow-y:auto;
      -webkit-overflow-scrolling: touch;
    }

    .pf-wrap{
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding: 16px 0 calc(26px + var(--safe-bottom));
    }
    .pf-container{
      width:min(980px, 94vw);
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .pf-metrics{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .pf-metricsLeft{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .pf-chip strong{ color: var(--pf-yellow); }

    #stage{
      position:relative;
      width:100%;
      border-radius:20px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.12);
      box-shadow:0 30px 90px rgba(0,0,0,.55);
      background:
        radial-gradient(900px 600px at 50% 0%, rgba(255,212,0,.09), transparent 55%),
        radial-gradient(900px 600px at 50% 100%, rgba(107,44,255,.11), transparent 55%),
        rgba(0,0,0,.18);
    }

    .arenaVideo{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit:cover;
      z-index:0;
      filter:saturate(1.05) contrast(1.03);
      transform: translateZ(0);
    }
    .arenaVignette{
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
      background:
        radial-gradient(1200px 700px at 50% 10%, rgba(255,212,0,.10), transparent 55%),
        radial-gradient(1200px 700px at 50% 100%, rgba(107,44,255,.14), transparent 60%),
        linear-gradient(180deg, rgba(0,0,0,.20), rgba(0,0,0,.42));
      mix-blend-mode:multiply;
    }

    canvas{
      position:relative;
      z-index:1;
      display:block;
      width:100%;
      height:520px;
      touch-action:none;
    }
    @media (max-width: 520px){
      canvas{ height: 62vh; }
    }

    .toast{
      position:absolute; left:50%; bottom:14px;
      transform:translateX(-50%);
      padding:10px 12px;
      border-radius:999px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.12);
      color:#fff;
      font-weight:1000;
      font-size:12px;
      opacity:0;
      transition: opacity .18s ease, transform .18s ease;
      pointer-events:none;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 18px rgba(255,212,0,.25), 0 0 32px rgba(107,44,255,.18);
      white-space:nowrap;
      z-index:5;
    }
    .toast.show{ opacity:1; transform:translateX(-50%) translateY(-2px); }

    .pf-hints{
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .pf-hintPill{
      padding:10px 14px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      font-size:13px;
      font-weight:900;
      color: rgba(255,255,255,.75);
      backdrop-filter: blur(10px);
      box-shadow:0 18px 60px rgba(0,0,0,.35);
      white-space:nowrap;
    }

    .overlay{
      position:absolute; inset:0;
      display:none; align-items:center; justify-content:center;
      background: rgba(0,0,0,.65);
      backdrop-filter: blur(10px);
      padding:16px;
      z-index:10;
    }
    .overlay.show{ display:flex; }

    .card{
      width:min(760px,100%);
      border-radius:24px;
      border:1px solid rgba(255,255,255,.14);
      background:
        radial-gradient(900px 420px at 20% 0%, rgba(91,44,255,.32), transparent 60%),
        radial-gradient(900px 520px at 80% 80%, rgba(255,212,0,.16), transparent 65%),
        rgba(255,255,255,.06);
      box-shadow:0 40px 140px rgba(0,0,0,.65);
      overflow:hidden;
      padding:18px;
    }
    .card h2{ margin:0 0 6px; font-size:20px; font-weight:1000; letter-spacing:.2px; }
    .card p{ margin:0 0 12px; color:rgba(255,255,255,.75); font-weight:800; line-height:1.35; }

    .mini{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .statCard{
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      padding:14px;
    }
    .statCard .k{ font-weight:900; color:rgba(255,255,255,.72); font-size:13px; margin-bottom:6px; }
    .statCard .v{ font-weight:1100; font-size:34px; letter-spacing:-.5px; color:rgba(255,212,0,.95); }

    .row{ display:flex; gap:12px; flex-wrap:wrap; margin-top:12px; }
    .btnOld{
      padding:10px 16px;
      border-radius:14px;
      font-weight:1000;
      background:linear-gradient(180deg, var(--pf-yellow), #ffbf00);
      color:#1b1400;
      border:none;
      box-shadow:0 14px 30px rgba(255,212,0,.45);
      cursor:pointer;
      flex:1;
      min-width: 160px;
    }
    .btnGhost{
      padding:10px 14px;
      border-radius:14px;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.14);
      color:rgba(255,255,255,.9);
      font-weight:1000;
      cursor:pointer;
      flex:1;
      min-width: 160px;
    }
    .btnOld:active, .btnGhost:active{ transform: scale(.98); }

    .divider{ height:1px; background: rgba(255,255,255,.10); margin:14px 0; }

    .leader{
      max-height: 240px; overflow:auto;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      padding:10px;
    }
    .leader table{ width:100%; border-collapse:collapse; font-size:13px; }
    .leader th,.leader td{ padding:8px 6px; text-align:left; border-bottom:1px solid rgba(255,255,255,.08); }
    .leader th{ color:rgba(255,255,255,.70); font-size:11px; letter-spacing:.35px; }

    .lbTabs{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      margin-top:10px;
    }
    .lbTab{
      padding:9px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      color: rgba(255,255,255,.82);
      cursor:pointer;
    }
    .lbTab.active{
      background: linear-gradient(180deg, rgba(255,212,0,.22), rgba(255,212,0,.10));
      border-color: rgba(255,212,0,.30);
      color:#fff;
    }

    .pf-bottom{
      position: sticky;
      bottom: calc(10px + var(--safe-bottom));
      z-index: 40;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
  </style>
</head>

<body>
  <div class="pf-wrap">
    <div class="pf-container">

      <div class="pf-top">
        <div class="pf-title">
          <div class="pf-titleLine">$PHAT ‚Äî Streak Shot</div>
          <div class="pf-subLine">One miss ends the run. Golden donuts are double.</div>
        </div>
        <div class="pf-chip" id="status">Drag to shoot</div>
      </div>

      <div class="pf-metrics">
        <div class="pf-metricsLeft">
          <div class="pf-chip">STREAK <strong id="streakTxt">0</strong></div>
          <div class="pf-chip">SCORE <strong id="scoreTxt">0</strong></div>
          <div class="pf-chip">RUN BEST <strong id="runBestTxt">0</strong></div>
          <div class="pf-chip">FOOD <strong id="foodTxt">‚Äî</strong></div>
          <div class="pf-chip">MULTI <strong id="multiTxt">1√ó</strong></div>
          <div class="pf-chip">RIM <strong id="rimTxt">MOVING</strong></div>
        </div>
      </div>

      <div id="stage">
        <video
          class="arenaVideo"
          id="arenaVid"
          autoplay
          muted
          loop
          playsinline
          preload="auto"
          poster="/assets/streakshot_bg_gym.png"
        >
          <source src="/assets/arena-crowd-loop.mp4" type="video/mp4" />
        </video>
        <div class="arenaVignette"></div>

        <canvas id="cv"></canvas>
        <div class="toast" id="toast"></div>

        <div class="overlay show" id="overlayStart">
          <div class="card">
            <h2>One miss ends the run.</h2>
            <p>Drag from the food in his hands ‚Ä¢ Release to shoot ‚Ä¢ Miss ends run ‚Ä¢ Golden = 2√ó</p>
            <div class="row">
              <button class="btnOld" id="btnGo">Run It</button>
              <button class="btnGhost" id="btnCloseStart">Not Yet</button>
            </div>
          </div>
        </div>

        <div class="overlay" id="overlayEnd">
          <div class="card">
            <h2>Run over.</h2>
            <p id="endLine">Saved automatically if you‚Äôre logged in.</p>

            <div class="mini">
              <div class="statCard">
                <div class="k">FINAL STREAK</div>
                <div class="v" id="finalStreakTxt">0</div>
              </div>
              <div class="statCard">
                <div class="k">FINAL SCORE</div>
                <div class="v" id="finalScoreTxt">0</div>
              </div>
            </div>

            <div class="divider"></div>

            <div class="row">
              <button class="btnOld" id="btnSave">Save</button>
              <button class="btnGhost" id="btnShare">Share</button>
            </div>

            <div class="lbTabs">
              <button class="lbTab active" id="tabGlobal">Global</button>
              <button class="lbTab" id="tabLocal">Local</button>
              <button class="lbTab" id="tabRefresh">Refresh</button>
            </div>

            <div class="divider"></div>

            <div class="leader" id="leaderBoxEnd"></div>

            <div class="divider"></div>

            <div class="row">
              <button class="btnOld" id="btnAgain">Run It Back</button>
              <button class="btnGhost" id="btnCloseEnd">Close</button>
            </div>
          </div>
        </div>
      </div>

      <div class="pf-hints">
        <div class="pf-hintPill">Controls: Drag from the food ‚Ä¢ Release to shoot</div>
        <div class="pf-hintPill">Miss = End ‚Ä¢ Golden = 2√ó</div>
      </div>

      <div class="pf-bottom">
        <button class="pf-btn pf-primary" id="btnStart">Start</button>
        <button class="pf-btn" id="shareBtn" data-pf-share="basket">Share</button>
        <button class="pf-btn" id="lbBtn">Leaderboard</button>
        <button class="pf-btn" id="backBtn">‚Üê Back to Gym</button>
      </div>

    </div>
  </div>

<script>
(() => {
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;

  function readLS(key){
    try { return (localStorage.getItem(key)||'').trim(); } catch { return ''; }
  }
  function writeJSON(key, obj){
    try { localStorage.setItem(key, JSON.stringify(obj)); } catch {}
  }
  function readJSON(key){
    try { return JSON.parse(localStorage.getItem(key)||'null'); } catch { return null; }
  }

  const API_BASE =
    (window.PF_API_BASE) ||
    readLS('pf_api_base') ||
    readLS('phat_api_base') ||
    '';

  function getToken(){
    return readLS('pf_token') || readLS('phat_token') || readLS('token');
  }

  function isLoggedIn(){
    return !!(String(API_BASE).trim() && String(getToken()).trim());
  }

  function fmtIdent(row){
    const dn = (row.display_name || row.displayName || row.name || '').trim();
    const addr = String(row.address || '').trim();
    if (dn) return dn;
    if (addr.startsWith('tg:')) return 'TG:' + addr.slice(3);
    if (addr) return addr.slice(0,4)+'‚Ä¶'+addr.slice(-4);
    return '‚Äî';
  }

  // ===== Local leaderboard (fallback + ‚Äúsave local‚Äù) =====
  const LB_KEY='pf_streakshot_local_v2';
  const loadLB=()=>{try{return JSON.parse(localStorage.getItem(LB_KEY)||'[]');}catch{return[];}};
  const saveLB=(rows)=>{ try{ localStorage.setItem(LB_KEY,JSON.stringify(rows)); }catch{} };

  function addLB(streak, score){
    const rows=loadLB();
    rows.push({streak, score, at:Date.now()});
    rows.sort((a,b)=> (b.streak-a.streak) || (b.score-a.score));
    saveLB(rows.slice(0,30));
  }

  function renderLocalLB(el){
    const rows=loadLB();
    if(!rows.length){
      el.innerHTML='<div style="color:rgba(255,255,255,.7);font-weight:900;">No local runs yet.</div>';
      return;
    }
    const fmt=(ts)=>{
      const d=new Date(ts);
      return d.toLocaleDateString(undefined,{month:'short',day:'numeric'})+' '+d.toLocaleTimeString(undefined,{hour:'numeric',minute:'2-digit'});
    };
    let html='<table><thead><tr><th>#</th><th>Streak</th><th>Score</th><th>When</th></tr></thead><tbody>';
    rows.forEach((r,i)=>{
      html+=`<tr>
        <td>${i+1}</td>
        <td style="font-weight:1100;color:rgba(255,212,0,.95)">${r.streak}</td>
        <td>${r.score}</td>
        <td style="color:rgba(255,255,255,.65)">${fmt(r.at)}</td>
      </tr>`;
    });
    html+='</tbody></table>';
    el.innerHTML=html;
  }

    // ===== Global leaderboard (server) =====
  async function fetchGlobalLB(){
    if (!String(API_BASE).trim()) return null;

    const base = String(API_BASE).replace(/\/$/,'');
    const tries = [
      `${base}/leaderboard/v2?window=lifetime&metric=streak&game=basket&limit=30`,
      `${base}/leaderboard/v2?window=lifetime&metric=score&game=basket&limit=30`,
      `${base}/leaderboard/game?game=basket&metric=streak&limit=30`,
      `${base}/leaderboard/game?game=basket&metric=score&limit=30`,
    ];

    for (const url of tries){
      try{
        const r = await fetch(url, { headers: { 'Accept':'application/json' } });
        if (!r.ok) continue;
        const j = await r.json().catch(()=>null);
        if (Array.isArray(j)) return j;
        if (j && Array.isArray(j.rows)) return j.rows;
      }catch{}
    }
    return null;
  }

  function getMetricRowValue(row){
    // handles different backend shapes
    if (row.value != null) return Number(row.value)||0;
    if (row.streak != null) return Number(row.streak)||0;
    if (row.best_streak != null) return Number(row.best_streak)||0;
    if (row.bestStreak != null) return Number(row.bestStreak)||0;
    if (row.score != null) return Number(row.score)||0;
    if (row.best_score != null) return Number(row.best_score)||0;
    if (row.bestScore != null) return Number(row.bestScore)||0;
    return 0;
  }

  function renderGlobalLB(el, rows){
    if (!rows || !rows.length){
      el.innerHTML =
        `<div style="color:rgba(255,255,255,.78);font-weight:900;">
          No global rows yet (or endpoint not wired).<br/>
          <span style="color:rgba(255,255,255,.60);font-weight:800;">If you‚Äôre logged in, your run still saves calories globally.</span>
        </div>`;
      return;
    }

    // sort by ‚Äúbest streak then best score‚Äù if present; else by value
    const mapped = rows.map(r => {
      const streak = (r.best_streak ?? r.bestStreak ?? r.streak ?? null);
      const score  = (r.best_score  ?? r.bestScore  ?? r.score  ?? null);
      return {
        raw: r,
        ident: fmtIdent(r),
        streak: streak != null ? Number(streak)||0 : null,
        score: score != null ? Number(score)||0 : null,
        value: getMetricRowValue(r),
      };
    });

    mapped.sort((a,b)=>{
      const as = (a.streak ?? -1), bs = (b.streak ?? -1);
      if (bs !== as) return bs - as;
      const ac = (a.score ?? -1), bc = (b.score ?? -1);
      if (bc !== ac) return bc - ac;
      return (b.value - a.value);
    });

    let html =
      `<table>
        <thead>
          <tr>
            <th>#</th>
            <th>Identity</th>
            <th>Best Streak</th>
            <th>Best Score</th>
          </tr>
        </thead>
        <tbody>`;

    mapped.slice(0,30).forEach((r,i)=>{
      const streak = (r.streak != null) ? r.streak : (r.value||0);
      const score  = (r.score  != null) ? r.score  : 0;
      html +=
        `<tr>
          <td>${i+1}</td>
          <td style="font-weight:900;">${escapeHtml(r.ident)}</td>
          <td style="font-weight:1100;color:rgba(255,212,0,.95)">${Number(streak||0)}</td>
          <td>${Number(score||0)}</td>
        </tr>`;
    });

    html += `</tbody></table>`;
    el.innerHTML = html;
  }

  function escapeHtml(s){
    return String(s || "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  async function submitSecureSession({ score, streak, durationMs }){
    if (!isLoggedIn()) return { ok:false, skipped:true };

    try{
      const url = `${String(API_BASE).replace(/\/$/,'')}/activity/submit`;
      const r = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type':'application/json',
          'Authorization': `Bearer ${String(getToken()).trim()}`,
        },
        body: JSON.stringify({
          game: 'basket',
          score,
          streak,
          durationMs
        })
      });

      const data = await r.json().catch(()=>null);
      if (!r.ok) return { ok:false, status:r.status, data };
      return { ok:true, data };
    }catch(e){
      return { ok:false, error:String(e && e.message ? e.message : e) };
    }
  }

  // ===== DOM refs =====
  const stage=document.getElementById('stage');
  const cv=document.getElementById('cv');
  const ctx=cv.getContext('2d');

  const arenaVid = document.getElementById('arenaVid');
  if (arenaVid){
    const tryPlay = async () => { try { await arenaVid.play(); } catch(e){} };
    document.addEventListener('touchstart', tryPlay, { once:true, passive:true });
    document.addEventListener('click', tryPlay, { once:true, passive:true });
    tryPlay();
  }

  const statusEl = document.getElementById('status');

  const streakTxt=document.getElementById('streakTxt');
  const scoreTxt=document.getElementById('scoreTxt');
  const runBestTxt=document.getElementById('runBestTxt');
  const foodTxt=document.getElementById('foodTxt');
  const multiTxt=document.getElementById('multiTxt');
  const rimTxt=document.getElementById('rimTxt');

  const toast=document.getElementById('toast');

  const overlayStart=document.getElementById('overlayStart');
  const overlayEnd=document.getElementById('overlayEnd');

  const finalStreakTxt=document.getElementById('finalStreakTxt');
  const finalScoreTxt=document.getElementById('finalScoreTxt');
  const endLine=document.getElementById('endLine');

  const leaderBoxEnd=document.getElementById('leaderBoxEnd');

  const btnStart=document.getElementById('btnStart');
  const btnGo=document.getElementById('btnGo');
  const btnCloseStart=document.getElementById('btnCloseStart');

  const btnAgain=document.getElementById('btnAgain');
  const btnCloseEnd=document.getElementById('btnCloseEnd');
  const btnSave=document.getElementById('btnSave');
  const btnShare=document.getElementById('btnShare');

  const shareBtn=document.getElementById('shareBtn');
  const lbBtn=document.getElementById('lbBtn');
  const backBtn=document.getElementById('backBtn');

  const tabGlobal = document.getElementById('tabGlobal');
  const tabLocal  = document.getElementById('tabLocal');
  const tabRefresh= document.getElementById('tabRefresh');

  let lbMode = 'global';
  let cachedGlobalRows = null;

  lbBtn.onclick = () => { window.location.href = '../index.html#leaderboard'; };
  backBtn.onclick = () => { window.location.href = '../index.html#gym'; };

  function setBtnSaveLabel(){
    if (isLoggedIn()){
      btnSave.textContent = 'Save (Global)';
    } else {
      btnSave.textContent = 'Save (Local)';
    }
  }

  async function renderActiveLB(){
    if (lbMode === 'local'){
      renderLocalLB(leaderBoxEnd);
      return;
    }
    if (!cachedGlobalRows){
      leaderBoxEnd.innerHTML = `<div style="color:rgba(255,255,255,.70);font-weight:900;">Loading global leaderboard‚Ä¶</div>`;
      cachedGlobalRows = await fetchGlobalLB();
    }
    renderGlobalLB(leaderBoxEnd, cachedGlobalRows);
  }

  function setActiveTab(){
    tabGlobal.classList.toggle('active', lbMode==='global');
    tabLocal.classList.toggle('active', lbMode==='local');
  }

  tabGlobal.onclick = async () => { lbMode='global'; setActiveTab(); await renderActiveLB(); };
  tabLocal.onclick  = async () => { lbMode='local';  setActiveTab(); await renderActiveLB(); };
  tabRefresh.onclick= async () => {
    cachedGlobalRows = null;
    await renderActiveLB();
    showToast('Leaderboard refreshed.');
  };

  // Toast
  let toastT=0;
  const showToast=(msg)=>{toast.textContent=msg;toast.classList.add('show');toastT=1.1;};

  // ---------- Game logic ----------
  function resize(){
    const rect=cv.getBoundingClientRect();
    const w = rect.width || stage.getBoundingClientRect().width;
    const h = rect.height || stage.getBoundingClientRect().height;
    const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
    cv.width=Math.floor(w*dpr);
    cv.height=Math.floor(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize, {passive:true});
  requestAnimationFrame(resize);

  const W=()=>cv.getBoundingClientRect().width || stage.getBoundingClientRect().width;
  const H=()=>cv.getBoundingClientRect().height || stage.getBoundingClientRect().height;

  function loadImage(src){
    return new Promise((resolve,reject)=>{
      const img=new Image();
      img.onload=()=>resolve(img);
      img.onerror=()=>reject(new Error('Failed to load '+src));
      img.src=src;
    });
  }

  const ASSET_PATH = '/assets/';
  const ASSETS = {
    basket: ASSET_PATH + 'basket_mouth.png',
    player: ASSET_PATH + 'basket_player_idle.png',
    cookie: ASSET_PATH + 'food_cookie_ball.png',
    donut:  ASSET_PATH + 'food_donut_pink_ball.png',
    meat:   ASSET_PATH + 'food_meatball_ball.png',
    pizza:  ASSET_PATH + 'food_pizza_deepdish_ball.png',
    gold:   ASSET_PATH + 'food_donut_gold_ball.png',
  };

  const IMG = { ready:false };

  async function preload(){
    try{
      const [basket,player,cookie,donut,meat,pizza,gold] = await Promise.all([
        loadImage(ASSETS.basket),
        loadImage(ASSETS.player),
        loadImage(ASSETS.cookie),
        loadImage(ASSETS.donut),
        loadImage(ASSETS.meat),
        loadImage(ASSETS.pizza),
        loadImage(ASSETS.gold),
      ]);
      IMG.basket=basket;
      IMG.player=player;
      IMG.cookie=cookie;
      IMG.donut=donut;
      IMG.meat=meat;
      IMG.pizza=pizza;
      IMG.gold=gold;
      IMG.ready=true;
      showToast('Assets loaded.');
    }catch(e){
      console.log(e);
      showToast('Missing PNGs ‚Äî check /assets filenames.');
    }
  }
  preload();

  const FOOD = {
    COOKIE:   { label:'üç™ Cookie',    g:1.02, drag:0.989, r:18, imgKey:'cookie' },
    DONUT:    { label:'üç© Donut',     g:0.90, drag:0.978, r:18, imgKey:'donut'  },
    MEATBALL: { label:'üçñ Meatball',  g:1.12, drag:0.992, r:18, imgKey:'meat'   },
    PIZZA:    { label:'üçï Deep Dish', g:1.06, drag:0.986, r:19, imgKey:'pizza'  },
    GOLD:     { label:'‚≠ê Golden',     g:0.96, drag:0.980, r:18, imgKey:'gold', golden:true }
  };
  function pickFood(){
    if(Math.random()<0.10) return 'GOLD';
    const r=Math.random();
    if(r<0.35) return 'COOKIE';
    if(r<0.68) return 'DONUT';
    if(r<0.86) return 'MEATBALL';
    return 'PIZZA';
  }

  const HAND_OX = -17;
  const HAND_OY = -39;

  function layout(){
    const w=W(), h=H();
    const playerBase = { x: w*0.06, y: h*0.93 };
    const playerH = Math.max(160, h*0.30);

    const hand = {
      x: playerBase.x + playerH*0.78 + HAND_OX,
      y: playerBase.y - playerH*0.72 + HAND_OY
    };

    const rimR = Math.max(34, w*0.055);
    return { w,h, playerBase, playerH, hand, rimR };
  }

  function rimStations(L){
    const w=L.w, h=L.h;
    return [
      {x:w*0.62, y:h*0.22},
      {x:w*0.78, y:h*0.30},
      {x:w*0.54, y:h*0.30},
      {x:w*0.70, y:h*0.40},
      {x:w*0.86, y:h*0.44},
      {x:w*0.58, y:h*0.42},
    ];
  }

  let run=null;
  let lastRun=null;

  let runStartedAt = 0;
  let submitting = false;

  function newRun(){
    const L=layout();
    const stations=rimStations(L);
    const first=stations[Math.floor(Math.random()*stations.length)];
    return {
      playing:true,
      ended:false,

      streak:0,
      score:0,
      runBest:0,

      aiming:false,
      aimNow:{x:0,y:0},

      foodKey: pickFood(),
      ball:null,

      rim:{ x:first.x, y:first.y, tx:first.x, ty:first.y, t:1 },
      rimMoving:true,
    };
  }

  function updateHUD(){
    streakTxt.textContent=String(run.streak);
    scoreTxt.textContent=String(run.score);
    runBestTxt.textContent=String(run.runBest);
    const f=FOOD[run.foodKey];
    foodTxt.textContent=f.label;
    multiTxt.textContent = f.golden ? '2√ó' : '1√ó';
    rimTxt.textContent = run.rimMoving ? 'MOVING' : 'FIXED';
  }

  function start(){
    run=newRun();
    lastRun=null;
    overlayEnd.classList.remove('show');
    runStartedAt = performance.now();
    submitting = false;

    overlayStart.classList.remove('show');
    updateHUD();
    setBtnSaveLabel();

    statusEl.textContent = 'RUN';
    showToast(isLoggedIn() ? 'Logged in. Saves globally.' : 'Guest mode. Connect in HUB for global saves.');
  }

  function moveRim(){
    const L=layout();
    const stations=rimStations(L);
    let pick=stations[Math.floor(Math.random()*stations.length)];
    let tries=0;
    while(tries++<6 && Math.hypot(pick.x-run.rim.tx, pick.y-run.rim.ty) < L.w*0.08){
      pick=stations[Math.floor(Math.random()*stations.length)];
    }
    run.rim.tx=pick.x;
    run.rim.ty=pick.y;
    run.rim.t=0;
  }

  function setupNextShot(){
    run.foodKey=pickFood();
    run.ball=null;
    if(run.rimMoving) moveRim();
    updateHUD();
  }

  // Writes best + last run for HUB display
  function persistBasketStats(streak, score, synced, calories){
    const best = readJSON('pf_best_basket') || { bestStreak:0, bestScore:0, at:0 };
    const next = { ...best };

    if (Number(streak) > Number(best.bestStreak || 0) ||
       (Number(streak) === Number(best.bestStreak || 0) && Number(score) > Number(best.bestScore || 0))){
      next.bestStreak = Number(streak)||0;
      next.bestScore  = Number(score)||0;
      next.at = Date.now();
      writeJSON('pf_best_basket', next);
    }

    writeJSON('pf_last_basket', {
      streak: Number(streak)||0,
      score: Number(score)||0,
      synced: !!synced,
      calories: Number(calories)||0,
      at: Date.now()
    });
  }

  async function endRun(reason){
    if(!run || run.ended) return;

    run.ended=true;
    run.playing=false;

    statusEl.textContent = 'Ended';

    const durationMs = Math.max(0, Math.round(performance.now() - (runStartedAt || performance.now())));

    lastRun = {
      streak: run.streak,
      score: run.score,
      at: Date.now(),
      reason: reason||'MISS',
      calories: 0,
      durationMs,
      synced: false,
      syncError: null,
      capLine: ''
    };

    finalStreakTxt.textContent = String(lastRun.streak);
    finalScoreTxt.textContent  = String(lastRun.score);

    endLine.textContent = isLoggedIn()
      ? `Run ended. Submitting‚Ä¶`
      : `Run ended. Guest run (open in Telegram / HUB to save globally).`;

    lbMode = 'global';
    setActiveTab();
    cachedGlobalRows = null;
    leaderBoxEnd.innerHTML = `<div style="color:rgba(255,255,255,.70);font-weight:900;">Loading leaderboard‚Ä¶</div>`;

    overlayEnd.classList.add('show');

    if (!isLoggedIn()){
      persistBasketStats(lastRun.streak, lastRun.score, false, 0);
      renderLocalLB(leaderBoxEnd);
      return;
    }

    if (isLoggedIn() && !submitting){
      submitting = true;

      const res = await submitSecureSession({
        score: lastRun.score,
        streak: lastRun.streak,
        durationMs
      });

      if (res && res.ok && res.data){
        const earned = Number(res.data.earnedCalories ?? res.data.calories ?? 0) || 0;

        const todayCals = (res.data.today && typeof res.data.today === 'object')
          ? Number(res.data.today.calories ?? 0)
          : null;

        const cap = (res.data.caps && typeof res.data.caps === 'object')
          ? Number(res.data.caps.dailyCapCalories ?? 0)
          : null;

        lastRun.calories = Math.max(0, Math.round(earned));
        lastRun.synced = true;

        if (todayCals !== null && cap !== null && isFinite(todayCals) && isFinite(cap) && cap > 0){
          lastRun.capLine = `Cals earned: ${lastRun.calories} ‚Ä¢ Today: ${todayCals}/${cap}`;
        } else {
          lastRun.capLine = `Cals earned: ${lastRun.calories}`;
        }

        endLine.textContent = `Run ended. ${lastRun.capLine} ‚úÖ`;
        showToast(`Synced ‚úÖ +${lastRun.calories} cals`);

        persistBasketStats(lastRun.streak, lastRun.score, true, lastRun.calories);
      } else {
        lastRun.synced = false;
        lastRun.syncError = (res && (res.error || res.status)) ? String(res.error || res.status) : 'submit failed';
        endLine.textContent = `Run ended. Couldn‚Äôt sync right now ‚Äî try again later.`;
        showToast('Couldn‚Äôt sync run.');
        persistBasketStats(lastRun.streak, lastRun.score, false, 0);
      }

      submitting = false;

      cachedGlobalRows = await fetchGlobalLB();
      await renderActiveLB();
    }
  }

  function miss(){
    showToast('Miss.');
    endRun('MISS');
  }

  function make(){
    const f=FOOD[run.foodKey];
    const pts=f.golden?2:1;

    run.score += pts;
    run.streak += 1;
    run.runBest = Math.max(run.runBest, run.streak);

    showToast(f.golden ? `GOLDEN +2 (Streak ${run.streak})` : `+1 (Streak ${run.streak})`);
    setupNextShot();
  }

  function computeShotSpeed(L, s, a){
    const dx=s.x-a.x;
    const dy=s.y-a.y;
    const dist=Math.hypot(dx,dy);

    const maxPull=Math.max(200, L.w*0.36);
    const pull=clamp(dist,0,maxPull);

    let power=pull/maxPull;
    power = Math.pow(power, 1.35);

    const rimDist = Math.hypot(run.rim.x - s.x, run.rim.y - s.y);
    const closeFactor = clamp(rimDist / Math.max(220, L.w*0.55), 0.55, 1.0);

    const minSpeed = 240;
    const maxSpeed = 1650 * closeFactor;

    const speed = lerp(minSpeed, maxSpeed, power);
    return { dx, dy, dist, speed };
  }

  function canAim(){ return run && run.playing && !run.ended && !run.ball; }
  function getPos(e){
    const rect=cv.getBoundingClientRect();
    const t=e.touches && e.touches[0];
    const cx=t? t.clientX : e.clientX;
    const cy=t? t.clientY : e.clientY;
    return {x: cx-rect.left, y: cy-rect.top};
  }

  function isNearHeldFood(p){
    const L=layout();
    const hx=L.hand.x, hy=L.hand.y;
    const d=Math.hypot(p.x-hx, p.y-hy);
    return d < Math.max(46, L.w*0.07);
  }

  function onDown(e){
    if(!canAim()) return;
    e.preventDefault();
    const p=getPos(e);
    if(!isNearHeldFood(p)) return;
    run.aiming=true;
    run.aimNow=p;
  }
  function onMove(e){
    if(!run || !run.aiming) return;
    e.preventDefault();
    run.aimNow=getPos(e);
  }
  function onUp(e){
    if(!run || !run.aiming) return;
    e.preventDefault();
    run.aiming=false;
    shoot();
  }

  stage.addEventListener('mousedown', onDown);
  stage.addEventListener('mousemove', onMove);
  stage.addEventListener('mouseup', onUp);
  stage.addEventListener('mouseleave', ()=>{ if(run) run.aiming=false; });

  stage.addEventListener('touchstart', onDown, {passive:false});
  stage.addEventListener('touchmove', onMove, {passive:false});
  stage.addEventListener('touchend', onUp, {passive:false});
  stage.addEventListener('touchcancel', ()=>{ if(run) run.aiming=false; }, {passive:true});

  function shoot(){
    const L=layout();
    const s=L.hand;
    const a=run.aimNow;

    const { dx, dy, dist, speed } = computeShotSpeed(L, s, a);
    const nx=dx/(dist||1);
    const ny=dy/(dist||1);

    const f=FOOD[run.foodKey];

    run.ball={
      x:s.x, y:s.y,
      px:s.x, py:s.y,
      vx:nx*speed,
      vy:ny*speed,
      r:f.r,
      key:run.foodKey,
      life:0,
      enteredRimZone:false,
      floorBounced:false
    };
  }

  function step(dt){
    if(!run) return;

    if(toastT>0){ toastT-=dt; if(toastT<=0) toast.classList.remove('show'); }

    if(run.rim.t<1){
      run.rim.t=Math.min(1, run.rim.t + dt*6.0);
      const t=1-Math.pow(1-run.rim.t,3);
      run.rim.x=lerp(run.rim.x, run.rim.tx, t);
      run.rim.y=lerp(run.rim.y, run.rim.ty, t);
    } else {
      run.rim.x=run.rim.tx; run.rim.y=run.rim.ty;
    }

    if(!run.ball) return;

    const L=layout();
    const b=run.ball;
    const f=FOOD[b.key];

    const g=980*f.g;

    b.px=b.x; b.py=b.y;

    b.vx*=f.drag;
    b.vy*=f.drag;
    b.vy+=g*dt;
    b.x+=b.vx*dt;
    b.y+=b.vy*dt;
    b.life+=dt;

    const mouthY = run.rim.y + (L.rimR*0.10);
    const mouthHalfW = L.rimR*0.72;

    const zonePad = L.rimR*1.05;
    if(Math.abs(b.x-run.rim.x) < zonePad && Math.abs(b.y-mouthY) < zonePad) b.enteredRimZone = true;

    const crossed = (b.py < mouthY && b.y >= mouthY);
    if(b.vy>0 && crossed){
      const t = (mouthY - b.py) / ((b.y - b.py) || 1);
      const xAt = b.px + (b.x - b.px) * t;
      if(Math.abs(xAt - run.rim.x) <= mouthHalfW){
        make(); return;
      }
    }

    const floorY = L.h * 0.78;
    if(!b.floorBounced && b.vy>0 && (b.y + b.r) >= floorY){
      b.floorBounced = true;
      b.y = floorY - b.r;

      b.vy *= -0.42;
      b.vx *= 0.78;

      if(Math.abs(b.vy) < 140){
        miss(); return;
      }
    }

    const margin=180;
    const maxLife=6.0;

    const offScreen = (b.x < -margin || b.x > L.w + margin || b.y < -margin || b.y > L.h + margin);
    const timedOut  = (b.life > maxLife);

    const fellBelowRim = (b.y > run.rim.y + L.rimR*2.6 && b.vy > 0);

    if(offScreen || timedOut){
      if(b.enteredRimZone){
        if(fellBelowRim || b.y > L.h + margin){
          miss(); return;
        }
      } else {
        miss(); return;
      }
    }

    if(b.floorBounced && b.vy>0 && (b.y > floorY + 40)){
      miss(); return;
    }
  }

  function drawImageCentered(img, x, y, size){
    if(!img) return;
    const w=img.naturalWidth||img.width;
    const h=img.naturalHeight||img.height;
    const scale = size / Math.max(w,h);
    const dw = w * scale;
    const dh = h * scale;
    ctx.drawImage(img, x - dw/2, y - dh/2, dw, dh);
  }

  function drawPlayer(L){
    if(!IMG.ready || !IMG.player) return;

    const img=IMG.player;
    const iw=img.naturalWidth||img.width;
    const ih=img.naturalHeight||img.height;

    const scale = L.playerH / ih;
    const dw = iw * scale;
    const dh = ih * scale;

    ctx.drawImage(img, L.playerBase.x, L.playerBase.y - dh, dw, dh);
  }

  function drawHeldFood(L){
    if(!run) return;
    if(run.ball) return;

    const f=FOOD[run.foodKey];
    if(IMG.ready){
      const img = IMG[f.imgKey];
      const size = (f.r * 4.8);
      drawImageCentered(img, L.hand.x, L.hand.y, size);
    }
  }

  function draw(){
    const L=layout();
    ctx.clearRect(0,0,L.w,L.h);

    ctx.save();
    ctx.globalAlpha=0.18;
    ctx.lineWidth=2;
    ctx.strokeStyle='rgba(255,255,255,0.14)';
    ctx.beginPath();
    ctx.arc(L.w*0.72, L.h*0.18, Math.min(L.w*0.52, L.h*0.52), 0.15*Math.PI, 0.85*Math.PI);
    ctx.stroke();
    ctx.restore();

    drawPlayer(L);
    drawHeldFood(L);

    if(run && IMG.ready && IMG.basket){
      const bx = run.rim.x;
      const by = run.rim.y - (L.rimR*0.35);
      const size = L.rimR * 4.2;
      drawImageCentered(IMG.basket, bx, by, size);
    }

    if(run && run.aiming && !run.ball && run.playing && !run.ended){
      const s=L.hand;
      const a=run.aimNow;

      const { dx, dy, dist, speed } = computeShotSpeed(L, s, a);
      const nx=dx/(dist||1), ny=dy/(dist||1);

      const f=FOOD[run.foodKey];
      let vx=nx*speed, vy=ny*speed;
      let x=s.x, y=s.y;

      const g=980*f.g;
      const simDt=1/60;

      ctx.save();
      ctx.fillStyle='rgba(255,255,255,0.70)';
      for(let i=0;i<28;i++){
        ctx.globalAlpha=0.80*(1-i/30);
        ctx.beginPath();
        ctx.arc(x,y,i===0?3:2.2,0,Math.PI*2);
        ctx.fill();
        vx*=f.drag; vy*=f.drag;
        vy+=g*simDt;
        x+=vx*simDt; y+=vy*simDt;
      }
      ctx.restore();
    }

    if(run && run.ball){
      const b=run.ball;
      const f=FOOD[b.key];

      if(IMG.ready){
        const img = IMG[f.imgKey];
        const size = b.r * 4.8;
        drawImageCentered(img, b.x, b.y, size);
      }
    }
  }

  let last=performance.now();
  function loop(now){
    requestAnimationFrame(loop);
    const dt=Math.min(0.033,(now-last)/1000);
    last=now;

    if(run){
      if(run.playing && !run.ended) step(dt);
      draw();
    } else {
      const tmp=newRun();
      tmp.playing=false;
      run=tmp; draw(); run=null;
    }
  }
  requestAnimationFrame(loop);

  async function shareRun(){
    if(!lastRun) return;

    const syncLine = lastRun.synced
      ? `üî• Calories: ${lastRun.calories}`
      : (isLoggedIn() ? `üî• Calories: (pending sync)` : `üî• Calories: (guest)`);

    const text =
      `Planet Fatness ‚Äî Streak Shot\n` +
      `üî• Streak: ${lastRun.streak}\n` +
      `üç© Score: ${lastRun.score}\n` +
      `${syncLine}\n` +
      `Can you beat it?`;

    const url = location.href;

    if(navigator.share){
      try{ await navigator.share({ title:'Planet Fatness ‚Äî Streak Shot', text, url }); }
      catch(e){}
    } else {
      try{
        await navigator.clipboard.writeText(text + `\n` + url);
        showToast('Copied share text.');
      } catch(e){
        showToast('Share not supported here.');
      }
    }
  }

  // Save button:
  // - Logged in: already submitted on end; refreshes global LB
  // - Guest: saves to local LB
  async function saveRun(){
    if(!lastRun) return;

    if (isLoggedIn()){
      cachedGlobalRows = null;
      lbMode = 'global';
      setActiveTab();
      await renderActiveLB();
      showToast('Saved globally (auto). Refreshed LB.');
      return;
    }

    addLB(lastRun.streak, lastRun.score);
    lbMode = 'local';
    setActiveTab();
    renderLocalLB(leaderBoxEnd);
    showToast('Saved (local).');
  }

  btnStart.onclick = () => start();
  btnGo.onclick = () => start();
  btnCloseStart.onclick = () => overlayStart.classList.remove('show');

  btnAgain.onclick = () => start();
  btnCloseEnd.onclick = () => overlayEnd.classList.remove('show');

  btnSave.onclick = saveRun;
  btnShare.onclick = shareRun;

  if (shareBtn){
    shareBtn.addEventListener('click', () => {
      try{
        if (window.PF_UI && typeof window.PF_UI.share === "function"){
          window.PF_UI.share({ game:"basket" });
          return;
        }
        if (window.PFUI && typeof window.PFUI.share === "function"){
          window.PFUI.share({ game:"basket" });
          return;
        }
      }catch{}
      shareRun();
    });
  }

  // Boot
  setBtnSaveLabel();
  (async () => {
    lbMode = 'global';
    setActiveTab();
    await renderActiveLB();
  })();

})();
</script>
</body>
</html>