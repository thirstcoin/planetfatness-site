<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Planet Fatness ‚Äî Three-Point Snack Contest</title>
  <style>
    :root{
      --pf-purple:#5b2cff;
      --pf-purple-2:#2b0f7a;
      --pf-yellow:#ffd400;
      --pf-ink:#0b0614;
      --pf-white:#ffffff;
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    html,body{
      height:100%;
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      background: radial-gradient(1100px 700px at 30% 20%, #7a4bff 0%, #3a167f 40%, #120622 100%);
      color:var(--pf-white);
    }
    .wrap{ height:100%; display:flex; flex-direction:column; }
    .topbar{
      padding: 12px 12px 8px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .brand{ display:flex; flex-direction:column; gap:2px; line-height:1.1; }
    .brand .title{
      font-weight:900; letter-spacing:.6px; text-transform:uppercase;
      font-size: 13px; color: var(--pf-yellow);
      text-shadow: 0 2px 10px rgba(0,0,0,.35);
    }
    .brand .sub{ font-weight:800; font-size: 16px; }
    .hud{ display:flex; gap:8px; align-items:center; font-weight:800; }
    .pill{
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(0,0,0,.20));
      border: 1px solid rgba(255,255,255,.14);
      padding: 8px 10px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      box-shadow: 0 10px 25px rgba(0,0,0,.25);
      min-width: 92px;
      text-align:center;
    }
    .pill .label{ font-size:11px; opacity:.9; }
    .pill .value{ font-size:16px; color:var(--pf-yellow); }

    .stage{ position:relative; flex:1; display:flex; padding: 0 10px 10px; }
    canvas{
      width:100%;
      height:100%;
      border-radius: 18px;
      background:
        radial-gradient(900px 600px at 70% 15%, rgba(255,212,0,.12) 0%, rgba(255,212,0,0) 45%),
        radial-gradient(900px 600px at 20% 80%, rgba(91,44,255,.22) 0%, rgba(91,44,255,0) 55%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.18));
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
      touch-action:none;
    }

    .bottombar{
      display:flex; gap:10px;
      padding: 10px 12px 14px;
      align-items:center; justify-content:space-between;
    }
    .btn{
      flex:1;
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px;
      padding: 12px 12px;
      font-weight:900;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.15);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(0,0,0,.28));
      color: var(--pf-white);
      text-decoration:none;
      user-select:none;
      box-shadow: 0 12px 28px rgba(0,0,0,.30);
    }
    .btn.yellow{
      background: linear-gradient(180deg, rgba(255,212,0,.95), rgba(255,212,0,.65));
      color: #1a1033;
      border: 1px solid rgba(0,0,0,.25);
    }
    .btn:active{ transform: translateY(1px); }

    .toast{
      position:absolute;
      left:50%; top: 14px;
      transform: translateX(-50%);
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
      font-weight:900;
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
      text-align:center;
      max-width: 92%;
    }
    .toast.show{ opacity:1; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="title">Planet Fatness Gym</div>
        <div class="sub">Three-Point Snack Contest</div>
      </div>
      <div class="hud">
        <div class="pill">
          <div class="label">Score</div>
          <div class="value" id="scoreVal">0</div>
        </div>
        <div class="pill">
          <div class="label">Shots</div>
          <div class="value" id="shotsVal">0/25</div>
        </div>
      </div>
    </div>

    <div class="stage">
      <div class="toast" id="toast"></div>
      <canvas id="game"></canvas>
    </div>

    <div class="bottombar">
      <a class="btn" href="/">‚¨Ö Back to Main</a>
      <a class="btn yellow" href="javascript:void(0)" onclick="alert('Local leaderboard can be added next ‚Äî game physics + racks are fixed now.')">üèÜ Leaderboards</a>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const scoreVal = document.getElementById('scoreVal');
  const shotsVal = document.getElementById('shotsVal');
  const toastEl  = document.getElementById('toast');

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', () => { resize(); computeLayout(); });
  resize();

  const THEME = {
    yellow: '#ffd400',
    white: '#ffffff'
  };

  // Contest rules
  const RUN = { totalShots: 25, racks: 5, shotsPerRack: 5 };

  // Physics tuning
  const PHYS = {
    gravity: 1700,           // base gravity
    maxDt: 0.033,
    // angle limits for ballistic solve (degrees)
    minAngleDeg: 18,
    maxAngleDeg: 78,
    // how much your drag affects "power feel" (scales the computed speed)
    powerMin: 0.85,
    powerMax: 1.18,
    // drag constraints
    minDrag: 18,
    maxDrag: 140
  };

  // Lazy timer (optional but keeps it degen)
  const LAZY = { aimIdleMax: 6.0, noInputMax: 10.0 };

  // Scoring
  const SCORE = { normal: 1, golden: 2, swishBonus: 1 };

  // Snacks (still different feel, BUT always solvable)
  const SNACKS = {
    donut:    { key:'donut',    name:'Donut',        gravMul:1.00, r:11, color:'#ffd400' },
    meatball: { key:'meatball', name:'Meatball',     gravMul:1.12, r:10, color:'#b24b2a' },
    cookie:   { key:'cookie',   name:'Cookie',       gravMul:0.92, r:11, color:'#d6a06a' },
    pizza:    { key:'pizza',    name:'Pizza',        gravMul:0.82, r:13, color:'#ffb14a' },
    burger:   { key:'burger',   name:'Burger',       gravMul:1.05, r:14, color:'#d98c4a' },
    gold:     { key:'gold',     name:'Golden Donut', gravMul:1.00, r:12, color:'#ffea00', glow:true }
  };

  // Rack order per position (last ball gold)
  const basePool = ['donut','meatball','cookie','pizza','burger'];
  function rackForIndex(i){
    // rotate per rack so it feels varied but consistent
    const rot = (arr,n)=>arr.map((_,k)=>arr[(k+n)%arr.length]);
    const pool = rot(basePool, i);
    return [SNACKS[pool[0]], SNACKS[pool[2]], SNACKS[pool[4]], SNACKS[pool[1]], SNACKS.gold];
  }

  // State
  const state = {
    w:0,h:0,
    floorY:0,
    player:{x:0,y:0},
    hoop:{x:0,y:0,r:26, bobT:0},
    racks:[],           // rack positions along arc
    rackIndex:0,
    shotIndex:0,
    shotInRack:0,
    currentSnack: SNACKS.donut,
    aiming:false,
    aimStart:{x:0,y:0},
    aimNow:{x:0,y:0},
    aimHold:0,
    idle:0,
    proj:null,
    score:0,
    swishes:0,
    goldMade:0,
    particles:[],
    pulse:0
  };

  function computeLayout(){
    const rect = canvas.getBoundingClientRect();
    state.w = rect.width;
    state.h = rect.height;
    state.floorY = state.h * 0.80;

    // hoop/basket-mouth on right side
    state.hoop.x = state.w * 0.78;
    state.hoop.y = state.h * 0.36;
    state.hoop.r = Math.max(22, Math.min(34, state.w * 0.04));

    // 5 rack spots along a "three point arc"
    // (screen-friendly approximation that looks like real racks on the arc)
    const left = state.w * 0.16;
    const right = state.w * 0.54;
    const mid = (left + right)/2;

    state.racks = [
      { x:left,  y:state.floorY,               label:'Corner L' },
      { x:state.w*0.25, y:state.floorY - state.h*0.08, label:'Wing L' },
      { x:mid,   y:state.floorY - state.h*0.14, label:'Top' },
      { x:state.w*0.45, y:state.floorY - state.h*0.08, label:'Wing R' },
      { x:right, y:state.floorY,               label:'Corner R' }
    ];

    const r = state.racks[state.rackIndex] || state.racks[0];
    state.player.x = r.x;
    state.player.y = r.y;
  }
  computeLayout();

  // HUD
  function hud(){
    scoreVal.textContent = String(state.score);
    shotsVal.textContent = `${state.shotIndex}/${RUN.totalShots}`;
  }

  // Toast
  let toastTimer = 0;
  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    toastTimer = 1.2;
  }

  // Pick current snack based on rack + shot
  function refreshSnack(){
    state.rackIndex = Math.floor(state.shotIndex / RUN.shotsPerRack);
    state.shotInRack = state.shotIndex % RUN.shotsPerRack;

    const rack = rackForIndex(state.rackIndex);
    state.currentSnack = rack[state.shotInRack];

    // move player to rack spot
    const r = state.racks[state.rackIndex];
    state.player.x = r.x;
    state.player.y = r.y;

    state.aimHold = 0;
    state.idle = 0;
  }

  // Input helpers
  function getPos(e){
    const r = canvas.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - r.left;
    const y = (e.touches ? e.touches[0].clientY : e.clientY) - r.top;
    return {x,y};
  }
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  function down(e){
    if (state.proj) return;
    if (state.shotIndex >= RUN.totalShots) return;

    const p = getPos(e);
    state.aiming = true;
    state.aimStart.x = state.player.x;
    state.aimStart.y = state.player.y - 18;
    state.aimNow = p;
    state.aimHold = 0;
    state.idle = 0;
    state.pulse = 0.12;
    e.preventDefault?.();
  }
  function move(e){
    if (!state.aiming) return;
    state.aimNow = getPos(e);
    state.idle = 0;
    e.preventDefault?.();
  }
  function up(e){
    if (!state.aiming) return;
    state.aiming = false;
    fireBallistic();
    e.preventDefault?.();
  }

  canvas.addEventListener('mousedown', down);
  canvas.addEventListener('mousemove', move);
  window.addEventListener('mouseup', up);

  canvas.addEventListener('touchstart', down, {passive:false});
  canvas.addEventListener('touchmove', move, {passive:false});
  window.addEventListener('touchend', up, {passive:false});

  // -------- FIX #1: Ballistic solve (always reachable) --------
  // Use your drag direction to choose an angle, then compute speed that would hit the hoop.
  function fireBallistic(){
    const x0 = state.aimStart.x;
    const y0 = state.aimStart.y;

    // Target: hoop "mouth"
    const xt = state.hoop.x;
    const yt = state.hoop.y + 10;

    // Pull vector (drag backwards)
    const dxPull = x0 - state.aimNow.x;
    const dyPull = y0 - state.aimNow.y;

    const dist = Math.hypot(dxPull, dyPull);
    const d = clamp(dist, PHYS.minDrag, PHYS.maxDrag);

    // If they barely drag, slip miss
    if (dist < 10){
      slipMiss("BRO DRAG TO AIM.");
      return;
    }

    // Determine desired shooting angle from pull direction (pointing toward hoop)
    // We'll convert pull into a positive-right launch direction.
    // Angle is measured from +X axis, up is negative Y (screen coords).
    let theta = Math.atan2(-dyPull, dxPull); // "forward" angle
    // clamp angle to a usable range
    const minA = PHYS.minAngleDeg * Math.PI/180;
    const maxA = PHYS.maxAngleDeg * Math.PI/180;
    theta = clamp(theta, minA, maxA);

    const snack = state.currentSnack;
    const g = PHYS.gravity * snack.gravMul;

    // Horizontal distance to target must be positive (shooting right)
    const dx = xt - x0;
    const dy = yt - y0;

    if (dx <= 10){
      slipMiss("STOP SHOOTING BACKWARDS.");
      return;
    }

    // ballistic formula:
    // v^2 = g*dx^2 / (2*cos^2(theta)*(dx*tan(theta) - dy))
    // If denominator <= 0, angle can't hit target -> nudge angle toward viable window.
    function solveV(thetaTry){
      const cos = Math.cos(thetaTry);
      const sin = Math.sin(thetaTry);
      const tan = sin / Math.max(0.0001, cos);
      const denom = 2 * cos*cos * (dx * tan - dy);
      if (denom <= 0.0001) return null;
      const v2 = g * dx*dx / denom;
      if (v2 <= 0) return null;
      return Math.sqrt(v2);
    }

    let v = solveV(theta);
    if (!v){
      // nudge angle upward until solvable (this is the core ‚Äúalways reachable‚Äù fix)
      let found = false;
      for (let a = theta; a <= maxA; a += 0.02){
        const vv = solveV(a);
        if (vv){ theta = a; v = vv; found = true; break; }
      }
      if (!found){
        for (let a = theta; a >= minA; a -= 0.02){
          const vv = solveV(a);
          if (vv){ theta = a; v = vv; found = true; break; }
        }
      }
      if (!found){
        slipMiss("THIS ANGLE AIN‚ÄôT IT.");
        return;
      }
    }

    // Apply a ‚Äúpower feel‚Äù from drag amount (small range so it stays solvable)
    const t = (d - PHYS.minDrag) / (PHYS.maxDrag - PHYS.minDrag);
    const powerMul = PHYS.powerMin + (PHYS.powerMax - PHYS.powerMin) * clamp(t,0,1);
    v *= powerMul;

    const vx = v * Math.cos(theta);
    const vy = -v * Math.sin(theta);

    state.proj = {
      x:x0, y:y0,
      vx, vy,
      r: snack.r,
      snack,
      scored:false,
      alive:true
    };

    state.pulse = 0.20;
  }

  function slipMiss(msg){
    toast(msg);
    // toss it somewhere dumb
    const snack = state.currentSnack;
    state.proj = {
      x: state.player.x, y: state.player.y-18,
      vx: 160 + Math.random()*80,
      vy: -220 - Math.random()*120,
      r: snack.r,
      snack,
      scored:true, // mark so it can‚Äôt score
      alive:true,
      forced:true
    };
  }

  // Particles
  function pop(x,y,count,color){
    for (let i=0;i<count;i++){
      state.particles.push({
        x,y,
        vx:(Math.random()*2-1)*260,
        vy:(Math.random()*2-1)*260-80,
        a:1,
        life:0.6+Math.random()*0.35,
        r:2+Math.random()*2.5,
        color
      });
    }
  }

  // Scoring check
  function checkScore(p){
    const mx = state.hoop.x;
    const my = state.hoop.y + 10;
    const R = state.hoop.r;

    const dx = p.x - mx;
    const dy = p.y - my;
    const dist2 = dx*dx + dy*dy;

    const hitR = R + p.r*0.55;
    if (!p.scored && dist2 <= hitR*hitR){
      p.scored = true;

      const swishR = R * 0.55;
      const swish = dist2 <= swishR*swishR;

      const isGold = p.snack.key === 'gold';
      const base = isGold ? SCORE.golden : SCORE.normal;
      const bonus = swish ? SCORE.swishBonus : 0;

      state.score += (base + bonus);
      if (swish) state.swishes++;
      if (isGold) state.goldMade++;

      toast(isGold ? `GOLD DONUT +${base}` : `+${base}${swish ? ' SWISH +1' : ''}`);
      pop(mx,my, isGold ? 18 : 12, isGold ? THEME.yellow : 'rgba(255,255,255,.75)');
      state.pulse = 0.22;

      // bounce out
      p.vx *= 0.25;
      p.vy = -420;
      hud();
    }
  }

  // End shot
  function nextShot(){
    state.shotIndex++;
    hud();
    if (state.shotIndex >= RUN.totalShots){
      toast(`RUN OVER: ${state.score} PTS`);
      // reset after a short pause
      setTimeout(reset, 700);
      return;
    }
    refreshSnack();
  }

  // -------- FIX #2: Draw racks spaced on the 3pt arc --------
  function drawRackVisual(r, idx){
    const active = idx === state.rackIndex;
    const baseW = 64;
    const baseH = 18;

    ctx.save();
    ctx.globalAlpha = active ? 0.95 : 0.35;

    // rack base
    ctx.fillStyle = active ? 'rgba(255,212,0,.18)' : 'rgba(255,255,255,.10)';
    ctx.strokeStyle = active ? 'rgba(255,212,0,.50)' : 'rgba(255,255,255,.14)';
    ctx.lineWidth = 2;

    // slight tilt to feel like real rack
    const tilt = (idx < 2) ? -0.08 : (idx > 2 ? 0.08 : 0);
    ctx.translate(r.x, r.y);
    ctx.rotate(tilt);

    roundRect(-baseW/2, -baseH/2, baseW, baseH, 8);
    ctx.fill();
    ctx.stroke();

    // balls on rack (5)
    const balls = rackForIndex(idx);
    for (let i=0;i<5;i++){
      const b = balls[i];
      const x = -baseW/2 + 10 + i*11;
      const y = 0;
      ctx.beginPath();
      ctx.fillStyle = b.key === 'gold' ? 'rgba(255,234,0,.95)' : 'rgba(255,255,255,.35)';
      ctx.arc(x, y, 4.2, 0, Math.PI*2);
      ctx.fill();
      if (b.key === 'gold'){
        ctx.strokeStyle = 'rgba(255,212,0,.7)';
        ctx.stroke();
      }
    }

    ctx.restore();
  }

  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  // Court / player / hoop
  function drawCourt(){
    ctx.save();
    // floor line
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = 'rgba(255,212,0,.30)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(state.w*0.04, state.floorY);
    ctx.lineTo(state.w*0.96, state.floorY);
    ctx.stroke();

    // 3pt arc hint
    ctx.globalAlpha = 0.18;
    ctx.beginPath();
    ctx.arc(state.hoop.x, state.floorY+180, state.w*0.55, Math.PI*1.15, Math.PI*1.95);
    ctx.stroke();
    ctx.restore();

    // racks
    for (let i=0;i<state.racks.length;i++){
      drawRackVisual(state.racks[i], i);
    }
  }

  function drawPlayer(){
    const x = state.player.x;
    const y = state.player.y;
    ctx.save();

    // shadow
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(x, y+8, 26, 10, 0, 0, Math.PI*2);
    ctx.fill();

    // body
    ctx.globalAlpha = 1;
    ctx.fillStyle = 'rgba(255,255,255,.10)';
    ctx.strokeStyle = 'rgba(255,255,255,.18)';
    ctx.lineWidth = 2;
    roundRect(x-18, y-58, 36, 56, 12);
    ctx.fill(); ctx.stroke();

    // head
    ctx.fillStyle = 'rgba(255,212,0,.95)';
    ctx.beginPath();
    ctx.arc(x, y-70, 14, 0, Math.PI*2);
    ctx.fill();

    // hand
    ctx.fillStyle = 'rgba(255,255,255,.55)';
    ctx.beginPath();
    ctx.arc(x, y-18, 4, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawHoop(){
    // bobbing ‚Äúfat guy mouth hoop‚Äù
    state.hoop.bobT += 0.016;
    const bob = Math.sin(state.hoop.bobT)*6;
    const lean = Math.sin(state.hoop.bobT*0.7)*8;

    const x = state.hoop.x + lean;
    const y = state.hoop.y + bob;

    ctx.save();
    // face blob
    ctx.fillStyle = 'rgba(255,255,255,.08)';
    ctx.strokeStyle = 'rgba(255,255,255,.16)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(x, y, 64, 58, 0, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // mouth
    ctx.fillStyle = 'rgba(0,0,0,.55)';
    ctx.beginPath();
    ctx.ellipse(x, y+10, state.hoop.r*1.1, state.hoop.r*0.8, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = 'rgba(255,212,0,.35)';
    ctx.beginPath();
    ctx.ellipse(x, y+10, state.hoop.r*1.15, state.hoop.r*0.85, 0, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();

    // update mouth target position
    state.hoop.drawX = x;
    state.hoop.drawY = y;
  }

  function drawSnack(snack,x,y,r){
    ctx.save();
    if (snack.glow){
      ctx.shadowColor = 'rgba(255,212,0,.85)';
      ctx.shadowBlur = 22;
    }
    ctx.fillStyle = snack.color;
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fill();

    if (snack.key === 'donut' || snack.key === 'gold'){
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(0,0,0,.30)';
      ctx.beginPath();
      ctx.arc(x,y,Math.max(4,r*0.45),0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  // Aim preview (now uses ballistic solve too, so preview matches reality)
  function aimPreview(){
    const x0 = state.aimStart.x;
    const y0 = state.aimStart.y;

    const xt = state.hoop.x;
    const yt = state.hoop.y + 10;

    const dxPull = x0 - state.aimNow.x;
    const dyPull = y0 - state.aimNow.y;

    const dist = Math.hypot(dxPull, dyPull);
    const d = clamp(dist, PHYS.minDrag, PHYS.maxDrag);

    let theta = Math.atan2(-dyPull, dxPull);
    const minA = PHYS.minAngleDeg * Math.PI/180;
    const maxA = PHYS.maxAngleDeg * Math.PI/180;
    theta = clamp(theta, minA, maxA);

    const snack = state.currentSnack;
    const g = PHYS.gravity * snack.gravMul;
    const dx = xt - x0;
    const dy = yt - y0;

    if (dx <= 10) return;

    function solveV(thetaTry){
      const cos = Math.cos(thetaTry);
      const sin = Math.sin(thetaTry);
      const tan = sin / Math.max(0.0001, cos);
      const denom = 2 * cos*cos * (dx * tan - dy);
      if (denom <= 0.0001) return null;
      const v2 = g * dx*dx / denom;
      if (v2 <= 0) return null;
      return Math.sqrt(v2);
    }

    let v = solveV(theta);
    if (!v) return;

    const t = (d - PHYS.minDrag) / (PHYS.maxDrag - PHYS.minDrag);
    const powerMul = PHYS.powerMin + (PHYS.powerMax - PHYS.powerMin) * clamp(t,0,1);
    v *= powerMul;

    const vx = v * Math.cos(theta);
    const vy = -v * Math.sin(theta);

    // draw pull line
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.strokeStyle = snack.key==='gold' ? THEME.yellow : 'rgba(255,255,255,.65)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(state.aimNow.x, state.aimNow.y);
    ctx.stroke();

    // arc dots
    for (let i=1;i<=18;i++){
      const tt = i*0.09;
      const x = x0 + vx*tt;
      const y = y0 + vy*tt + 0.5*g*tt*tt;
      const a = 0.85 - i/22;
      ctx.globalAlpha = a;
      ctx.fillStyle = snack.key==='gold' ? THEME.yellow : 'rgba(255,255,255,.85)';
      ctx.beginPath();
      ctx.arc(x,y, 3.4 - i*0.08, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  // Update loop
  let last = performance.now();
  function tick(now){
    const dt = Math.min((now-last)/1000, PHYS.maxDt);
    last = now;

    // pulse overlay
    if (state.pulse > 0) state.pulse = Math.max(0, state.pulse - dt);

    // particles
    for (let i=state.particles.length-1;i>=0;i--){
      const p = state.particles[i];
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.vy += 900*dt;
      p.a -= dt/p.life;
      if (p.a <= 0) state.particles.splice(i,1);
    }

    // toast
    if (toastTimer > 0){
      toastTimer -= dt;
      if (toastTimer <= 0) toastEl.classList.remove('show');
    }

    // lazy timers
    if (state.shotIndex < RUN.totalShots){
      state.idle += dt;
      if (state.aiming) state.aimHold += dt;

      if (!state.aiming && !state.proj && state.idle > LAZY.noInputMax){
        slipMiss("BRO SHOOT OR GO HOME.");
        state.idle = 0;
      }
      if (state.aiming && state.aimHold > LAZY.aimIdleMax){
        state.aiming = false;
        slipMiss("STOP THINKING. JUST YEET IT.");
        state.aimHold = 0;
        state.idle = 0;
      }
    }

    // projectile
    if (state.proj){
      const p = state.proj;
      const g = PHYS.gravity * p.snack.gravMul;

      p.vy += g*dt;
      p.x += p.vx*dt;
      p.y += p.vy*dt;

      if (!p.scored && !p.forced) checkScore(p);

      if (p.x < -120 || p.x > state.w+120 || p.y < -220 || p.y > state.h+160){
        state.proj = null;
        nextShot();
      }
    }

    // render
    ctx.clearRect(0,0,state.w,state.h);

    if (state.pulse > 0){
      ctx.save();
      ctx.globalAlpha = Math.min(0.22, state.pulse);
      ctx.fillStyle = THEME.yellow;
      ctx.fillRect(0,0,state.w,state.h);
      ctx.restore();
    }

    drawCourt();
    drawHoop();
    drawPlayer();

    if (state.aiming && !state.proj) aimPreview();

    if (state.proj){
      drawSnack(state.proj.snack, state.proj.x, state.proj.y, state.proj.r);
    }

    // particles on top
    for (const p of state.particles){
      ctx.save();
      ctx.globalAlpha = Math.max(0,p.a);
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    requestAnimationFrame(tick);
  }

  function reset(){
    state.score = 0;
    state.shotIndex = 0;
    state.swishes = 0;
    state.goldMade = 0;
    state.proj = null;
    state.particles.length = 0;
    state.aiming = false;
    state.idle = 0;
    state.aimHold = 0;
    state.pulse = 0;
    refreshSnack();
    hud();
  }

  // start
  reset();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>