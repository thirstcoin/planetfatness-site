<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>$PHAT ‚Äî Treadmill Rage Runner</title>

  <style>
    :root{
      --purple:#5b2cff;
      --yellow:#ffd400;
      --panel:rgba(255,255,255,.08);
      --stroke:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.95);
      --muted:rgba(255,255,255,.70);
    }

    *{
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      user-select: none;
    }

    html,body{
      margin:0;
      height:100%;
      background:
        radial-gradient(900px 520px at 50% 0%, rgba(91,44,255,.35), transparent 60%),
        radial-gradient(700px 420px at 50% 100%, rgba(255,212,0,.22), transparent 60%),
        linear-gradient(180deg, #140b2b, #07050c);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      overflow:hidden;
    }

    #wrap{
      height:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:12px;
      padding:14px;
    }

    .row{
      width:min(920px,100%);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }

    .pill{
      padding:10px 14px;
      border-radius:999px;
      background:var(--panel);
      border:1px solid var(--stroke);
      font-size:13px;
      font-weight:900;
      color:var(--muted);
      backdrop-filter: blur(10px);
      box-shadow:0 18px 60px rgba(0,0,0,.35);
      user-select:none;
      white-space:nowrap;
    }

    .btn{
      padding:10px 16px;
      border-radius:14px;
      font-weight:1000;
      background:linear-gradient(180deg, var(--yellow), #ffbf00);
      color:#1b1400;
      border:none;
      box-shadow:0 14px 30px rgba(255,212,0,.45);
      cursor:pointer;
    }
    .btn:active{ transform: scale(.98); }

    .btnGhost{
      padding:10px 14px;
      border-radius:14px;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.14);
      color:rgba(255,255,255,.9);
      font-weight:1000;
      cursor:pointer;
    }
    .btnGhost:active{ transform: scale(.98); }

    #stage{ position:relative; width:min(920px,100%); }

    #runnerWrap{
      position:absolute;
      inset:0;
      z-index:1;
      pointer-events:none;
      display:flex;
      align-items:flex-end;
      justify-content:center;
    }

    #runnerGif{
      height: 430px;
      width:auto;
      margin-bottom: 0px;
      transform-origin: center bottom;
      will-change: transform, filter;
      filter: drop-shadow(0 26px 42px rgba(0,0,0,.55));
      -webkit-user-drag: none;
      user-drag: none;
    }

    #beltFx{
      position:absolute;
      z-index:2;
      left: 12%;
      top: 63%;
      width: 76%;
      height: 16%;
      border-radius: 18px;
      opacity: 0;
      pointer-events:none;
      background:
        repeating-linear-gradient(
          135deg,
          rgba(255,255,255,.11) 0px,
          rgba(255,255,255,.11) 10px,
          rgba(0,0,0,0) 10px,
          rgba(0,0,0,0) 22px
        );
      mix-blend-mode: overlay;
      filter: blur(0.4px);
      transform: translateZ(0);
    }

    #speedLines{
      position:absolute;
      inset:0;
      z-index:3;
      opacity:0;
      pointer-events:none;
      background:
        repeating-linear-gradient(
          90deg,
          rgba(255,255,255,.12) 0px,
          rgba(255,255,255,.12) 1px,
          rgba(0,0,0,0) 1px,
          rgba(0,0,0,0) 18px
        );
      mask-image: radial-gradient(circle at 50% 40%, rgba(0,0,0,1), rgba(0,0,0,0) 70%);
      -webkit-mask-image: radial-gradient(circle at 50% 40%, rgba(0,0,0,1), rgba(0,0,0,0) 70%);
      mix-blend-mode: overlay;
    }

    #vignette{
      position:absolute;
      inset:0;
      z-index:4;
      opacity:0;
      pointer-events:none;
      background:
        radial-gradient(circle at 50% 45%, rgba(0,0,0,0) 40%, rgba(0,0,0,.55) 78%, rgba(0,0,0,.75) 100%),
        radial-gradient(circle at 50% 45%, rgba(255,60,90,.22), rgba(0,0,0,0) 55%);
      mix-blend-mode: screen;
    }

    canvas{
      position:relative;
      z-index:5;
      width:100%;
      border-radius:20px;
      background: transparent;
      border:1px solid rgba(255,255,255,.12);
      box-shadow:0 30px 90px rgba(0,0,0,.55);
      touch-action:manipulation;
      display:block;
      -webkit-user-select:none;
      user-select:none;
    }

    .hint{
      width:min(920px,100%);
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }

    #modalBack{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(8px);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:50;
    }
    #modal{
      width:min(760px, 100%);
      border-radius:24px;
      border:1px solid rgba(255,255,255,.14);
      background:
        radial-gradient(900px 420px at 20% 0%, rgba(91,44,255,.32), transparent 60%),
        radial-gradient(900px 520px at 80% 80%, rgba(255,212,0,.16), transparent 65%),
        rgba(255,255,255,.06);
      box-shadow:0 40px 140px rgba(0,0,0,.65);
      overflow:hidden;
    }
    #modal .top{ padding:18px 18px 8px; }
    #modal .title{ font-size:20px; font-weight:1000; letter-spacing:.2px; }
    #modal .sub{ margin-top:6px; color:rgba(255,255,255,.75); font-weight:800; }

    #cards{
      padding:14px 18px 8px;
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .card{
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      padding:14px;
    }
    .card .k{ font-weight:900; color:rgba(255,255,255,.72); font-size:13px; margin-bottom:6px; }
    .card .v{ font-weight:1100; font-size:34px; letter-spacing:-.5px; }
    .card .note{ margin-top:6px; color:rgba(255,255,255,.70); font-weight:800; font-size:13px; }

    #actions{
      padding:14px 18px 18px;
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      justify-content:flex-start;
    }

    #footerHint{
      padding:0 18px 18px;
      color:rgba(255,255,255,.75);
      font-weight:900;
      text-align:center;
    }
  </style>
</head>

<body>
  <div id="wrap">
    <div class="row">
      <div class="pill">$PHAT ‚Äî Treadmill Rage Runner</div>
      <div class="pill" id="status">Tap to start</div>

      <button class="btnGhost" id="backBtn">‚Üê Gym</button>
      <button class="btn" id="restartBtn">Restart</button>
    </div>

    <div id="stage">
      <div id="runnerWrap">
        <img id="runnerGif" src="../assets/runner.gif" alt="Planet Fatness Treadmill Scene" draggable="false" />
        <div id="beltFx"></div>
        <div id="speedLines"></div>
        <div id="vignette"></div>
      </div>
      <canvas id="c" width="900" height="520"></canvas>
    </div>

    <div class="hint">
      <div class="pill">Controls: Tap / Click / Space ‚Ä¢ Hold = auto-run (mobile)</div>
      <div class="pill">Best: <span id="best">0.0s</span> ‚Ä¢ <span id="bestMi">0.00mi</span></div>
    </div>
  </div>

  <div id="modalBack" role="dialog" aria-modal="true">
    <div id="modal">
      <div class="top">
        <div class="title">Ejected üí•</div>
        <div class="sub">Snack-first doesn‚Äôt mean speed-last.</div>
      </div>

      <div id="cards">
        <div class="card">
          <div class="k">Run Time</div>
          <div class="v" id="mTime">0.0s</div>
          <div class="note">Rank: <span id="mRank">NEW YEAR SIGNUP</span></div>
        </div>

        <div class="card">
          <div class="k">Miles (this run)</div>
          <div class="v" id="mMiles">0.00mi</div>
          <div class="note">3 minutes = ~1 mile baseline ‚Ä¢ intensity bumps it a bit</div>
        </div>

        <div class="card">
          <div class="k">Calories (this run)</div>
          <div class="v" id="mCals">0</div>
          <div class="note" id="mCalsNote">Connect on the site to stack lifetime calories</div>
        </div>

        <div class="card">
          <div class="k">Cadence</div>
          <div class="v" id="mCad">0.0/s</div>
          <div class="note">Certified menace cadence</div>
        </div>

        <div class="card">
          <div class="k">Incline Peak</div>
          <div class="v" id="mIncl">0.0%</div>
          <div class="note">The belt was disrespectful</div>
        </div>
      </div>

      <div id="actions">
        <button class="btn" id="runBackBtn">Run it back</button>
        <button class="btnGhost" id="closeBtn">Close</button>
        <button class="btnGhost" id="lbBtn">Leaderboard</button>
      </div>

      <div id="footerHint">Guest run complete. Connect on the site to stack lifetime calories.</div>
    </div>
  </div>

<script>
/* =========================================================
   Runner ‚Äî FIXED for PlanetFatness production keys + backend
   ‚úÖ Uses the SAME localStorage keys as your main site:
      - API base: pf_api_base
      - token:    pf_token
      - address:  pf_address (not required here, token is enough)
   ‚úÖ Submits to: POST /activity/submit (server-computed calories)
   ‚úÖ Pulls caps from: GET /daily/progress
   ‚úÖ Does NOT "double count" locally when logged in
   ‚úÖ Gameplay unchanged
   ========================================================= */

/* ===== API + AUTH (read both new + legacy keys) ===== */
function readLS(key){
  try { return (localStorage.getItem(key) || '').trim(); } catch { return ''; }
}

// Prefer your current site keys (pf_*), fall back to older phat_* if present
const API_BASE =
  (window.PF_API_BASE) ||
  readLS('pf_api_base') ||
  readLS('phat_api_base') ||
  '';

const TOKEN_KEY_PRIMARY = 'pf_token';
const TOKEN_KEY_LEGACY  = 'phat_token';

function getToken(){
  return readLS(TOKEN_KEY_PRIMARY) || readLS(TOKEN_KEY_LEGACY) || '';
}

function api(path){
  const b = String(API_BASE || '').trim();
  if (!b) return '';
  return b.replace(/\/$/,'') + path;
}

async function fetchDailyProgress(){
  const token = getToken();
  if (!API_BASE || !token) return null;
  try{
    const r = await fetch(api('/daily/progress'), {
      headers: { 'Authorization':'Bearer ' + token }
    });
    const j = await r.json();
    if (j && j.games && j.games.runner) return j;
    return null;
  }catch{
    return null;
  }
}

async function submitSecureRunner(payload){
  const token = getToken();
  if (!API_BASE || !token) return null;

  try{
    const r = await fetch(api('/activity/submit'), {
      method:'POST',
      headers:{
        'Content-Type':'application/json',
        'Authorization':'Bearer ' + token
      },
      body: JSON.stringify(payload)
    });
    const j = await r.json();
    if (j && j.ok) return j;
    return j || null; // return error payload if any
  }catch{
    return null;
  }
}

/* ===== DAILY (fallback local only when NOT logged in) ===== */
let DAILY_CAP = 1000;

// Use pf_* keys for runner daily cache (and accept legacy if it exists)
const KEY_RESET = "pf_runner_reset";
const KEY_TODAY = "pf_runner_today";

function nextMidnight(){
  const d = new Date();
  return new Date(d.getFullYear(), d.getMonth(), d.getDate()+1).getTime();
}

let resetAt = Number(readLS(KEY_RESET) || nextMidnight());
let today = Number(readLS(KEY_TODAY) || 0);

if (Date.now() > resetAt){
  today = 0;
  resetAt = nextMidnight();
  try{
    localStorage.setItem(KEY_RESET, String(resetAt));
    localStorage.setItem(KEY_TODAY, String(today));
  }catch{}
}

async function syncFromServer(){
  const prog = await fetchDailyProgress();
  if (!prog) return;

  const g = prog.games.runner;
  if (g?.caps?.dailyCapCalories != null) DAILY_CAP = Number(g.caps.dailyCapCalories || DAILY_CAP);
  if (g?.today?.calories != null) today = Number(g.today.calories || 0);

  try{
    localStorage.setItem(KEY_RESET, String(resetAt));
    localStorage.setItem(KEY_TODAY, String(today));
  }catch{}
}

/* ===== DOM ===== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

const statusEl = document.getElementById('status');
const bestEl = document.getElementById('best');
const bestMiEl = document.getElementById('bestMi');
const restartBtn = document.getElementById('restartBtn');

const gif = document.getElementById('runnerGif');
const beltFx = document.getElementById('beltFx');
const speedLines = document.getElementById('speedLines');
const vignette = document.getElementById('vignette');

const modalBack = document.getElementById('modalBack');
const mTime = document.getElementById('mTime');
const mRank = document.getElementById('mRank');
const mMiles = document.getElementById('mMiles');
const mCals = document.getElementById('mCals');
const mCalsNote = document.getElementById('mCalsNote');
const mCad = document.getElementById('mCad');
const mIncl = document.getElementById('mIncl');

const runBackBtn = document.getElementById('runBackBtn');
const closeBtn = document.getElementById('closeBtn');
const lbBtn = document.getElementById('lbBtn');
const backBtn = document.getElementById('backBtn');

backBtn.addEventListener('click', () => {
  window.location.href = '../index.html#gym';
});

/* ===== BEST ===== */
const BEST_KEY = 'pf_treadmill_best_seconds';
let best = Number(readLS(BEST_KEY) || 0);
bestEl.textContent = best.toFixed(1) + 's';

const BEST_MILES_KEY = 'pf_treadmill_best_miles';
let bestMiles = Number(readLS(BEST_MILES_KEY) || 0);
bestMiEl.textContent = bestMiles.toFixed(2) + 'mi';

/* ===== INPUT TUNING ===== */
const isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
const TAP_BOOST = isTouch ? 0.26 : 0.18;

let holding=false;
let holdAccumulator=0;
const HOLD_TAPS_PER_SEC = 8.5;

/* Results lock */
let resultsOpen = false;
let inputLockedUntil = 0;
function nowMs(){ return performance.now(); }

/* ===== GAME STATE ===== */
let running=false, gameOver=false;
let t=0, last=performance.now();

let speed=0.34, stamina=1, incline=0, required=0.32;
let tapPulse=0, wobble=0, grace=2.35;

let taps=0;
let beltPhase=0;
let inclinePeak=0;

/* preview calories (UI only; server is truth when logged in) */
let caloriesThisRun=0;

/* miles tracking (derived) */
let milesThisRun = 0;

function clamp01(x){ return Math.max(0, Math.min(1, x)); }

function computeMiles(sec){
  const base = sec / 180;
  const multRaw = 0.85 + 0.35 * clamp01(speed) + 0.20 * clamp01(incline);
  const mult = Math.min(1.35, Math.max(0.75, multRaw));
  return base * mult;
}

function showModal(){
  resultsOpen = true;
  modalBack.style.display = 'flex';
}
function hideModal(){
  resultsOpen = false;
  modalBack.style.display = 'none';
}

function rankFromTime(sec){
  if (sec >= 90) return "CHAD ZILLA";
  if (sec >= 60) return "ULTRA GRINDER";
  if (sec >= 40) return "SWEATY DEGEN";
  if (sec >= 25) return "TREADMILL MENACE";
  if (sec >= 12) return "NEW YEAR SIGNUP";
  return "FIRST DAY BACK";
}

function resetGame(){
  running=false; gameOver=false;
  t=0; speed=0.34; stamina=1; incline=0; required=0.32;
  tapPulse=0; wobble=0; grace=2.35;

  taps=0;
  beltPhase=0;
  inclinePeak=0;
  caloriesThisRun=0;
  milesThisRun=0;

  holding=false;
  holdAccumulator=0;

  statusEl.textContent='Tap to start';

  hideModal();
  inputLockedUntil = 0;

  gif.style.transform = 'translate(0px,0px) rotate(0deg) scale(1)';
  gif.style.filter = 'drop-shadow(0 26px 42px rgba(0,0,0,.55))';
  beltFx.style.opacity = 0;
  speedLines.style.opacity = 0;
  vignette.style.opacity = 0;

  last=performance.now();
}

function tapOnce(){
  const n = nowMs();
  if (resultsOpen || n < inputLockedUntil) return;
  if (gameOver) return;

  if (!running){
    running = true;
    statusEl.textContent = 'RUN';
    last = performance.now();
    tapPulse = Math.max(tapPulse, 0.88);

    // quiet sync (doesn't block)
    syncFromServer();
  }

  tapPulse = Math.min(2.0, tapPulse + TAP_BOOST);
  taps++;
}

window.addEventListener('pointerdown', (e) => {
  if (e && typeof e.preventDefault === 'function') e.preventDefault();
  if (resultsOpen || nowMs() < inputLockedUntil) return;
  holding = true;
  tapOnce();
}, {passive:false});

window.addEventListener('pointerup',   () => { holding = false; }, {passive:true});
window.addEventListener('pointercancel',() => { holding = false; }, {passive:true});

window.addEventListener('keydown', e => {
  if (e.code === 'Space') tapOnce();
});

restartBtn.addEventListener('click', () => resetGame());

runBackBtn.addEventListener('click', () => {
  resetGame();
  running = true;
  statusEl.textContent = 'RUN';
  tapPulse = 0.95;
  syncFromServer();
});

closeBtn.addEventListener('click', () => hideModal());

lbBtn.addEventListener('click', () => {
  window.location.href = '../index.html#leaderboard';
});

modalBack.addEventListener('click', (e) => {
  if (e.target === modalBack) hideModal();
});

/* ===== UPDATE ===== */
function update(dt){
  if (!running) return;
  dt = Math.min(0.02, dt);

  t += dt;
  grace = Math.max(0, grace - dt);

  milesThisRun = computeMiles(t);

  if (holding && !gameOver && !resultsOpen){
    holdAccumulator += dt * HOLD_TAPS_PER_SEC;
    while (holdAccumulator >= 1){
      holdAccumulator -= 1;
      tapPulse = Math.min(2.0, tapPulse + (TAP_BOOST * 0.55));
      taps++;
    }
  }

  const ramp = 1 - Math.exp(-t/40);
  incline = 0.04 + 0.85*ramp;
  required = 0.30 + 0.55*ramp;
  inclinePeak = Math.max(inclinePeak, incline);

  tapPulse = Math.max(0, tapPulse - (0.78 + 0.95*incline)*dt);

  const target = 0.22 + 0.78*(tapPulse/1.25)*(0.62 + 0.38*stamina);
  speed += (target - speed) * 3.1 * dt;

  speed = Math.max(0, speed - (0.17 + 0.52*incline) * dt);

  stamina = Math.max(0, stamina - (0.045 + 0.20*incline + 0.095*speed) * dt);
  if (tapPulse > 0.70) stamina = Math.min(1, stamina + 0.065*dt);

  const intensity = (0.80 + 0.75*speed + 0.55*incline);
  const calPerSec = 0.95;
  caloriesThisRun += intensity * calPerSec * dt;

  if (grace <= 0 && (speed < required - 0.02 || stamina <= 0)){
    wobble += dt * 3.2;
    if (wobble > 1){
      gameOver = true;
      running = false;
      holding = false;

      statusEl.textContent = 'Flew off üí•';

      if (t > best){
        best = t;
        try { localStorage.setItem(BEST_KEY, String(best)); } catch {}
        bestEl.textContent = best.toFixed(1) + 's';
      }

      if (milesThisRun > bestMiles){
        bestMiles = milesThisRun;
        try { localStorage.setItem(BEST_MILES_KEY, String(bestMiles)); } catch {}
        bestMiEl.textContent = bestMiles.toFixed(2) + 'mi';
      }

      const cadence = taps / Math.max(0.1, t);

      // midnight guard (tab left open)
      if (Date.now() > resetAt){
        today = 0;
        resetAt = nextMidnight();
      }

      mTime.textContent = t.toFixed(1) + 's';
      mRank.textContent = rankFromTime(t);
      mMiles.textContent = milesThisRun.toFixed(2) + 'mi';
      mCad.textContent = cadence.toFixed(1) + '/s';
      mIncl.textContent = (inclinePeak * 10).toFixed(1) + '%';

      inputLockedUntil = nowMs() + 450;

      // ===== SECURE SUBMIT (server decides earned calories) =====
      const durationMs = Math.max(0, Math.round(t * 1000));
      const milesSafe = Number(milesThisRun.toFixed(4));
      const bestSeconds = Number(t.toFixed(3));

      const token = getToken();
      const canSubmit = !!(API_BASE && token);

      const rawPreview = Math.max(0, Math.round(caloriesThisRun));

      if (canSubmit){
        // IMPORTANT: do NOT add local "today" here (prevents double counting)
        mCals.textContent = "‚Ä¶";
        mCalsNote.textContent = `Submitting run‚Ä¶`;

        submitSecureRunner({
          game: "runner",
          durationMs,
          miles: milesSafe,
          bestSeconds,
          // optional signal (server rules ignore score for runner; harmless)
          score: Math.floor(bestSeconds)
        }).then((res)=>{
          if (res && res.ok){
            const earned = Number(res.earnedCalories || 0);
            const todayServer = Number(res.today?.calories ?? today);
            const capServer = Number(res.caps?.dailyCapCalories ?? DAILY_CAP);

            // reconcile UI to server truth
            DAILY_CAP = capServer;
            today = todayServer;

            try{
              localStorage.setItem(KEY_TODAY, String(today));
              localStorage.setItem(KEY_RESET, String(resetAt));
            }catch{}

            mCals.textContent = String(earned);
            mCalsNote.textContent = `Run logged ‚úÖ (${earned} credited ‚Ä¢ today ${today}/${DAILY_CAP})`;
          } else {
            // submit failed -> fall back to local *single* credit
            const creditedFallback = Math.max(0, Math.min(rawPreview, DAILY_CAP - today));
            today += creditedFallback;

            try{
              localStorage.setItem(KEY_TODAY, String(today));
              localStorage.setItem(KEY_RESET, String(resetAt));
            }catch{}

            mCals.textContent = String(creditedFallback);
            const errMsg = (res && (res.error || res.message)) ? String(res.error || res.message) : '';
            mCalsNote.textContent =
              `Couldn‚Äôt submit right now ‚Äî counted locally. (${creditedFallback} credited ‚Ä¢ today ${today}/${DAILY_CAP})` +
              (errMsg ? ` ‚Ä¢ ${errMsg}` : ``);
          }
        });
      } else {
        // guest run -> local preview credit (not lifetime)
        const creditedFallback = Math.max(0, Math.min(rawPreview, DAILY_CAP - today));
        today += creditedFallback;

        try{
          localStorage.setItem(KEY_TODAY, String(today));
          localStorage.setItem(KEY_RESET, String(resetAt));
        }catch{}

        mCals.textContent = String(creditedFallback);
        mCalsNote.textContent = `Connect your wallet on the main site to stack lifetime calories. (${creditedFallback} credited ‚Ä¢ today ${today}/${DAILY_CAP})`;
      }

      showModal();
    }
  } else {
    wobble = Math.max(0, wobble - dt*2.2);
  }
}

/* ===== MOTION CUES ===== */
function applySceneMotion(){
  if (gameOver){
    beltFx.style.opacity = 0;
    speedLines.style.opacity = 0;
    vignette.style.opacity = 0.25;
    gif.style.filter = 'drop-shadow(0 0 24px rgba(255,60,90,.55)) drop-shadow(0 26px 42px rgba(0,0,0,.55))';
    return;
  }

  const leanDeg = -incline * 10.5;
  const scale = 0.98 + speed * 0.10;

  const baseRumble = (0.55 + speed*1.55) * (running ? 1 : 0);
  const panic = wobble > 0 ? (wobble * 2.2) : 0;
  const rumble = baseRumble + panic;

  const rx = (Math.random()*2-1) * rumble;
  const ry = (Math.random()*2-1) * rumble;

  const driftY = (speed > 0.65 ? -1.2 : 0) + (incline * -2.0);

  gif.style.transform = `translate(${rx}px, ${ry + driftY}px) rotate(${leanDeg}deg) scale(${scale})`;

  beltPhase += (220 + 1200*speed) * 0.016;
  beltFx.style.backgroundPosition = `${-beltPhase}px 0px`;
  beltFx.style.opacity = Math.min(0.55, Math.max(0, (speed - 0.20) * 0.9));

  speedLines.style.opacity = Math.min(0.45, Math.max(0, (speed - 0.35) * 0.55));

  const danger = (grace<=0) && (speed < required+0.01 || stamina < 0.12);
  vignette.style.opacity = danger ? (0.55 + 0.20*Math.sin(performance.now()/80)) : 0;

  if (danger){
    gif.style.filter = 'drop-shadow(0 0 18px rgba(255,60,90,.40)) drop-shadow(0 26px 42px rgba(0,0,0,.55))';
  } else if (speed > 0.75){
    gif.style.filter = 'drop-shadow(0 0 18px rgba(255,212,0,.35)) drop-shadow(0 26px 42px rgba(0,0,0,.55))';
  } else {
    gif.style.filter = 'drop-shadow(0 26px 42px rgba(0,0,0,.55))';
  }
}

/* ===== HUD ===== */
function drawHUD(){
  ctx.clearRect(0,0,900,520);

  ctx.fillStyle = 'rgba(255,255,255,.95)';
  ctx.font = '900 28px system-ui';
  ctx.fillText(t.toFixed(1)+'s', 34, 52);

  const cadence = taps / Math.max(0.1, t);
  ctx.fillStyle = 'rgba(255,255,255,.72)';
  ctx.font = '800 13px system-ui';
  ctx.fillText('Cadence: ' + cadence.toFixed(1) + '/s', 34, 78);

  const mi = milesThisRun || 0;
  const paceMinPerMi = mi > 0.0001 ? (t / 60) / mi : 0;
  const paceStr = mi > 0.0001 ? formatPace(paceMinPerMi) : '‚Äî';
  ctx.fillText('Miles: ' + mi.toFixed(2) + ' ‚Ä¢ Pace: ' + paceStr + '/mi', 34, 102);

  // preview only
  const calsPreview = Math.max(0, Math.round(caloriesThisRun));
  ctx.fillText('Calories: ' + calsPreview, 34, 126);

  drawBar(40, 450, 380, 22, speed, 'Speed', true);
  drawBar(480, 450, 380, 22, stamina, 'Stamina', false);
}

function formatPace(minPerMi){
  if (!isFinite(minPerMi) || minPerMi <= 0) return '‚Äî';
  const totalSec = Math.max(0, Math.round(minPerMi * 60));
  const m = Math.floor(totalSec / 60);
  const s = totalSec % 60;
  return m + ':' + String(s).padStart(2,'0');
}

function drawBar(x,y,w,h,p,label,isSpeed){
  ctx.fillStyle = 'rgba(255,255,255,.14)';
  ctx.fillRect(x,y,w,h);

  const val = Math.max(0, Math.min(1, p));
  ctx.fillStyle = isSpeed ? '#ffd400' : '#7fff7f';
  ctx.fillRect(x,y,w*val,h);

  ctx.fillStyle = 'rgba(0,0,0,.82)';
  ctx.font = '900 12px system-ui';
  ctx.fillText(label, x+8, y+15);

  if (isSpeed){
    const req = Math.max(0, Math.min(1, required));
    ctx.strokeStyle = 'rgba(255,255,255,.45)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x + w*req, y);
    ctx.lineTo(x + w*req, y+h);
    ctx.stroke();
  }
}

/* ===== LOOP ===== */
function loop(now){
  const dt = (now - last) / 1000;
  last = now;

  update(dt);
  applySceneMotion();
  drawHUD();

  requestAnimationFrame(loop);
}

resetGame();

// quiet sync on load (if logged in)
syncFromServer();

requestAnimationFrame(loop);
</script>
</body>
</html>