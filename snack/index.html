<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>$PHAT ‚Äî Conveyor Munch</title>
  <style>
    :root{
      --bg1:#2a1442;
      --bg2:#140a22;
      --card:rgba(255,255,255,.06);
      --card2:rgba(255,255,255,.08);
      --stroke:rgba(255,255,255,.10);
      --txt:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.70);
      --pill:rgba(0,0,0,.35);
      --good:#6dffb3;
      --bad:#ff6d8a;
      --accent:#ffd44d;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--txt);
      background:
        radial-gradient(1000px 700px at 50% 10%, rgba(255,255,255,.08), transparent 60%),
        radial-gradient(900px 700px at 50% 60%, rgba(255,255,255,.05), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      min-height:100vh;
      display:flex;
      justify-content:center;
    }

    .wrap{
      width:min(980px, 94vw);
      padding:18px 0 28px;
    }

    .topbar{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      margin-bottom:12px;
    }

    .titleBox{
      flex:1;
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:20px;
      padding:14px 16px;
      backdrop-filter: blur(10px);
    }

    .titleLine{
      font-weight:800;
      letter-spacing:.3px;
      font-size:18px;
      opacity:.95;
      margin-bottom:6px;
    }

    .subLine{
      color:var(--muted);
      font-size:14px;
      line-height:1.3;
    }

    .btn{
      border:0;
      background:var(--accent);
      color:#231400;
      font-weight:900;
      padding:12px 14px;
      border-radius:16px;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      cursor:pointer;
      white-space:nowrap;
    }

    .btn:active{ transform: translateY(1px); }

    .stats{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:12px;
      margin:12px 0 14px;
    }
    .stat{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:18px;
      padding:14px;
      backdrop-filter: blur(10px);
      min-height:86px;
    }
    .stat .k{
      font-size:12px;
      letter-spacing:1.8px;
      font-weight:800;
      opacity:.75;
    }
    .stat .v{
      font-size:34px;
      font-weight:900;
      margin-top:4px;
      line-height:1;
    }
    .stat .s{
      margin-top:6px;
      color:var(--muted);
      font-size:13px;
    }

    .stageCard{
      position:relative;
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:24px;
      padding:14px;
      backdrop-filter: blur(10px);
      overflow:hidden;
    }

    .stage{
      position:relative;
      width:100%;
      aspect-ratio: 9 / 12;
      border-radius:18px;
      background: radial-gradient(700px 500px at 50% 15%, rgba(255,255,255,.08), transparent 60%);
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
    }

    /* Scene background image */
    .scene{
      position:absolute;
      inset:0;
      background: transparent;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      z-index:2;
    }
    .scene img{
      width:100%;
      height:100%;
      object-fit:contain;
      object-position:center;
      user-select:none;
      -webkit-user-drag:none;
    }

    /* Thought bubble + label cluster */
    .thoughtCluster{
      position:absolute;
      left:50%;
      top:17%;
      transform:translateX(-50%);
      z-index:6;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
      pointer-events:none;
    }

    .targetName{
      background:var(--pill);
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      padding:10px 14px;
      font-weight:900;
      letter-spacing:3px;
      text-transform:uppercase;
      text-align:center;
      max-width:min(92vw, 520px);
      line-height:1.15;
      font-size:16px;
      box-shadow:0 10px 24px rgba(0,0,0,.25);
      word-break:break-word;
    }

    .thought{
      position:relative;
      width:min(260px, 56vw);
      aspect-ratio: 4 / 3;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .thought img.bubble{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit:contain;
      opacity:1;
      user-select:none;
      -webkit-user-drag:none;
    }
    .thought img.food{
      position:relative;
      width:46%;
      height:46%;
      object-fit:contain;
      transform: translateY(-2%);
      user-select:none;
      -webkit-user-drag:none;
    }

    /* Conveyor items */
    .itemsLayer{
      position:absolute;
      inset:0;
      z-index:5;
      pointer-events:none; /* items themselves will override */
    }

    .foodItem{
      position:absolute;
      width:86px; /* ‚Äúgood‚Äù size baseline */
      height:86px;
      display:flex;
      align-items:center;
      justify-content:center;
      transform: translate3d(0,0,0);
      will-change: transform;
      pointer-events:auto;
      touch-action:none;
      user-select:none;
      -webkit-user-drag:none;
      z-index:7; /* above scene so you can grab */
    }
    .foodItem img{
      width:100%;
      height:100%;
      object-fit:contain;
      user-select:none;
      -webkit-user-drag:none;
      pointer-events:none;
    }

    /* Mouth drop target (invisible) */
    .mouthTarget{
      position:absolute;
      left:50%;
      top:43.5%;
      transform:translate(-50%,-50%);
      width:140px;
      height:110px;
      border-radius:999px;
      z-index:8;
      pointer-events:none;
      opacity:0;
      outline:2px dashed rgba(109,255,179,.75);
      outline-offset:6px;
    }

    .debugOn .mouthTarget{ opacity:.18; }

    /* Feedback */
    .toast{
      position:absolute;
      left:50%;
      top:52%;
      transform:translate(-50%,-50%);
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.14);
      border-radius:999px;
      padding:10px 16px;
      font-weight:900;
      letter-spacing:2px;
      text-transform:uppercase;
      z-index:10;
      display:none;
    }
    .toast.good{ color:var(--good); }
    .toast.bad{ color:var(--bad); }

    .bottomRow{
      display:flex;
      gap:12px;
      margin-top:12px;
    }
    .ghostBtn{
      flex:1;
      border:1px solid var(--stroke);
      background:var(--card2);
      color:var(--txt);
      padding:12px 14px;
      border-radius:16px;
      font-weight:800;
      cursor:pointer;
    }

    .how{
      margin-top:12px;
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:18px;
      padding:14px 16px;
      color:var(--muted);
      line-height:1.35;
    }

    .how b{ color:var(--txt); }

    @media (min-width:720px){
      .stage{ aspect-ratio: 16 / 15; }
      .foodItem{ width:92px; height:92px; }
      .thoughtCluster{ top:15%; }
      .mouthTarget{ top:44%; width:150px; height:115px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="titleBox">
        <div class="titleLine">$PHAT ‚Äî Conveyor Munch</div>
        <div class="subLine">Drag the correct snack into his mouth. Miss = pain. Streak = glory.</div>
      </div>
      <button class="btn" id="btnReset">Run it back</button>
    </div>

    <div class="stats">
      <div class="stat">
        <div class="k">RUN</div>
        <div class="v" id="runScore">0</div>
        <div class="s">Streak: <span id="streak">0</span> ¬∑ Mult: <span id="mult">1.0x</span></div>
      </div>
      <div class="stat">
        <div class="k">BEST</div>
        <div class="v" id="bestScore">0</div>
        <div class="s">Daily best: <span id="dailyBest">0</span></div>
      </div>
      <div class="stat">
        <div class="k">DAILY GOAL</div>
        <div class="v"><span id="dailyNow">0</span> / 30</div>
        <div class="s">Resets in <span id="resetIn">--:--:--</span></div>
      </div>
    </div>

    <div class="stageCard">
      <div class="stage" id="stage">
        <div class="thoughtCluster">
          <div class="targetName" id="targetName">‚Äî</div>
          <div class="thought">
            <img class="bubble" src="../assets/thought-bubble.png" alt="thought bubble" />
            <img class="food" id="targetFoodImg" src="" alt="target food" />
          </div>
        </div>

        <div class="mouthTarget" id="mouthTarget"></div>

        <div class="itemsLayer" id="itemsLayer"></div>

        <div class="scene">
          <img src="../assets/stack_scene.png" alt="scene" />
        </div>

        <div class="toast" id="toast"></div>
      </div>

      <div class="bottomRow">
        <button class="ghostBtn" id="btnShare">Share score</button>
        <button class="ghostBtn" id="btnDebug">Toggle debug</button>
      </div>

      <div class="how">
        <b>How it plays:</b> The thought bubble shows what he wants. The belt feeds a nonstop stream of snacks.
        Grab the correct one <b>between the wrong choices</b> and drag it to his mouth before it rolls away.
      </div>
    </div>
  </div>

<script>
(() => {
  // --- Assets (ALL of your foods) ---
  const FOODS = [
    { id:"brownies",           label:"Brownies",          src:"../assets/food_brownies.png" },
    { id:"burger",             label:"Burger",            src:"../assets/food_burger.png" },
    { id:"cake",               label:"Cake",              src:"../assets/food_cake.png" },
    { id:"takeout",            label:"Chinese Takeout",   src:"../assets/food_chinese_takeout.png" },
    { id:"pizookie",           label:"Pizookie",          src:"../assets/food_cookie_pizza.png" }, // rename label only
    { id:"donut_stack",        label:"Donut Stack",       src:"../assets/food_donut_stack.png" },
    { id:"fried_chicken",      label:"Fried Chicken",     src:"../assets/food_fried_chicken.png" },
    { id:"fries",              label:"Fries",             src:"../assets/food_fries.png" },
    { id:"grilledcheese",      label:"Grilled Cheese",    src:"../assets/food_grilledcheese.png" },
    { id:"hotdogs",            label:"Hot Dogs",          src:"../assets/food_hotdogs.png" },
    { id:"icecream",           label:"Ice Cream",         src:"../assets/food_icecream_cone.png" },
    { id:"shake_choc",         label:"Chocolate Shake",   src:"../assets/food_milkshake_chocolate.png" },
    { id:"shake_straw",        label:"Strawberry Shake",  src:"../assets/food_milkshake_strawberry.png" },
    { id:"shake_van",          label:"Vanilla Shake",     src:"../assets/food_milkshake_vanilla.png" },
    { id:"onion_rings",        label:"Onion Rings",       src:"../assets/food_onion_rings.png" },
    { id:"pancakes",           label:"Pancakes",          src:"../assets/food_pancakes.png" },
    { id:"pizza_stack",        label:"Pizza Stack",       src:"../assets/food_pizza_stack.png" },
    { id:"popcorn",            label:"Popcorn",           src:"../assets/food_popcorn.png" },
    { id:"soda",               label:"Soda",              src:"../assets/food_soda.png" },
    { id:"sub",                label:"Sub",               src:"../assets/food_sub.png" },
  ];

  // --- DOM ---
  const stage = document.getElementById('stage');
  const itemsLayer = document.getElementById('itemsLayer');
  const targetNameEl = document.getElementById('targetName');
  const targetFoodImg = document.getElementById('targetFoodImg');
  const mouthTarget = document.getElementById('mouthTarget');
  const toast = document.getElementById('toast');

  const runScoreEl = document.getElementById('runScore');
  const bestScoreEl = document.getElementById('bestScore');
  const dailyBestEl = document.getElementById('dailyBest');
  const streakEl = document.getElementById('streak');
  const multEl = document.getElementById('mult');
  const dailyNowEl = document.getElementById('dailyNow');
  const resetInEl = document.getElementById('resetIn');

  const btnReset = document.getElementById('btnReset');
  const btnShare = document.getElementById('btnShare');
  const btnDebug = document.getElementById('btnDebug');

  // --- State ---
  let debug = false;

  let runScore = 0;
  let streak = 0;
  let bestScore = 0;

  // Daily
  const LS_KEY = 'phat_snack_daily_v1';
  const LS_BEST = 'phat_snack_dailybest_v1';
  const LS_BEST_RUN = 'phat_snack_best_run_v1';

  function todayKey(){
    const d = new Date();
    return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
  }

  function loadDaily(){
    const k = todayKey();
    const raw = localStorage.getItem(LS_KEY);
    if(!raw){
      localStorage.setItem(LS_KEY, JSON.stringify({ day:k, count:0 }));
      return { day:k, count:0 };
    }
    try{
      const obj = JSON.parse(raw);
      if(obj.day !== k){
        localStorage.setItem(LS_KEY, JSON.stringify({ day:k, count:0 }));
        return { day:k, count:0 };
      }
      return obj;
    }catch{
      localStorage.setItem(LS_KEY, JSON.stringify({ day:k, count:0 }));
      return { day:k, count:0 };
    }
  }

  function saveDailyCount(count){
    localStorage.setItem(LS_KEY, JSON.stringify({ day:todayKey(), count }));
  }

  function nextMidnightMs(){
    const now = new Date();
    const next = new Date(now);
    next.setHours(24,0,0,0);
    return next.getTime() - now.getTime();
  }

  function tickReset(){
    let ms = nextMidnightMs();
    if(ms < 0) ms = 0;
    const s = Math.floor(ms/1000);
    const hh = String(Math.floor(s/3600)).padStart(2,'0');
    const mm = String(Math.floor((s%3600)/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    resetInEl.textContent = `${hh}:${mm}:${ss}`;
  }
  setInterval(tickReset, 250);
  tickReset();

  // --- Conveyor config ---
  // Belt Y tuned to your stack_scene.png so foods sit on the belt.
  // If you ever tweak the scene art, only adjust BELT_Y.
  function rect(el){ return el.getBoundingClientRect(); }

  // Items visible + spacing (prevents overlap / mis-grab)
  const MAX_ONSCREEN = 6;            // pressure without chaos
  const MIN_GAP_PX = 88;             // spacing between item centers
  const LANES = 1;                   // keep single lane to avoid stacked overlap
  let SPEED = 155;                   // px/sec baseline (we‚Äôll scale with streak)

  // Food size (back to ‚Äúgood‚Äù)
  // This is the one you said felt right before it got huge.
  const FOOD_SIZE_PX_MOBILE = 90;
  const FOOD_SIZE_PX_DESKTOP = 96;

  // Mouth target is intentionally forgiving
  function isInMouth(clientX, clientY){
    const m = mouthTarget.getBoundingClientRect();
    return (clientX >= m.left && clientX <= m.right && clientY >= m.top && clientY <= m.bottom);
  }

  // --- Target selection ---
  let target = null;
  function pickTarget(){
    target = FOODS[Math.floor(Math.random()*FOODS.length)];
    targetNameEl.textContent = target.label.toUpperCase();
    targetFoodImg.src = target.src;
  }

  // --- Food item objects ---
  const items = [];
  let lastTs = performance.now();

  function stageDims(){
    const r = stage.getBoundingClientRect();
    return { w:r.width, h:r.height, left:r.left, top:r.top };
  }

  function beltY(){
    // Belt ride line tuned visually: around the upper belt surface in your new scene.
    // Uses stage height so it stays consistent on different screens.
    const { h } = stageDims();
    return Math.round(h * 0.675); // sweet spot for your stack_scene.png
  }

  function setFoodSize(){
    const px = (window.innerWidth >= 720) ? FOOD_SIZE_PX_DESKTOP : FOOD_SIZE_PX_MOBILE;
    document.querySelectorAll('.foodItem').forEach(el => {
      el.style.width = px + 'px';
      el.style.height = px + 'px';
    });
  }

  function spawnItem(x = null){
    const { w } = stageDims();
    const px = (window.innerWidth >= 720) ? FOOD_SIZE_PX_DESKTOP : FOOD_SIZE_PX_MOBILE;

    // Choose a food at random
    const f = FOODS[Math.floor(Math.random()*FOODS.length)];

    // Create DOM
    const el = document.createElement('div');
    el.className = 'foodItem';
    el.style.width = px + 'px';
    el.style.height = px + 'px';

    const img = document.createElement('img');
    img.src = f.src;
    img.alt = f.label;

    el.appendChild(img);
    itemsLayer.appendChild(el);

    // Position: right to left
    const y = beltY() - Math.round(px * 0.55); // sit ‚Äúon‚Äù belt instead of floating
    const startX = (x !== null) ? x : (w + px + Math.random()*40);

    const obj = {
      id: crypto.randomUUID ? crypto.randomUUID() : String(Math.random()),
      food: f,
      el,
      x: startX,
      y,
      vx: -SPEED,
      dragging: false,
      dragOffsetX: 0,
      dragOffsetY: 0,
      pointerId: null,
      zBase: 7
    };

    // Pointer handling (no jump)
    el.addEventListener('pointerdown', (ev) => {
      ev.preventDefault();
      el.setPointerCapture(ev.pointerId);

      // Bring to front while dragging
      el.style.zIndex = 999;

      const er = el.getBoundingClientRect();
      obj.dragging = true;
      obj.pointerId = ev.pointerId;

      // Keep offset so it doesn't jump
      obj.dragOffsetX = ev.clientX - er.left;
      obj.dragOffsetY = ev.clientY - er.top;

      // Freeze belt movement while dragging THIS item
      obj.vx = 0;
    }, { passive:false });

    el.addEventListener('pointermove', (ev) => {
      if(!obj.dragging || obj.pointerId !== ev.pointerId) return;
      const { left, top } = stageDims();

      obj.x = (ev.clientX - left) - obj.dragOffsetX;
      obj.y = (ev.clientY - top) - obj.dragOffsetY;

      // clamp inside stage a bit
      const { w, h } = stageDims();
      obj.x = Math.max(-40, Math.min(w - px + 40, obj.x));
      obj.y = Math.max(-40, Math.min(h - px + 40, obj.y));
    }, { passive:true });

    el.addEventListener('pointerup', (ev) => {
      if(!obj.dragging || obj.pointerId !== ev.pointerId) return;

      obj.dragging = false;
      obj.pointerId = null;

      // Restore z-index
      el.style.zIndex = obj.zBase;

      // Check drop success
      const hit = isInMouth(ev.clientX, ev.clientY);

      if(hit){
        if(obj.food.id === target.id){
          onCorrect(obj);
        } else {
          onMiss(obj);
        }
      } else {
        // If they let go not on mouth, snap back to belt (keeps pressure)
        snapToBelt(obj);
      }
    });

    el.addEventListener('pointercancel', () => {
      if(!obj.dragging) return;
      obj.dragging = false;
      obj.pointerId = null;
      el.style.zIndex = obj.zBase;
      snapToBelt(obj);
    });

    items.push(obj);
    return obj;
  }

  function snapToBelt(obj){
    const px = (window.innerWidth >= 720) ? FOOD_SIZE_PX_DESKTOP : FOOD_SIZE_PX_MOBILE;
    obj.y = beltY() - Math.round(px * 0.55);
    obj.vx = -SPEED; // resume movement
  }

  function removeItem(obj){
    const idx = items.indexOf(obj);
    if(idx >= 0) items.splice(idx,1);
    obj.el.remove();
  }

  // Prevent overlapping/stacking on belt
  function enforceSpacing(){
    // Only enforce for non-dragging items
    const live = items.filter(it => !it.dragging).sort((a,b)=>a.x-b.x);
    for(let i=1;i<live.length;i++){
      const a = live[i-1], b = live[i];
      const dx = (b.x - a.x);
      if(dx < MIN_GAP_PX){
        b.x = a.x + MIN_GAP_PX;
      }
    }
  }

  // Spawn enough items to keep pressure, without chaos
  function topUpItems(){
    const { w } = stageDims();
    const px = (window.innerWidth >= 720) ? FOOD_SIZE_PX_DESKTOP : FOOD_SIZE_PX_MOBILE;

    // Count items that are ‚Äúactive‚Äù (not far offscreen)
    const active = items.filter(it => it.x > -px*1.5).length;
    if(active >= MAX_ONSCREEN) return;

    // Spawn behind the right edge with spacing from right-most item
    const rightMost = items.reduce((m,it)=>Math.max(m,it.x), -Infinity);
    let spawnX = (rightMost === -Infinity) ? (w + px) : (rightMost + MIN_GAP_PX);
    while(items.filter(it => it.x > -px*1.5).length < MAX_ONSCREEN){
      spawnItem(spawnX);
      spawnX += MIN_GAP_PX;
    }
  }

  // --- Scoring + feedback ---
  function showToast(text, good){
    toast.textContent = text;
    toast.className = 'toast ' + (good ? 'good' : 'bad');
    toast.style.display = 'block';
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toast.style.display = 'none', 650);
  }

  function updateHUD(){
    runScoreEl.textContent = runScore;
    bestScoreEl.textContent = bestScore;

    streakEl.textContent = streak;
    const mult = (1 + Math.min(0.8, streak * 0.05)).toFixed(1);
    multEl.textContent = mult + 'x';

    // daily
    const d = loadDaily();
    dailyNowEl.textContent = d.count;

    const db = Number(localStorage.getItem(LS_BEST) || '0');
    dailyBestEl.textContent = db;
  }

  function onCorrect(obj){
    runScore += 1;
    streak += 1;

    // speed scales slightly with streak (more pressure)
    const mult = 1 + Math.min(0.75, streak * 0.04);
    SPEED = 155 * mult;

    // daily count
    const d = loadDaily();
    d.count += 1;
    saveDailyCount(d.count);

    // bests
    bestScore = Math.max(bestScore, runScore);
    localStorage.setItem(LS_BEST_RUN, String(bestScore));

    const dailyBest = Number(localStorage.getItem(LS_BEST) || '0');
    if(runScore > dailyBest) localStorage.setItem(LS_BEST, String(runScore));

    showToast('FED ‚úÖ', true);

    removeItem(obj);
    pickTarget();
    updateHUD();
  }

  function onMiss(obj){
    streak = 0;
    SPEED = 155;

    showToast('MISSED ‚ùå', false);

    // remove the wrong fed item too (keeps game moving)
    removeItem(obj);
    pickTarget();
    updateHUD();
  }

  // --- Animation loop ---
  function render(){
    const px = (window.innerWidth >= 720) ? FOOD_SIZE_PX_DESKTOP : FOOD_SIZE_PX_MOBILE;

    for(const it of items){
      it.el.style.transform = `translate3d(${it.x}px, ${it.y}px, 0)`;
    }
  }

  function step(ts){
    const dt = Math.min(0.033, (ts - lastTs) / 1000);
    lastTs = ts;

    // Move non-dragging items
    for(const it of items){
      if(it.dragging) continue;
      it.vx = -SPEED;
      it.x += it.vx * dt;

      // keep locked to belt line (prevents float if layout changes)
      it.y = beltY() - Math.round(px * 0.55);
    }

    // Remove offscreen
    for(let i=items.length-1;i>=0;i--){
      if(items[i].x < -px*2){
        removeItem(items[i]);
      }
    }

    enforceSpacing();
    topUpItems();
    render();

    requestAnimationFrame(step);
  }

  // --- Controls ---
  function hardReset(){
    // clear items
    while(items.length) removeItem(items[0]);

    runScore = 0;
    streak = 0;
    SPEED = 155;
    bestScore = Number(localStorage.getItem(LS_BEST_RUN) || '0');

    pickTarget();
    topUpItems();
    updateHUD();
  }

  btnReset.addEventListener('click', hardReset);

  btnShare.addEventListener('click', async () => {
    const d = loadDaily();
    const text = `$PHAT Conveyor Munch\nRun: ${runScore}\nStreak: ${streak}\nDaily: ${d.count}/30\nplanetfatness.fit/snack/`;
    try{
      if(navigator.share){
        await navigator.share({ text });
      } else {
        await navigator.clipboard.writeText(text);
        showToast('COPIED üìã', true);
      }
    }catch{
      // ignore
    }
  });

  btnDebug.addEventListener('click', () => {
    debug = !debug;
    stage.classList.toggle('debugOn', debug);
  });

  // --- Init ---
  // Persist best run
  bestScore = Number(localStorage.getItem(LS_BEST_RUN) || '0');

  // Ensure bubble asset loads (avoid blank on slow loads)
  targetFoodImg.onload = () => {};
  targetFoodImg.onerror = () => { targetFoodImg.src = ""; };

  pickTarget();
  topUpItems();
  updateHUD();
  setFoodSize();

  // Recalculate on resize/orientation
  window.addEventListener('resize', () => {
    setFoodSize();
  });

  requestAnimationFrame(step);
})();
</script>
</body>
</html>