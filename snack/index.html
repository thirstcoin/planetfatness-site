<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>$PHAT — Conveyor Munch</title>

  <style>
    :root{
      --bg1:#2a1442; --bg2:#140a22;
      --card:rgba(255,255,255,.06);
      --stroke:rgba(255,255,255,.10);
      --txt:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.70);
      --accent:#ffd44d;
      --good:#6dffb3;
      --bad:#ff6d8a;

      --mp4-top:#6f3cff;
      --mp4-mid:#6a36ff;
      --mp4-bot:#6431ff;

      /* Ride height knob */
      --beltY: 88.4%;

      /* Head safe */
      --videoFit: contain;
      --videoPosY: 100%;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--txt);
      background:
        radial-gradient(1000px 700px at 50% 10%, rgba(255,255,255,.08), transparent 60%),
        radial-gradient(900px 700px at 50% 60%, rgba(255,255,255,.05), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      min-height:100vh;
      display:flex;
      justify-content:center;
    }
    .wrap{ width:min(980px, 94vw); padding:18px 0 28px; }

    .topbar{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      margin-bottom:12px;
    }
    .titleBox{
      flex:1;
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:20px;
      padding:14px 16px;
      backdrop-filter: blur(10px);
    }
    .titleLine{ font-weight:800; letter-spacing:.3px; font-size:18px; opacity:.95; margin-bottom:6px; }
    .subLine{ color:var(--muted); font-size:14px; line-height:1.3; }

    .btn{
      border:0;
      background:var(--accent);
      color:#231400;
      font-weight:900;
      padding:12px 14px;
      border-radius:16px;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      cursor:pointer;
      white-space:nowrap;
    }
    .btn:active{ transform: translateY(1px); }

    .stats{
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap:10px;
      margin-bottom:12px;
    }
    .stat{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:18px;
      padding:14px 14px 12px;
      backdrop-filter: blur(10px);
      min-height:72px;
    }
    .stat h4{ margin:0 0 6px; font-size:12px; letter-spacing:.22em; opacity:.75; }
    .stat .big{ font-size:34px; font-weight:900; line-height:1; }
    .stat .sub{ margin-top:6px; color:var(--muted); font-size:13px; }

    .panel{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:22px;
      padding:14px;
      backdrop-filter: blur(10px);
    }

    .stage{
      position:relative;
      width:100%;
      aspect-ratio: 9/11;
      max-height: 820px;
      border-radius:22px;
      overflow:hidden;
      background:
        radial-gradient(700px 520px at 50% 18%, rgba(255,255,255,.12), transparent 55%),
        linear-gradient(180deg, var(--mp4-top) 0%, var(--mp4-mid) 45%, var(--mp4-bot) 100%);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
    }
    .stage::after{
      content:"";
      position:absolute; inset:0;
      pointer-events:none;
      z-index:12;
      background:
        radial-gradient(900px 760px at 50% 30%, rgba(0,0,0,0), rgba(0,0,0,.18) 70%),
        linear-gradient(180deg, rgba(0,0,0,.10), rgba(0,0,0,0) 35%, rgba(0,0,0,.10));
      mix-blend-mode: multiply;
    }

    .scene{
      position:absolute; inset:0;
      pointer-events:none;
      z-index:10;
    }
    .scene video{
      width:100%;
      height:100%;
      object-fit: var(--videoFit);
      object-position: 50% var(--videoPosY);
      display:block;
      background: transparent;
    }

    .targetCluster{
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      top: 10%;
      width:min(520px, 92%);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
      pointer-events:none;
      z-index:30;
    }
    .targetLabel{
      background:rgba(0,0,0,.40);
      border:1px solid rgba(255,255,255,.16);
      border-radius:999px;
      padding:10px 16px;
      font-weight:900;
      letter-spacing:.18em;
      text-indent:.18em;
      text-transform:uppercase;
      max-width:92%;
      overflow:hidden;
      white-space:nowrap;
      text-overflow:ellipsis;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .bubbleWrap{
      position:relative;
      width:min(360px, 72%);
      aspect-ratio: 3 / 2;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.28));
    }
    .bubbleWrap img.bubble{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:contain;
      user-select:none;
      -webkit-user-drag:none;
    }
    .bubbleFood{
      position:absolute;
      left:50%;
      top:49%;
      transform:translate(-50%, -50%);
      width:38%;
      height:auto;
      user-select:none;
      -webkit-user-drag:none;
      pointer-events:none;
    }

    .beltLane{
      position:absolute;
      left:0;
      width:100%;
      height:1px;
      top: var(--beltY);
      pointer-events:none;
      z-index:20;
      opacity:0;
    }

    .food{
      position:absolute;
      top:0;
      transform: translate(-50%, -100%);
      width: 150px;
      height:auto;
      touch-action:none;
      user-select:none;
      -webkit-user-drag:none;
      z-index:25;
      filter: drop-shadow(0 8px 10px rgba(0,0,0,.22));
    }
    .food.dragging{
      z-index:60;
      filter: drop-shadow(0 14px 18px rgba(0,0,0,.30));
    }

    .dropZone{
      position:absolute;
      left:50%;
      top: 58.5%;
      transform:translate(-50%, -50%);
      width: 240px;
      height: 150px;
      border-radius:22px;
      pointer-events:none;
      z-index:26;
    }

    .toast{
      margin-top:12px;
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:18px;
      padding:14px 16px;
      color:var(--muted);
      line-height:1.35;
    }

    .rowBtns{
      display:flex;
      gap:10px;
      margin-top:12px;
    }
    .ghost{
      flex:1;
      background:transparent;
      border:1px solid rgba(255,255,255,.16);
      color:rgba(255,255,255,.88);
      border-radius:18px;
      padding:12px 14px;
      font-weight:800;
      cursor:pointer;
      text-align:center;
      min-height:46px;
    }
    .ghost:active{ transform: translateY(1px); }
    a.ghost{ text-decoration:none; display:inline-flex; align-items:center; justify-content:center; }

    .ghostPrimary{
      background: var(--accent);
      color:#231400;
      border:0;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      font-weight:950;
    }

    .banner{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%, -50%);
      z-index:80;
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.18);
      padding:14px 16px;
      border-radius:18px;
      font-weight:900;
      letter-spacing:.08em;
      text-transform:uppercase;
      display:none;
    }
    .banner.show{ display:block; }

    .tapStart{
      position:absolute; inset:0;
      z-index:90;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      background:
        radial-gradient(900px 760px at 50% 35%, rgba(0,0,0,.18), rgba(0,0,0,.40) 70%),
        rgba(0,0,0,.22);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }
    .tapStart.hidden{ display:none; }

    .tapCard{
      max-width: 380px;
      width: min(380px, 92%);
      background: rgba(0,0,0,.46);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 22px;
      padding: 16px 16px 14px;
      text-align:center;
      box-shadow: 0 14px 34px rgba(0,0,0,.35);
    }
    .tapCard .big{
      font-weight: 950;
      letter-spacing:.08em;
      text-transform: uppercase;
      margin-bottom: 8px;
    }
    .tapCard .small{
      color: rgba(255,255,255,.82);
      line-height: 1.35;
      font-size: 14px;
      margin-bottom: 12px;
    }
    .tapCard .tapBtn{
      width:100%;
      border:0;
      background: var(--accent);
      color:#231400;
      font-weight: 950;
      border-radius: 16px;
      padding: 12px 14px;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .tapCard .tapBtn:active{ transform: translateY(1px); }

    @media (max-width:520px){
      .stats{ grid-template-columns: 1fr; }
      .stage{ aspect-ratio: 9/12; }
      .food{ width: 140px; }
      .dropZone{ width: 230px; height: 140px; }
      .targetCluster{ top: 8%; }
      :root{ --beltY: 88.8%; }
      .rowBtns{ flex-direction:column; }
      .ghost{ width:100%; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="titleBox">
        <div class="titleLine">$PHAT — Conveyor Munch</div>
        <div class="subLine">Drag the correct snack into his mouth. <strong>Missed meals kill gains.</strong></div>
      </div>
    </div>

    <div class="stats">
      <div class="stat">
        <h4>RUN</h4>
        <div class="big" id="runScore">0</div>
        <div class="sub" id="runSub">Streak: 0 · Belt: 1.00x · Cals: 0</div>
      </div>
      <div class="stat">
        <h4>BEST</h4>
        <div class="big" id="bestScore">0</div>
        <div class="sub" id="bestSub">Daily best: 0</div>
      </div>
      <div class="stat">
        <h4>DAILY GOAL</h4>
        <div class="big" id="goalScore">0 / 30</div>
        <div class="sub" id="goalSub">Today cals: <span id="todayCals">0</span> / <span id="cap">1000</span> · Resets in <span id="resetIn">--:--:--</span></div>
      </div>
    </div>

    <div class="panel">
      <div class="stage" id="stage">
        <div class="scene">
          <video
            id="snackLoop"
            muted
            loop
            playsinline
            preload="auto"
            webkit-playsinline
          >
            <source src="/assets/snack-loop.mp4?v=7" type="video/mp4" />
          </video>
        </div>

        <div class="targetCluster">
          <div class="targetLabel" id="targetText">—</div>
          <div class="bubbleWrap">
            <img class="bubble" src="/assets/thought-bubble.png" alt="thought bubble" />
            <img class="bubbleFood" id="bubbleFood" src="" alt="target food"/>
          </div>
        </div>

        <div class="beltLane" id="beltLane"></div>
        <div class="dropZone" id="dropZone"></div>
        <div class="banner" id="banner">MISSED</div>

        <div class="tapStart" id="tapStart">
          <div class="tapCard">
            <div class="big">FIRE UP THE BELT</div>
            <div class="small">Tap once to clock in. Then feed the beast before it rolls away.</div>
            <button class="tapBtn" id="tapBtn">Start Round</button>
          </div>
        </div>
      </div>

      <div class="rowBtns">
        <button class="ghost ghostPrimary" id="resetBtn">Run it back</button>
        <button class="ghost" id="shareBtn">Share score</button>
        <a class="ghost" id="backBtn" href="/">Back to Planet Fatness</a>
      </div>

      <div class="toast">
        <strong>How it plays:</strong> The thought bubble shows what he wants. The belt feeds a nonstop stream of snacks.
        Grab the correct one between the wrong choices and drag it to his mouth before it rolls away.
        <br><br>
        <strong>Fair calories:</strong> You earn calories for correct munches, but it <em>diminishes</em> the longer you keep going — and the daily cap keeps it honest.
      </div>
    </div>
  </div>

<script>
(() => {
  const FOODS = [
    { key:'brownies',      name:'Brownies',         src:'/assets/food_brownies.png' },
    { key:'burger',        name:'Burger',           src:'/assets/food_burger.png' },
    { key:'cake',          name:'Cake',             src:'/assets/food_cake.png' },
    { key:'takeout',       name:'Takeout',          src:'/assets/food_chinese_takeout.png' },
    { key:'pizookie',      name:'Pizookie',         src:'/assets/food_cookie_pizza.png' },
    { key:'donut_stack',   name:'Donut Stack',      src:'/assets/food_donut_stack.png' },
    { key:'fried_chicken', name:'Fried Chicken',    src:'/assets/food_fried_chicken.png' },
    { key:'fries',         name:'Fries',            src:'/assets/food_fries.png' },
    { key:'grilledcheese', name:'Grilled Cheese',   src:'/assets/food_grilledcheese.png' },
    { key:'hotdogs',       name:'Hot Dogs',         src:'/assets/food_hotdogs.png' },
    { key:'icecream',      name:'Ice Cream',        src:'/assets/food_icecream_cone.png' },
    { key:'shake_choc',    name:'Chocolate Shake',  src:'/assets/food_milkshake_chocolate.png' },
    { key:'shake_straw',   name:'Strawberry Shake', src:'/assets/food_milkshake_strawberry.png' },
    { key:'shake_van',     name:'Vanilla Shake',    src:'/assets/food_milkshake_vanilla.png' },
    { key:'onion_rings',   name:'Onion Rings',      src:'/assets/food_onion_rings.png' },
    { key:'pancakes',      name:'Pancakes',         src:'/assets/food_pancakes.png' },
    { key:'pizza_stack',   name:'Pizza',            src:'/assets/food_pizza_stack.png' },
    { key:'popcorn',       name:'Popcorn',          src:'/assets/food_popcorn.png' },
    { key:'soda',          name:'Soda',             src:'/assets/food_soda.png' },
    { key:'sub',           name:'Sub',              src:'/assets/food_sub.png' },
  ];

  // =========================
  // PHASE 2 BACKEND WIRING
  // =========================
  const API_BASE =
    (window.PF_API_BASE) ||
    localStorage.getItem('phat_api_base') ||
    "https://YOUR-RENDER-BACKEND.onrender.com";

  const TOKEN_KEY = "phat_token";

  const getToken = () => localStorage.getItem(TOKEN_KEY) || "";
  const api = (path) => `${String(API_BASE || "").replace(/\/$/,'')}${path}`;

  async function fetchDailyProgress(){
    const token = getToken();
    if (!token) return null;

    try{
      const r = await fetch(api("/daily/progress"), {
        headers: { "Authorization": `Bearer ${token}` }
      });
      const j = await r.json();
      if (j && j.games && j.games.snack) return j;
      return null;
    } catch {
      return null;
    }
  }

  async function submitSecureSnack({ score, durationMs }){
    const token = getToken();
    if (!token) return null;

    try{
      const r = await fetch(api("/activity/submit"), {
        method: "POST",
        headers: {
          "Content-Type":"application/json",
          "Authorization": `Bearer ${token}`
        },
        body: JSON.stringify({
          game: "snack",
          score: Number(score || 0),
          durationMs: Math.max(0, Math.floor(Number(durationMs || 0)))
        })
      });
      const j = await r.json();
      if (j && j.ok) return j;
      return null;
    } catch {
      return null;
    }
  }

  // ===== DAILY CAP (LOCAL FALLBACK; SERVER OVERRIDES IF LOGGED IN) =====
  let DAILY_CAP = 1000; // fallback only
  const KEY_RESET = "phat_reset";
  const KEY_TODAY = "phat_today";

  function nextMidnight(){
    const d=new Date();
    return new Date(d.getFullYear(), d.getMonth(), d.getDate()+1).getTime();
  }

  let resetAt = Number(localStorage.getItem(KEY_RESET) || nextMidnight());
  let today = Number(localStorage.getItem(KEY_TODAY) || 0);
  if (Date.now() > resetAt){
    today = 0;
    resetAt = nextMidnight();
    localStorage.setItem(KEY_RESET, resetAt);
    localStorage.setItem(KEY_TODAY, today);
  }

  // ===== FAIR CALORIE FORMULA (SNACK) =====
  // (kept for in-run feedback; server is final authority at end)
  function caloriesForCorrect(correctIndex, speedMult){
    let base;
    if (correctIndex <= 10) base = 6;
    else if (correctIndex <= 25) base = 3;
    else base = 2;

    const bonus = 1 + Math.min(0.22, Math.max(0, (speedMult - 1) * 0.18));
    return Math.round(base * bonus);
  }

  const ROUND_CAP = 160;

  const stage      = document.getElementById('stage');
  const beltLane   = document.getElementById('beltLane');
  const dropZoneEl = document.getElementById('dropZone');
  const banner     = document.getElementById('banner');

  const targetText = document.getElementById('targetText');
  const bubbleFood = document.getElementById('bubbleFood');

  const runScoreEl = document.getElementById('runScore');
  const runSubEl   = document.getElementById('runSub');
  const bestEl     = document.getElementById('bestScore');
  const bestSubEl  = document.getElementById('bestSub');
  const goalEl     = document.getElementById('goalScore');

  const todayCalsEl = document.getElementById('todayCals');
  const capEl = document.getElementById('cap');

  const resetBtn = document.getElementById('resetBtn');
  const shareBtn = document.getElementById('shareBtn');
  const resetInEl = document.getElementById('resetIn');

  const v = document.getElementById('snackLoop');
  const tapStart = document.getElementById('tapStart');
  const tapBtn = document.getElementById('tapBtn');

  // goal (default 30, server can override)
  let goalTarget = 30;

  capEl.textContent = DAILY_CAP;
  todayCalsEl.textContent = today;

  let unlocked = false;

  let foodsOnBelt = [];
  let nextId = 1;

  let running = false;
  let streak = 0;
  let score = 0;
  let speedMult = 1.00;

  // calories (local preview + server reconcile at end)
  let runCals = 0;

  // duration
  let roundStartAt = 0;

  let speedFlashUntil = 0;

  const baseSpeed = 160;
  const speedStep = 0.045;
  const speedCap  = 2.25;

  const targetFlowCount = 10;
  const maxOnScreen = 14;
  const minGap = 135;
  const spawnEveryMs = 260;
  let acc = 0;

  const targetMustAppearWithinMs = 6000;
  let targetSetAt = 0;

  let activeDrag = null;
  let lastPointerId = null;

  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
  function stageRect(){ return stage.getBoundingClientRect(); }
  function laneY(){
    const s = stageRect();
    const r = beltLane.getBoundingClientRect();
    return (r.top - s.top);
  }

  function freezeLoop(){
    if (!v) return;
    try { v.pause(); } catch {}
    try { v.currentTime = 0; } catch {}
  }

  async function playLoop(){
    if (!v) return;
    try { v.currentTime = 0; } catch {}
    try {
      const p = v.play();
      if (p && typeof p.then === 'function') await p;
    } catch {}
  }

  const todayKey = () => {
    const d = new Date();
    return `phat_snack_best_${d.getFullYear()}_${d.getMonth()+1}_${d.getDate()}`;
  };
  const loadBest = () => +localStorage.getItem(todayKey()) || 0;
  const saveBest = (v) => localStorage.setItem(todayKey(), String(v));
  let best = loadBest();
  bestEl.textContent = best;
  bestSubEl.textContent = `Daily best: ${best}`;

  function updateHUD(){
    runScoreEl.textContent = score;
    const now = performance.now();
    runSubEl.textContent = `Streak: ${streak} · Belt: ${speedMult.toFixed(2)}x · Cals: ${runCals}`;
    runSubEl.style.color = (now < speedFlashUntil) ? 'var(--accent)' : 'var(--muted)';
    goalEl.textContent = `${Math.min(score, goalTarget)} / ${goalTarget}`;
    todayCalsEl.textContent = today;
    capEl.textContent = DAILY_CAP;
  }

  function setBanner(text, cssColor){
    banner.textContent = text;
    banner.style.color = cssColor || '#fff';
    banner.classList.add('show');
    setTimeout(() => banner.classList.remove('show'), 800);
  }

  function pickTarget(){
    const def = FOODS[Math.floor(Math.random()*FOODS.length)];
    targetText.textContent = def.name.toUpperCase();
    bubbleFood.src = def.src;
    targetSetAt = performance.now();
    return def;
  }

  let currentTarget = pickTarget();

  function canSpawnAt(x){
    for (const f of foodsOnBelt){
      if (!f.active) continue;
      if (Math.abs(f.x - x) < minGap) return false;
    }
    return true;
  }

  function spawnFood(forceTarget=false){
    if (!running) return false;
    if (foodsOnBelt.length >= maxOnScreen) return false;

    const s = stageRect();
    const y = laneY();

    let def;
    if (forceTarget){
      def = currentTarget;
    } else {
      const roll = Math.random();
      if (roll < 0.24) def = currentTarget;
      else {
        do { def = FOODS[Math.floor(Math.random()*FOODS.length)]; }
        while(def.key === currentTarget.key && Math.random() < 0.75);
      }
    }

    let x = null;
    for (let tries=0; tries<6; tries++){
      const candidate = s.width + 140 + Math.random()*120;
      if (canSpawnAt(candidate)){
        x = candidate;
        break;
      }
    }
    if (x === null) return false;

    const el = document.createElement('img');
    el.className = 'food';
    el.src = def.src;
    el.alt = def.name;
    el.draggable = false;
    el.style.left = `${x}px`;
    el.style.top  = `${y}px`;

    const id = nextId++;
    el.addEventListener('pointerdown', (e) => onPointerDown(e, id));

    stage.appendChild(el);
    foodsOnBelt.push({ id, def, el, x, prevX: x, active: true });
    return true;
  }

  function fillBelt(){
    if (!running) return;
    const activeCount = foodsOnBelt.filter(f => f.active).length;
    const need = Math.max(0, targetFlowCount - activeCount);
    if (need === 0) return;

    let spawned = 0;
    let attempts = 0;
    const maxAttempts = 22;

    while (spawned < need && attempts < maxAttempts){
      attempts++;
      if (spawnFood(false)) spawned++;
    }
  }

  function ensureTargetSoon(){
    const now = performance.now();
    if ((now - targetSetAt) > targetMustAppearWithinMs){
      for (let i=0;i<6;i++){
        if (spawnFood(true)) break;
      }
      targetSetAt = now;
    }
  }

  function removeFood(food){
    food.active = false;
    try { food.el.remove(); } catch {}
    foodsOnBelt = foodsOnBelt.filter(f => f.id !== food.id);
  }

  async function syncFromServerIfLoggedIn(){
    const prog = await fetchDailyProgress();
    if (!prog) return;

    const g = prog.games.snack;
    if (g?.caps?.dailyCapCalories != null) DAILY_CAP = Number(g.caps.dailyCapCalories || DAILY_CAP);
    if (g?.today?.calories != null) today = Number(g.today.calories || 0);
    if (g?.goal?.goal != null) goalTarget = Number(g.goal.goal || goalTarget);

    localStorage.setItem(KEY_RESET, resetAt);
    localStorage.setItem(KEY_TODAY, today);
    updateHUD();
  }

  async function endRound(reasonText){
    if (!running) return;
    running = false;
    freezeLoop();

    const dur = Math.max(0, Math.floor(performance.now() - roundStartAt));

    // persist local fallback (server will override if logged in)
    localStorage.setItem(KEY_RESET, resetAt);
    localStorage.setItem(KEY_TODAY, today);

    if (reasonText) setBanner(reasonText, getComputedStyle(document.documentElement).getPropertyValue('--bad'));

    // ✅ PHASE 2: secure submit (server computes + caps)
    // If not logged in, nothing breaks (local-only run).
    const res = await submitSecureSnack({ score, durationMs: dur });

    if (res && res.ok){
      // server is truth
      const earned = Number(res.earnedCalories || 0);
      runCals = earned;

      // update today's calories + cap from server response
      if (res.today && typeof res.today.calories === "number") today = Number(res.today.calories || 0);
      if (res.caps && typeof res.caps.dailyCapCalories === "number") DAILY_CAP = Number(res.caps.dailyCapCalories || DAILY_CAP);
      if (res.goal && typeof res.goal.goal === "number") goalTarget = Number(res.goal.goal || goalTarget);

      updateHUD();

      if (earned > 0){
        setBanner(`+${earned} CALS`, 'var(--good)');
      } else {
        // keep it subtle—still feels like a real system
        if (res.reason === "too_short") setBanner('TOO SHORT', 'var(--accent)');
        else if (res.reason === "score_too_high") setBanner('TOO FAST', 'var(--accent)');
        else setBanner('NO CALS', 'var(--accent)');
      }
    }

    activeDrag = null;
    lastPointerId = null;
  }

  function gameOver(){
    endRound('MISSED');
  }

  function winCorrect(food){
    const s = stageRect();
    const z = dropZoneEl.getBoundingClientRect();
    const targetX = (z.left - s.left) + (z.width/2);
    const targetY = (z.top  - s.top ) + (z.height/2);

    food.el.style.transition = 'left 140ms ease, top 140ms ease, transform 140ms ease, opacity 140ms ease';
    food.el.style.left = `${targetX}px`;
    food.el.style.top  = `${targetY}px`;
    food.el.style.transform = 'translate(-50%, -50%) scale(.65)';
    food.el.style.opacity = '0.25';
    setTimeout(() => removeFood(food), 160);

    score += 1;
    streak += 1;

    const prevSpeed = speedMult;
    speedMult = clamp(speedMult + speedStep, 1.00, speedCap);

    // ===== in-run calories (preview only; server final at end) =====
    // still respects local caps so UI doesn't show insane numbers
    if (today < DAILY_CAP && runCals < ROUND_CAP){
      const add = caloriesForCorrect(score, speedMult);
      const roomDaily = DAILY_CAP - today;
      const roomRound = ROUND_CAP - runCals;
      const actualAdd = Math.max(0, Math.min(add, roomDaily, roomRound));
      runCals += actualAdd;
      today += actualAdd;

      // keep it lightweight
      if (actualAdd > 0 && (score % 5 === 0)){
        setBanner(`+${actualAdd} CALS`, 'var(--good)');
      }
    }

    speedFlashUntil = performance.now() + 800;
    if (speedMult > prevSpeed + 0.0001){
      setBanner(`BELT +${(speedMult - prevSpeed).toFixed(2)}x`, 'var(--accent)');
    }

    currentTarget = pickTarget();

    if (score > best){
      best = score;
      bestEl.textContent = best;
      bestSubEl.textContent = `Daily best: ${best}`;
      saveBest(best);
    }

    updateHUD();
    fillBelt();
    ensureTargetSoon();
  }

  function onPointerDown(e, id){
    if (!running) return;
    const food = foodsOnBelt.find(f => f.id === id);
    if (!food || !food.active) return;

    lastPointerId = e.pointerId;
    food.el.classList.add('dragging');

    const s = stageRect();
    const r = food.el.getBoundingClientRect();
    const offsetX = (e.clientX - r.left) - r.width/2;
    const offsetY = (e.clientY - r.top ) - r.height/2;

    activeDrag = { food, offsetX, offsetY };
    food.el.setPointerCapture(e.pointerId);
    e.preventDefault();
  }

  function onPointerMove(e){
    if (!activeDrag || e.pointerId !== lastPointerId) return;
    const { food, offsetX, offsetY } = activeDrag;
    if (!food.active) return;
    const s = stageRect();

    const x = (e.clientX - s.left) - offsetX;
    const y = (e.clientY - s.top ) - offsetY;

    food.el.style.transition = 'none';
    food.el.style.left = `${x}px`;
    food.el.style.top = `${y}px`;
    food.el.style.transform = 'translate(-50%, -50%)';
  }

  function onPointerUp(e){
    if (!activeDrag || e.pointerId !== lastPointerId) return;

    const { food } = activeDrag;
    activeDrag = null;
    lastPointerId = null;

    if (!food.active) return;

    food.el.classList.remove('dragging');

    const fRect = food.el.getBoundingClientRect();
    const zRect = dropZoneEl.getBoundingClientRect();
    const fCx = fRect.left + fRect.width/2;
    const fCy = fRect.top  + fRect.height/2;

    const inZone = (fCx >= zRect.left && fCx <= zRect.right && fCy >= zRect.top && fCy <= zRect.bottom);

    if (!inZone){
      const y = laneY();
      food.el.style.transition = 'top 120ms ease, transform 120ms ease';
      food.el.style.top = `${y}px`;
      food.el.style.transform = 'translate(-50%, -100%)';
      return;
    }

    if (food.def.key !== currentTarget.key){
      gameOver();
      return;
    }

    winCorrect(food);
  }

  stage.addEventListener('pointermove', onPointerMove);
  stage.addEventListener('pointerup', onPointerUp);
  stage.addEventListener('pointercancel', onPointerUp);

  const OFFSCREEN_X = -180;

  let lastT = performance.now();
  function loop(now){
    const rawDt = (now - lastT) / 1000;
    const dt = Math.min(rawDt, 0.033);
    lastT = now;

    if (running){
      const y = laneY();
      const beltDx = (baseSpeed * speedMult) * dt;

      for (const f of foodsOnBelt){
        if (!f.active) continue;
        if (!Number.isFinite(f.x)) { removeFood(f); continue; }

        f.prevX = f.x;
        f.x -= beltDx;

        if (activeDrag && activeDrag.food.id === f.id){
          const curLeft = parseFloat(f.el.style.left) || f.x;
          f.el.style.left = `${curLeft - beltDx}px`;
        } else {
          f.el.style.left = `${f.x}px`;
          f.el.style.top  = `${y}px`;
          f.el.style.transform = 'translate(-50%, -100%)';
        }
      }

      for (const f of [...foodsOnBelt]){
        if (!f.active) continue;
        const crossed = (Number.isFinite(f.prevX) ? (f.prevX >= OFFSCREEN_X && f.x < OFFSCREEN_X) : (f.x < OFFSCREEN_X));
        if (crossed){
          if (f.def.key === currentTarget.key){
            gameOver();
            break;
          } else {
            removeFood(f);
          }
        }
      }

      acc += dt * 1000;
      fillBelt();
      ensureTargetSoon();

      if (acc >= spawnEveryMs){
        acc = 0;
        spawnFood(false);
      }
    }

    requestAnimationFrame(loop);
  }

  function resetRoundState(){
    streak = 0;
    score = 0;
    speedMult = 1.00;
    speedFlashUntil = 0;

    runCals = 0;
    roundStartAt = performance.now();

    currentTarget = pickTarget();
    updateHUD();

    for (const f of [...foodsOnBelt]) removeFood(f);
    for (let i=0;i<8;i++) spawnFood(i===2);
    fillBelt();
    ensureTargetSoon();
  }

  async function startRoundFromGesture(){
    unlocked = true;
    tapStart.classList.add('hidden');

    // pull server caps/today/goal if logged in (doesn't block play)
    syncFromServerIfLoggedIn();

    running = true;
    await playLoop();     // must be inside gesture on iOS
    resetRoundState();
  }

  function runItBack(){
    if (!unlocked){
      tapStart.classList.remove('hidden');
      return;
    }

    // refresh server totals if logged in
    syncFromServerIfLoggedIn();

    running = true;
    playLoop();
    resetRoundState();
  }

  function share(){
    const txt =
      `$PHAT Conveyor Munch — ${score} correct · streak ${streak} · belt ${speedMult.toFixed(2)}x · cals ${runCals}\n` +
      `Today: ${today}/${DAILY_CAP}\n` +
      `planetfatness.fit/snack`;
    if (navigator.share){
      navigator.share({ text: txt }).catch(()=>{});
    } else {
      navigator.clipboard?.writeText(txt);
      setBanner('COPIED', '#fff');
    }
  }

  function timeToMidnight(){
    const n = new Date();
    const m = new Date(n);
    m.setHours(24,0,0,0);
    return m - n;
  }
  function fmt(ms){
    ms = Math.max(0, ms);
    const s = Math.floor(ms/1000);
    const hh = String(Math.floor(s/3600)).padStart(2,'0');
    const mm = String(Math.floor((s%3600)/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return `${hh}:${mm}:${ss}`;
  }
  setInterval(() => resetInEl.textContent = fmt(timeToMidnight()), 250);

  resetBtn.addEventListener('click', runItBack);
  shareBtn.addEventListener('click', share);

  tapBtn.addEventListener('click', startRoundFromGesture);
  tapStart.addEventListener('click', startRoundFromGesture);

  if (v){
    v.addEventListener('loadedmetadata', () => freezeLoop());
  }

  updateHUD();
  pickTarget();
  requestAnimationFrame(loop);

  // one quiet sync on load (if logged in)
  syncFromServerIfLoggedIn();
})();
</script>

</body>
</html>