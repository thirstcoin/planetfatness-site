<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>$PHAT ‚Äî Conveyor Munch</title>

  <style>
    :root{
      --bg1:#2a1442; --bg2:#140a22;
      --card:rgba(255,255,255,.06);
      --stroke:rgba(255,255,255,.10);
      --txt:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.70);
      --accent:#ffd44d;
      --good:#6dffb3;
      --bad:#ff6d8a;

      --mp4-top:#6f3cff;
      --mp4-mid:#6a36ff;
      --mp4-bot:#6431ff;

      /* Ride height knob */
      --beltY: 88.4%;

      /* Head safe: no crop */
      --videoFit: contain;
      --videoPosY: 100%;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--txt);
      background:
        radial-gradient(1000px 700px at 50% 10%, rgba(255,255,255,.08), transparent 60%),
        radial-gradient(900px 700px at 50% 60%, rgba(255,255,255,.05), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      min-height:100vh;
      display:flex;
      justify-content:center;
    }
    .wrap{ width:min(980px, 94vw); padding:18px 0 28px; }

    .topbar{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      margin-bottom:12px;
    }
    .titleBox{
      flex:1;
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:20px;
      padding:14px 16px;
      backdrop-filter: blur(10px);
    }
    .titleLine{ font-weight:800; letter-spacing:.3px; font-size:18px; opacity:.95; margin-bottom:6px; }
    .subLine{ color:var(--muted); font-size:14px; line-height:1.3; }

    .btn{
      border:0;
      background:var(--accent);
      color:#231400;
      font-weight:900;
      padding:12px 14px;
      border-radius:16px;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      cursor:pointer;
      white-space:nowrap;
    }
    .btn:active{ transform: translateY(1px); }

    .stats{
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap:10px;
      margin-bottom:12px;
    }
    .stat{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:18px;
      padding:14px 14px 12px;
      backdrop-filter: blur(10px);
      min-height:72px;
    }
    .stat h4{ margin:0 0 6px; font-size:12px; letter-spacing:.22em; opacity:.75; }
    .stat .big{ font-size:34px; font-weight:900; line-height:1; }
    .stat .sub{ margin-top:6px; color:var(--muted); font-size:13px; }

    .panel{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:22px;
      padding:14px;
      backdrop-filter: blur(10px);
    }

    .stage{
      position:relative;
      width:100%;
      aspect-ratio: 9/11;
      max-height: 820px;
      border-radius:22px;
      overflow:hidden;
      background:
        radial-gradient(700px 520px at 50% 18%, rgba(255,255,255,.12), transparent 55%),
        linear-gradient(180deg, var(--mp4-top) 0%, var(--mp4-mid) 45%, var(--mp4-bot) 100%);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
    }

    /* (2) POLISH: extra vignette/gloss so the box looks ‚Äúpremium‚Äù */
    .stage::before{
      content:"";
      position:absolute; inset:0;
      pointer-events:none;
      z-index:11;
      background:
        radial-gradient(120% 92% at 50% 18%, rgba(255,255,255,.10), rgba(255,255,255,0) 42%),
        radial-gradient(120% 120% at 50% 60%, rgba(0,0,0,0), rgba(0,0,0,.22) 70%);
      opacity:.75;
    }
    .stage::after{
      content:"";
      position:absolute; inset:0;
      pointer-events:none;
      z-index:12;
      background:
        linear-gradient(180deg, rgba(0,0,0,.10), rgba(0,0,0,0) 35%, rgba(0,0,0,.12)),
        radial-gradient(900px 760px at 50% 30%, rgba(0,0,0,0), rgba(0,0,0,.16) 70%);
      mix-blend-mode: multiply;
    }

    .scene{
      position:absolute; inset:0;
      pointer-events:none;
      z-index:10;
    }

    /* (4) POLISH: crossfade static‚Üîvideo (static is your stage gradient) */
    .scene video{
      width:100%;
      height:100%;
      object-fit: var(--videoFit);
      object-position: 50% var(--videoPosY);
      display:block;
      background: transparent;

      opacity: 0;
      transition: opacity 220ms ease;
      will-change: opacity;
    }
    .scene video.playing{ opacity: 1; }

    .targetCluster{
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      top: 10%;
      width:min(520px, 92%);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
      pointer-events:none;
      z-index:30;
    }
    .targetLabel{
      background:rgba(0,0,0,.40);
      border:1px solid rgba(255,255,255,.16);
      border-radius:999px;
      padding:10px 16px;
      font-weight:900;
      letter-spacing:.18em;
      text-indent:.18em;
      text-transform:uppercase;
      max-width:92%;
      overflow:hidden;
      white-space:nowrap;
      text-overflow:ellipsis;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .bubbleWrap{
      position:relative;
      width:min(360px, 72%);
      aspect-ratio: 3 / 2;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.28));
    }
    .bubbleWrap img.bubble{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:contain;
      user-select:none;
      -webkit-user-drag:none;
    }
    .bubbleFood{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%, -50%);
      width:32%;
      height:auto;
      user-select:none;
      -webkit-user-drag:none;
      pointer-events:none;
    }

    .beltLane{
      position:absolute;
      left:0;
      width:100%;
      height:1px;
      top: var(--beltY);
      pointer-events:none;
      z-index:20;
      opacity:0;
    }

    /* (3) POLISH: food shadow tuned down + add ‚Äúcontact shadow‚Äù element */
    .food{
      position:absolute;
      top:0;
      transform: translate(-50%, -100%);
      width: 150px;
      height:auto;
      touch-action:none;
      user-select:none;
      -webkit-user-drag:none;
      z-index:25;

      /* reduced float shadow */
      filter: drop-shadow(0 6px 7px rgba(0,0,0,.20));
    }
    .food.dragging{
      z-index:60;
      filter: drop-shadow(0 14px 14px rgba(0,0,0,.34));
    }

    /* contact shadow that ‚Äúpins‚Äù snack to the belt */
    .foodShadow{
      position:absolute;
      width: 72px;
      height: 16px;
      transform: translate(-50%, -50%);
      border-radius: 999px;
      background: rgba(0,0,0,.34);
      filter: blur(7px);
      opacity: .62;
      z-index:24;
      pointer-events:none;
    }
    .foodShadow.dragging{
      opacity:.35;
      filter: blur(10px);
    }

    .dropZone{
      position:absolute;
      left:50%;
      top: 58.5%;
      transform:translate(-50%, -50%);
      width: 240px;
      height: 150px;
      border-radius:22px;
      pointer-events:none;
      z-index:26;
    }

    .toast{
      margin-top:12px;
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:18px;
      padding:14px 16px;
      color:var(--muted);
      line-height:1.35;
    }
    .rowBtns{ display:flex; gap:10px; margin-top:12px; }
    .ghost{
      flex:1;
      background:transparent;
      border:1px solid rgba(255,255,255,.16);
      color:rgba(255,255,255,.88);
      border-radius:18px;
      padding:12px 14px;
      font-weight:800;
      cursor:pointer;
      text-align:center;
    }
    .ghost:active{ transform: translateY(1px); }
    a.ghost{ text-decoration:none; display:inline-flex; align-items:center; justify-content:center; }

    .banner{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%, -50%);
      z-index:80;
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.18);
      padding:14px 16px;
      border-radius:18px;
      font-weight:900;
      letter-spacing:.08em;
      text-transform:uppercase;
      display:none;
    }
    .banner.show{ display:block; }

    /* ‚úÖ one-time tap to unlock video play on iOS (copy rewritten to be in-lore) */
    .tapStart{
      position:absolute; inset:0;
      z-index:90;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      background:
        radial-gradient(900px 720px at 50% 30%, rgba(0,0,0,.08), rgba(0,0,0,.34)),
        rgba(0,0,0,.15);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .tapStart.hidden{ display:none; }
    .tapCard{
      max-width: 360px;
      width: min(360px, 92%);
      background: rgba(12,8,22,.52);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 20px;
      padding: 16px 16px 14px;
      text-align:center;
      box-shadow: 0 14px 34px rgba(0,0,0,.35);
    }
    .tapCard .big{
      font-weight: 950;
      letter-spacing:.10em;
      text-transform: uppercase;
      margin-bottom: 8px;
    }
    .tapCard .small{
      color: rgba(255,255,255,.80);
      line-height: 1.35;
      font-size: 14px;
      margin-bottom: 12px;
    }
    .tapCard .tapBtn{
      width:100%;
      border:0;
      background: var(--accent);
      color:#231400;
      font-weight: 950;
      border-radius: 16px;
      padding: 12px 14px;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .tapCard .tapBtn:active{ transform: translateY(1px); }

    @media (max-width:520px){
      .stats{ grid-template-columns: 1fr; }
      .stage{ aspect-ratio: 9/12; }
      .food{ width: 140px; }
      .dropZone{ width: 230px; height: 140px; }
      .targetCluster{ top: 8%; }
      :root{ --beltY: 88.8%; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="titleBox">
        <div class="titleLine">$PHAT ‚Äî Conveyor Munch</div>
        <div class="subLine">Drag the correct snack into his mouth. <strong>Missed meals kill gains.</strong></div>
      </div>
      <button class="btn" id="resetBtn">Run it back</button>
    </div>

    <div class="stats">
      <div class="stat">
        <h4>RUN</h4>
        <div class="big" id="runScore">0</div>
        <div class="sub" id="runSub">Streak: 0 ¬∑ Speed: 1.00x</div>
      </div>
      <div class="stat">
        <h4>BEST</h4>
        <div class="big" id="bestScore">0</div>
        <div class="sub" id="bestSub">Daily best: 0</div>
      </div>
      <div class="stat">
        <h4>DAILY GOAL</h4>
        <div class="big" id="goalScore">0 / 30</div>
        <div class="sub" id="goalSub">Resets in <span id="resetIn">--:--:--</span></div>
      </div>
    </div>

    <div class="panel">
      <div class="stage" id="stage">
        <div class="scene">
          <video
            id="snackLoop"
            muted
            loop
            playsinline
            preload="auto"
            webkit-playsinline
          >
            <source src="/assets/snack-loop.mp4?v=6" type="video/mp4" />
          </video>
        </div>

        <div class="targetCluster">
          <div class="targetLabel" id="targetText">‚Äî</div>
          <div class="bubbleWrap">
            <img class="bubble" src="../assets/thought-bubble.png" alt="thought bubble" />
            <img class="bubbleFood" id="bubbleFood" src="" alt="target food"/>
          </div>
        </div>

        <div class="beltLane" id="beltLane"></div>
        <div class="dropZone" id="dropZone"></div>
        <div class="banner" id="banner">MISSED</div>

        <!-- ‚úÖ one-time tap to unlock video play on iOS -->
        <div class="tapStart" id="tapStart">
          <div class="tapCard">
            <div class="big">CLOCK IN</div>
            <div class="small">Start the belt and feed the beast. No excuses.</div>
            <button class="tapBtn" id="tapBtn">START SHIFT</button>
          </div>
        </div>
      </div>

      <div class="rowBtns">
        <button class="ghost" id="shareBtn">Share score</button>
        <a class="ghost" id="backBtn" href="/">Back to Planet Fatness</a>
      </div>

      <div class="toast">
        <strong>How it plays:</strong> The thought bubble shows what he wants. The belt feeds a nonstop stream of snacks.
        Grab the correct one between the wrong choices and drag it to his mouth before it rolls away.
        <br><br>
        <strong>Heads up:</strong> Every correct munch makes the belt faster. üî•
      </div>
    </div>
  </div>

<script>
(() => {
  const FOODS = [
    { key:'brownies',      name:'Brownies',         src:'../assets/food_brownies.png' },
    { key:'burger',        name:'Burger',           src:'../assets/food_burger.png' },
    { key:'cake',          name:'Cake',             src:'../assets/food_cake.png' },
    { key:'takeout',       name:'Takeout',          src:'../assets/food_chinese_takeout.png' },
    { key:'pizookie',      name:'Pizookie',         src:'../assets/food_cookie_pizza.png' },
    { key:'donut_stack',   name:'Donut Stack',      src:'../assets/food_donut_stack.png' },
    { key:'fried_chicken', name:'Fried Chicken',    src:'../assets/food_fried_chicken.png' },
    { key:'fries',         name:'Fries',            src:'../assets/food_fries.png' },
    { key:'grilledcheese', name:'Grilled Cheese',   src:'../assets/food_grilledcheese.png' },
    { key:'hotdogs',       name:'Hot Dogs',         src:'../assets/food_hotdogs.png' },
    { key:'icecream',      name:'Ice Cream',        src:'../assets/food_icecream_cone.png' },
    { key:'shake_choc',    name:'Chocolate Shake',  src:'../assets/food_milkshake_chocolate.png' },
    { key:'shake_straw',   name:'Strawberry Shake', src:'../assets/food_milkshake_strawberry.png' },
    { key:'shake_van',     name:'Vanilla Shake',    src:'../assets/food_milkshake_vanilla.png' },
    { key:'onion_rings',   name:'Onion Rings',      src:'../assets/food_onion_rings.png' },
    { key:'pancakes',      name:'Pancakes',         src:'../assets/food_pancakes.png' },
    { key:'pizza_stack',   name:'Pizza',            src:'../assets/food_pizza_stack.png' },
    { key:'popcorn',       name:'Popcorn',          src:'../assets/food_popcorn.png' },
    { key:'soda',          name:'Soda',             src:'../assets/food_soda.png' },
    { key:'sub',           name:'Sub',              src:'../assets/food_sub.png' },
  ];

  const stage      = document.getElementById('stage');
  const beltLane   = document.getElementById('beltLane');
  const dropZoneEl = document.getElementById('dropZone');
  const banner     = document.getElementById('banner');

  const targetText = document.getElementById('targetText');
  const bubbleFood = document.getElementById('bubbleFood');

  const runScoreEl = document.getElementById('runScore');
  const runSubEl   = document.getElementById('runSub');
  const bestEl     = document.getElementById('bestScore');
  const goalEl     = document.getElementById('goalScore');

  const resetBtn = document.getElementById('resetBtn');
  const shareBtn = document.getElementById('shareBtn');
  const resetInEl = document.getElementById('resetIn');

  const v = document.getElementById('snackLoop');
  const tapStart = document.getElementById('tapStart');
  const tapBtn = document.getElementById('tapBtn');

  let unlocked = false;

  // {id, def, el, shadowEl, x, prevX, active}
  let foodsOnBelt = [];
  let nextId = 1;

  let running = false;
  let streak = 0;
  let score = 0;
  let speedMult = 1.00;

  let speedFlashUntil = 0;

  const baseSpeed = 160;
  const speedStep = 0.045;
  const speedCap  = 2.25;

  const targetFlowCount = 10;
  const maxOnScreen = 14;
  const minGap = 135;
  const spawnEveryMs = 260;
  let acc = 0;

  const targetMustAppearWithinMs = 6000;
  let targetSetAt = 0;

  let activeDrag = null;
  let lastPointerId = null;

  const goalTarget = 30;

  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
  function stageRect(){ return stage.getBoundingClientRect(); }
  function laneY(){
    const s = stageRect();
    const r = beltLane.getBoundingClientRect();
    return (r.top - s.top);
  }

  function freezeLoop(){
    if (!v) return;
    try { v.pause(); } catch {}
    try { v.currentTime = 0; } catch {}
    // (4) crossfade back to static
    v.classList.remove('playing');
  }

  async function playLoop(){
    if (!v) return;
    try { v.currentTime = 0; } catch {}
    try {
      const p = v.play();
      if (p && typeof p.then === 'function') await p;
    } catch {}
    // (4) crossfade to video
    v.classList.add('playing');
  }

  const todayKey = () => {
    const d = new Date();
    return `phat_snack_best_${d.getFullYear()}_${d.getMonth()+1}_${d.getDate()}`;
  };
  const loadBest = () => +localStorage.getItem(todayKey()) || 0;
  const saveBest = (v) => localStorage.setItem(todayKey(), String(v));
  let best = loadBest();
  bestEl.textContent = best;

  function updateHUD(){
    runScoreEl.textContent = score;
    const now = performance.now();
    runSubEl.textContent = `Streak: ${streak} ¬∑ Belt: ${speedMult.toFixed(2)}x`;
    runSubEl.style.color = (now < speedFlashUntil) ? 'var(--accent)' : 'var(--muted)';
    goalEl.textContent = `${Math.min(score, goalTarget)} / ${goalTarget}`;
  }

  function setBanner(text, cssColor){
    banner.textContent = text;
    banner.style.color = cssColor || '#fff';
    banner.classList.add('show');
    setTimeout(() => banner.classList.remove('show'), 800);
  }

  function pickTarget(){
    const def = FOODS[Math.floor(Math.random()*FOODS.length)];
    targetText.textContent = def.name.toUpperCase();
    bubbleFood.src = def.src;
    targetSetAt = performance.now();
    return def;
  }

  let currentTarget = pickTarget();

  function canSpawnAt(x){
    for (const f of foodsOnBelt){
      if (!f.active) continue;
      if (Math.abs(f.x - x) < minGap) return false;
    }
    return true;
  }

  function spawnFood(forceTarget=false){
    if (!running) return false;
    if (foodsOnBelt.length >= maxOnScreen) return false;

    const s = stageRect();
    const y = laneY();

    let def;
    if (forceTarget){
      def = currentTarget;
    } else {
      const roll = Math.random();
      if (roll < 0.24) def = currentTarget;
      else {
        do { def = FOODS[Math.floor(Math.random()*FOODS.length)]; }
        while(def.key === currentTarget.key && Math.random() < 0.75);
      }
    }

    let x = null;
    for (let tries=0; tries<6; tries++){
      const candidate = s.width + 140 + Math.random()*120;
      if (canSpawnAt(candidate)){
        x = candidate;
        break;
      }
    }
    if (x === null) return false;

    // (3) contact shadow element
    const shadowEl = document.createElement('div');
    shadowEl.className = 'foodShadow';
    shadowEl.style.left = `${x}px`;
    shadowEl.style.top  = `${y + 8}px`; // sits slightly below snack base

    const el = document.createElement('img');
    el.className = 'food';
    el.src = def.src;
    el.alt = def.name;
    el.draggable = false;
    el.style.left = `${x}px`;
    el.style.top  = `${y}px`;

    const id = nextId++;
    el.addEventListener('pointerdown', (e) => onPointerDown(e, id));

    // order matters: shadow below snack
    stage.appendChild(shadowEl);
    stage.appendChild(el);

    foodsOnBelt.push({ id, def, el, shadowEl, x, prevX: x, active: true });
    return true;
  }

  function fillBelt(){
    if (!running) return;
    const activeCount = foodsOnBelt.filter(f => f.active).length;
    const need = Math.max(0, targetFlowCount - activeCount);
    if (need === 0) return;

    let spawned = 0;
    let attempts = 0;
    const maxAttempts = 22;

    while (spawned < need && attempts < maxAttempts){
      attempts++;
      if (spawnFood(false)) spawned++;
    }
  }

  function ensureTargetSoon(){
    const now = performance.now();
    if ((now - targetSetAt) > targetMustAppearWithinMs){
      for (let i=0;i<6;i++){
        if (spawnFood(true)) break;
      }
      targetSetAt = now;
    }
  }

  function removeFood(food){
    food.active = false;
    try { food.el.remove(); } catch {}
    try { food.shadowEl?.remove(); } catch {}
    foodsOnBelt = foodsOnBelt.filter(f => f.id !== food.id);
  }

  function gameOver(){
    if (!running) return;
    running = false;
    freezeLoop();
    setBanner('MISSED', getComputedStyle(document.documentElement).getPropertyValue('--bad'));
    activeDrag = null;
    lastPointerId = null;
  }

  function winCorrect(food){
    const s = stageRect();
    const z = dropZoneEl.getBoundingClientRect();
    const targetX = (z.left - s.left) + (z.width/2);
    const targetY = (z.top  - s.top ) + (z.height/2);

    // move snack
    food.el.style.transition = 'left 140ms ease, top 140ms ease, transform 140ms ease, opacity 140ms ease';
    food.el.style.left = `${targetX}px`;
    food.el.style.top  = `${targetY}px`;
    food.el.style.transform = 'translate(-50%, -50%) scale(.65)';
    food.el.style.opacity = '0.25';

    // fade shadow quickly
    if (food.shadowEl){
      food.shadowEl.style.transition = 'opacity 120ms ease';
      food.shadowEl.style.opacity = '0';
    }

    setTimeout(() => removeFood(food), 160);

    score += 1;
    streak += 1;

    const prevSpeed = speedMult;
    speedMult = clamp(speedMult + speedStep, 1.00, speedCap);

    speedFlashUntil = performance.now() + 800;
    if (speedMult > prevSpeed + 0.0001){
      setBanner(`BELT +${(speedMult - prevSpeed).toFixed(2)}x`, 'var(--accent)');
    }

    currentTarget = pickTarget();

    if (score > best){
      best = score;
      bestEl.textContent = best;
      saveBest(best);
    }

    updateHUD();
    fillBelt();
    ensureTargetSoon();
  }

  function onPointerDown(e, id){
    if (!running) return;
    const food = foodsOnBelt.find(f => f.id === id);
    if (!food || !food.active) return;

    lastPointerId = e.pointerId;
    food.el.classList.add('dragging');
    food.shadowEl?.classList.add('dragging');

    const s = stageRect();
    const r = food.el.getBoundingClientRect();
    const offsetX = (e.clientX - r.left) - r.width/2;
    const offsetY = (e.clientY - r.top ) - r.height/2;

    activeDrag = { food, offsetX, offsetY };
    food.el.setPointerCapture(e.pointerId);
    e.preventDefault();
  }

  function onPointerMove(e){
    if (!activeDrag || e.pointerId !== lastPointerId) return;
    const { food, offsetX, offsetY } = activeDrag;
    if (!food.active) return;
    const s = stageRect();

    const x = (e.clientX - s.left) - offsetX;
    const y = (e.clientY - s.top ) - offsetY;

    food.el.style.transition = 'none';
    food.el.style.left = `${x}px`;
    food.el.style.top = `${y}px`;
    food.el.style.transform = 'translate(-50%, -50%)';

    // keep contact shadow under snack while dragging (a bit looser)
    if (food.shadowEl){
      food.shadowEl.style.transition = 'none';
      food.shadowEl.style.left = `${x}px`;
      food.shadowEl.style.top = `${y + 58}px`;
    }
  }

  function onPointerUp(e){
    if (!activeDrag || e.pointerId !== lastPointerId) return;

    const { food } = activeDrag;
    activeDrag = null;
    lastPointerId = null;

    if (!food.active) return;

    food.el.classList.remove('dragging');
    food.shadowEl?.classList.remove('dragging');

    const fRect = food.el.getBoundingClientRect();
    const zRect = dropZoneEl.getBoundingClientRect();
    const fCx = fRect.left + fRect.width/2;
    const fCy = fRect.top  + fRect.height/2;

    const inZone = (fCx >= zRect.left && fCx <= zRect.right && fCy >= zRect.top && fCy <= zRect.bottom);

    if (!inZone){
      const y = laneY();
      food.el.style.transition = 'top 120ms ease, transform 120ms ease';
      food.el.style.top = `${y}px`;
      food.el.style.transform = 'translate(-50%, -100%)';

      if (food.shadowEl){
        food.shadowEl.style.transition = 'top 120ms ease, opacity 120ms ease';
        food.shadowEl.style.left = `${parseFloat(food.el.style.left) || food.x}px`;
        food.shadowEl.style.top  = `${y + 8}px`;
        food.shadowEl.style.opacity = '0.62';
      }
      return;
    }

    if (food.def.key !== currentTarget.key){
      gameOver();
      return;
    }

    winCorrect(food);
  }

  stage.addEventListener('pointermove', onPointerMove);
  stage.addEventListener('pointerup', onPointerUp);
  stage.addEventListener('pointercancel', onPointerUp);

  const OFFSCREEN_X = -180;

  let lastT = performance.now();
  function loop(now){
    const rawDt = (now - lastT) / 1000;
    const dt = Math.min(rawDt, 0.033);
    lastT = now;

    if (running){
      const y = laneY();
      const beltDx = (baseSpeed * speedMult) * dt;

      for (const f of foodsOnBelt){
        if (!f.active) continue;
        if (!Number.isFinite(f.x)) { removeFood(f); continue; }

        f.prevX = f.x;
        f.x -= beltDx;

        if (activeDrag && activeDrag.food.id === f.id){
          const curLeft = parseFloat(f.el.style.left) || f.x;
          f.el.style.left = `${curLeft - beltDx}px`;

          if (f.shadowEl){
            const curShadowLeft = parseFloat(f.shadowEl.style.left) || curLeft;
            f.shadowEl.style.left = `${curShadowLeft - beltDx}px`;
          }
        } else {
          f.el.style.left = `${f.x}px`;
          f.el.style.top  = `${y}px`;
          f.el.style.transform = 'translate(-50%, -100%)';

          if (f.shadowEl){
            f.shadowEl.style.left = `${f.x}px`;
            f.shadowEl.style.top  = `${y + 8}px`;
            f.shadowEl.style.opacity = '0.62';
          }
        }
      }

      for (const f of [...foodsOnBelt]){
        if (!f.active) continue;
        const crossed = (Number.isFinite(f.prevX) ? (f.prevX >= OFFSCREEN_X && f.x < OFFSCREEN_X) : (f.x < OFFSCREEN_X));
        if (crossed){
          if (f.def.key === currentTarget.key){
            gameOver();
            break;
          } else {
            removeFood(f);
          }
        }
      }

      acc += dt * 1000;
      fillBelt();
      ensureTargetSoon();

      if (acc >= spawnEveryMs){
        acc = 0;
        spawnFood(false);
      }
    }

    requestAnimationFrame(loop);
  }

  function resetRoundState(){
    streak = 0;
    score = 0;
    speedMult = 1.00;
    speedFlashUntil = 0;
    currentTarget = pickTarget();
    updateHUD();

    for (const f of [...foodsOnBelt]) removeFood(f);
    for (let i=0;i<8;i++) spawnFood(i===2);
    fillBelt();
    ensureTargetSoon();
  }

  async function startRoundFromGesture(){
    unlocked = true;
    tapStart.classList.add('hidden');

    running = true;

    // must be in user gesture for iOS
    await playLoop();

    resetRoundState();
  }

  function runItBack(){
    if (!unlocked){
      tapStart.classList.remove('hidden');
      return;
    }
    running = true;
    playLoop();
    resetRoundState();
  }

  function share(){
    const txt = `$PHAT Conveyor Munch ‚Äî ${score} correct ¬∑ streak ${streak} ¬∑ belt ${speedMult.toFixed(2)}x\nplanetfatness.fit/snack`;
    if (navigator.share){
      navigator.share({ text: txt }).catch(()=>{});
    } else {
      navigator.clipboard?.writeText(txt);
      setBanner('COPIED', '#fff');
    }
  }

  function timeToMidnight(){
    const n = new Date();
    const m = new Date(n);
    m.setHours(24,0,0,0);
    return m - n;
  }
  function fmt(ms){
    ms = Math.max(0, ms);
    const s = Math.floor(ms/1000);
    const hh = String(Math.floor(s/3600)).padStart(2,'0');
    const mm = String(Math.floor((s%3600)/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return `${hh}:${mm}:${ss}`;
  }
  setInterval(() => resetInEl.textContent = fmt(timeToMidnight()), 250);

  resetBtn.addEventListener('click', runItBack);
  shareBtn.addEventListener('click', share);

  // tap overlay button (real user gesture)
  tapBtn.addEventListener('click', startRoundFromGesture);
  tapStart.addEventListener('click', startRoundFromGesture);

  // start STATIC on load (expected on iPhone)
  if (v){
    v.addEventListener('loadedmetadata', () => freezeLoop());
  }

  // initialize HUD + target without starting round
  updateHUD();
  pickTarget();

  requestAnimationFrame(loop);
})();
</script>

</body>
</html>