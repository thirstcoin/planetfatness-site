<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>$PHAT — Conveyor Munch</title>

  <style>
    :root{
      --bg1:#2a1442; --bg2:#140a22;
      --card:rgba(255,255,255,.06);
      --stroke:rgba(255,255,255,.10);
      --txt:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.70);
      --accent:#ffd44d;
      --good:#6dffb3;
      --bad:#ff6d8a;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--txt);
      background:
        radial-gradient(1000px 700px at 50% 10%, rgba(255,255,255,.08), transparent 60%),
        radial-gradient(900px 700px at 50% 60%, rgba(255,255,255,.05), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      min-height:100vh;
      display:flex;
      justify-content:center;
    }
    .wrap{ width:min(980px, 94vw); padding:18px 0 28px; }

    .topbar{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      margin-bottom:12px;
    }
    .titleBox{
      flex:1;
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:20px;
      padding:14px 16px;
      backdrop-filter: blur(10px);
    }
    .titleLine{ font-weight:800; letter-spacing:.3px; font-size:18px; opacity:.95; margin-bottom:6px; }
    .subLine{ color:var(--muted); font-size:14px; line-height:1.3; }

    .btn{
      border:0;
      background:var(--accent);
      color:#231400;
      font-weight:900;
      padding:12px 14px;
      border-radius:16px;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      cursor:pointer;
      white-space:nowrap;
    }
    .btn:active{ transform: translateY(1px); }

    .stats{
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap:10px;
      margin-bottom:12px;
    }
    .stat{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:18px;
      padding:14px 14px 12px;
      backdrop-filter: blur(10px);
      min-height:72px;
    }
    .stat h4{ margin:0 0 6px; font-size:12px; letter-spacing:.22em; opacity:.75; }
    .stat .big{ font-size:34px; font-weight:900; line-height:1; }
    .stat .sub{ margin-top:6px; color:var(--muted); font-size:13px; }

    .panel{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:22px;
      padding:14px;
      backdrop-filter: blur(10px);
    }

    .stage{
      position:relative;
      width:100%;
      aspect-ratio: 9/11;
      max-height: 820px;
      border-radius:22px;
      overflow:hidden;
      background:
        radial-gradient(900px 700px at 50% 20%, rgba(255,255,255,.08), transparent 62%),
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,0));
    }

    .scene{
      position:absolute; inset:0;
      display:flex; align-items:flex-end; justify-content:center;
      pointer-events:none;
      z-index:10;
    }
    .scene img{
      width:100%;
      height:100%;
      object-fit:contain;
      object-position: center bottom;
      user-select:none;
      -webkit-user-drag:none;
    }

    .targetCluster{
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      top: 10%;
      width:min(520px, 92%);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
      pointer-events:none;
      z-index:30;
    }
    .targetLabel{
      background:rgba(0,0,0,.40);
      border:1px solid rgba(255,255,255,.16);
      border-radius:999px;
      padding:10px 16px;
      font-weight:900;
      letter-spacing:.18em;
      text-indent:.18em;
      text-transform:uppercase;
      max-width:92%;
      overflow:hidden;
      white-space:nowrap;
      text-overflow:ellipsis;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .bubbleWrap{
      position:relative;
      width:min(360px, 72%);
      aspect-ratio: 3 / 2;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.28));
    }
    .bubbleWrap img.bubble{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:contain;
      user-select:none;
      -webkit-user-drag:none;
    }
    .bubbleFood{
      position:absolute;
      left:50%;
      top:33%;
      transform:translate(-50%, -50%);
      width:32%;
      height:auto;
      user-select:none;
      -webkit-user-drag:none;
      pointer-events:none;
    }

    /* BELT LANE — adjust this only if needed */
    .beltLane{
      position:absolute;
      left:0;
      width:100%;
      height:1px;
      top: 84%;
      pointer-events:none;
      z-index:20;
    }

    .food{
      position:absolute;
      top:0;
      transform: translate(-50%, -100%);
      width: 150px;
      height:auto;
      touch-action:none;
      user-select:none;
      -webkit-user-drag:none;
      z-index:25;
      filter: drop-shadow(0 10px 12px rgba(0,0,0,.25));
    }
    .food.dragging{ z-index:60; filter: drop-shadow(0 16px 18px rgba(0,0,0,.35)); }

    .dropZone{
      position:absolute;
      left:50%;
      top: 58.5%;
      transform:translate(-50%, -50%);
      width: 240px;
      height: 150px;
      border-radius:22px;
      pointer-events:none;
      z-index:26;
    }

    .toast{
      margin-top:12px;
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:18px;
      padding:14px 16px;
      color:var(--muted);
      line-height:1.35;
    }
    .rowBtns{ display:flex; gap:10px; margin-top:12px; }
    .ghost{
      flex:1;
      background:transparent;
      border:1px solid rgba(255,255,255,.16);
      color:rgba(255,255,255,.88);
      border-radius:18px;
      padding:12px 14px;
      font-weight:800;
      cursor:pointer;
    }

    .banner{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%, -50%);
      z-index:80;
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.18);
      padding:14px 16px;
      border-radius:18px;
      font-weight:900;
      letter-spacing:.08em;
      text-transform:uppercase;
      display:none;
    }
    .banner.show{ display:block; }

    @media (max-width:520px){
      .stats{ grid-template-columns: 1fr; }
      .stage{ aspect-ratio: 9/12; }
      .food{ width: 140px; }
      .dropZone{ width: 230px; height: 140px; }
      .targetCluster{ top: 8%; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="titleBox">
        <div class="titleLine">$PHAT — Conveyor Munch</div>
        <div class="subLine">Drag the correct snack into his mouth. Miss = pain. Streak = glory.</div>
      </div>
      <button class="btn" id="resetBtn">Run it back</button>
    </div>

    <div class="stats">
      <div class="stat">
        <h4>RUN</h4>
        <div class="big" id="runScore">0</div>
        <div class="sub" id="runSub">Streak: 0 · Speed: 1.00x</div>
      </div>
      <div class="stat">
        <h4>BEST</h4>
        <div class="big" id="bestScore">0</div>
        <div class="sub" id="bestSub">Daily best: 0</div>
      </div>
      <div class="stat">
        <h4>DAILY GOAL</h4>
        <div class="big" id="goalScore">0 / 30</div>
        <div class="sub" id="goalSub">Resets in <span id="resetIn">--:--:--</span></div>
      </div>
    </div>

    <div class="panel">
      <div class="stage" id="stage">
        <div class="scene">
          <img src="../assets/stack_scene.png" alt="scene" />
        </div>

        <div class="targetCluster">
          <div class="targetLabel" id="targetText">—</div>
          <div class="bubbleWrap">
            <img class="bubble" src="../assets/thought-bubble.png" alt="thought bubble" />
            <img class="bubbleFood" id="bubbleFood" src="" alt="target food"/>
          </div>
        </div>

        <div class="beltLane" id="beltLane"></div>
        <div class="dropZone" id="dropZone"></div>
        <div class="banner" id="banner">MISSED</div>
      </div>

      <div class="rowBtns">
        <button class="ghost" id="shareBtn">Share score</button>
        <button class="ghost" id="debugBtn">Toggle debug</button>
      </div>

      <div class="toast">
        <strong>How it plays:</strong> The thought bubble shows what he wants. The belt feeds a nonstop stream of snacks.
        Grab the correct one between the wrong choices and drag it to his mouth before it rolls away.
      </div>
    </div>
  </div>

<script>
(() => {
  const FOODS = [
    { key:'brownies',      name:'Brownies',         src:'../assets/food_brownies.png' },
    { key:'burger',        name:'Burger',           src:'../assets/food_burger.png' },
    { key:'cake',          name:'Cake',             src:'../assets/food_cake.png' },
    { key:'takeout',       name:'Takeout',          src:'../assets/food_chinese_takeout.png' },
    { key:'pizookie',      name:'Pizookie',         src:'../assets/food_cookie_pizza.png' },
    { key:'donut_stack',   name:'Donut Stack',      src:'../assets/food_donut_stack.png' },
    { key:'fried_chicken', name:'Fried Chicken',    src:'../assets/food_fried_chicken.png' },
    { key:'fries',         name:'Fries',            src:'../assets/food_fries.png' },
    { key:'grilledcheese', name:'Grilled Cheese',   src:'../assets/food_grilledcheese.png' },
    { key:'hotdogs',       name:'Hot Dogs',         src:'../assets/food_hotdogs.png' },
    { key:'icecream',      name:'Ice Cream',        src:'../assets/food_icecream_cone.png' },
    { key:'shake_choc',    name:'Chocolate Shake',  src:'../assets/food_milkshake_chocolate.png' },
    { key:'shake_straw',   name:'Strawberry Shake', src:'../assets/food_milkshake_strawberry.png' },
    { key:'shake_van',     name:'Vanilla Shake',    src:'../assets/food_milkshake_vanilla.png' },
    { key:'onion_rings',   name:'Onion Rings',      src:'../assets/food_onion_rings.png' },
    { key:'pancakes',      name:'Pancakes',         src:'../assets/food_pancakes.png' },
    { key:'pizza_stack',   name:'Pizza',            src:'../assets/food_pizza_stack.png' },
    { key:'popcorn',       name:'Popcorn',          src:'../assets/food_popcorn.png' },
    { key:'soda',          name:'Soda',             src:'../assets/food_soda.png' },
    { key:'sub',           name:'Sub',              src:'../assets/food_sub.png' },
  ];

  const stage      = document.getElementById('stage');
  const beltLane   = document.getElementById('beltLane');
  const dropZoneEl = document.getElementById('dropZone');
  const banner     = document.getElementById('banner');

  const targetText = document.getElementById('targetText');
  const bubbleFood = document.getElementById('bubbleFood');

  const runScoreEl = document.getElementById('runScore');
  const runSubEl   = document.getElementById('runSub');
  const bestEl     = document.getElementById('bestScore');
  const goalEl     = document.getElementById('goalScore');

  const resetBtn = document.getElementById('resetBtn');
  const shareBtn = document.getElementById('shareBtn');
  const debugBtn = document.getElementById('debugBtn');
  const resetInEl = document.getElementById('resetIn');

  let debug = false;

  let foodsOnBelt = []; // {id, def, el, x}
  let nextId = 1;

  let running = true;
  let streak = 0;
  let score = 0;
  let speedMult = 1.00;

  // PRESSURE TUNING
  const baseSpeed = 160;
  const speedStep = 0.045;
  const speedCap  = 2.25;

  const targetFlowCount = 8;    // aim ~8 on belt
  const maxOnScreen = 10;
  const minGap = 200;           // safe spacing to reduce mis-grab overlap
  const spawnEveryMs = 330;
  let acc = 0;

  const targetMustAppearWithinMs = 1400;
  let targetSetAt = 0;

  let activeDrag = null; // {food, offsetX, offsetY}
  let lastPointerId = null;

  const goalTarget = 30;

  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
  function stageRect(){ return stage.getBoundingClientRect(); }
  function laneY(){
    const s = stageRect();
    const r = beltLane.getBoundingClientRect();
    return (r.top - s.top);
  }

  const todayKey = () => {
    const d = new Date();
    return `phat_snack_best_${d.getFullYear()}_${d.getMonth()+1}_${d.getDate()}`;
  };
  const loadBest = () => +localStorage.getItem(todayKey()) || 0;
  const saveBest = (v) => localStorage.setItem(todayKey(), String(v));
  let best = loadBest();
  bestEl.textContent = best;

  function updateHUD(){
    runScoreEl.textContent = score;
    runSubEl.textContent = `Streak: ${streak} · Speed: ${speedMult.toFixed(2)}x`;
    goalEl.textContent = `${Math.min(score, goalTarget)} / ${goalTarget}`;
  }

  function setBanner(text, cssColor){
    banner.textContent = text;
    banner.style.color = cssColor || '#fff';
    banner.classList.add('show');
    setTimeout(() => banner.classList.remove('show'), 800);
  }

  function pickTarget(){
    const def = FOODS[Math.floor(Math.random()*FOODS.length)];
    targetText.textContent = def.name.toUpperCase(); // no truncation like "STRAWBERRY"
    bubbleFood.src = def.src;
    targetSetAt = performance.now();
    return def;
  }

  let currentTarget = pickTarget();

  function canSpawnAt(x){
    for (const f of foodsOnBelt){
      if (Math.abs(f.x - x) < minGap) return false;
    }
    return true;
  }

  function spawnFood(forceTarget=false){
    if (!running) return false;
    if (foodsOnBelt.length >= maxOnScreen) return false;

    const s = stageRect();
    const y = laneY();

    let def;
    if (forceTarget){
      def = currentTarget;
    } else {
      const roll = Math.random();
      if (roll < 0.24) def = currentTarget;
      else {
        do { def = FOODS[Math.floor(Math.random()*FOODS.length)]; }
        while(def.key === currentTarget.key && Math.random() < 0.75);
      }
    }

    // Try a few candidate spawn X positions
    let x = null;
    for (let tries=0; tries<6; tries++){
      const candidate = s.width + 140 + Math.random()*120;
      if (canSpawnAt(candidate)){
        x = candidate;
        break;
      }
    }
    if (x === null) return false;

    const el = document.createElement('img');
    el.className = 'food';
    el.src = def.src;
    el.alt = def.name;
    el.draggable = false;
    el.style.left = `${x}px`;
    el.style.top  = `${y}px`;

    const id = nextId++;
    el.addEventListener('pointerdown', (e) => onPointerDown(e, id));

    stage.appendChild(el);
    foodsOnBelt.push({ id, def, el, x });

    if (debug){
      el.style.outline = (def.key === currentTarget.key)
        ? '2px solid rgba(109,255,179,.85)'
        : '2px solid rgba(255,255,255,.14)';
    } else {
      el.style.outline = 'none';
    }

    return true;
  }

  // ✅ SAFE: bounded attempts (no infinite loops => no Safari crash)
  function fillBelt(){
    if (!running) return;
    const need = Math.max(0, targetFlowCount - foodsOnBelt.length);
    if (need === 0) return;

    let spawned = 0;
    let attempts = 0;
    const maxAttempts = 22; // hard cap per call

    while (spawned < need && attempts < maxAttempts){
      attempts++;
      if (spawnFood(false)) spawned++;
    }
  }

  function ensureTargetSoon(){
    const now = performance.now();
    if ((now - targetSetAt) > targetMustAppearWithinMs){
      // Try a few times to force-spawn target (bounded)
      for (let i=0;i<6;i++){
        if (spawnFood(true)) break;
      }
      targetSetAt = now;
    }
  }

  function removeFood(food){
    try { food.el.remove(); } catch {}
    foodsOnBelt = foodsOnBelt.filter(f => f.id !== food.id);
  }

  function gameOver(){
    if (!running) return;
    running = false;
    setBanner('MISSED', getComputedStyle(document.documentElement).getPropertyValue('--bad'));
    activeDrag = null;
    lastPointerId = null;
  }

  function winCorrect(food){
    const s = stageRect();
    const z = dropZoneEl.getBoundingClientRect();
    const targetX = (z.left - s.left) + (z.width/2);
    const targetY = (z.top  - s.top ) + (z.height/2);

    food.el.style.transition = 'left 140ms ease, top 140ms ease, transform 140ms ease, opacity 140ms ease';
    food.el.style.left = `${targetX}px`;
    food.el.style.top  = `${targetY}px`;
    food.el.style.transform = 'translate(-50%, -50%) scale(.65)';
    food.el.style.opacity = '0.25';
    setTimeout(() => removeFood(food), 160);

    score += 1;
    streak += 1;

    speedMult = clamp(speedMult + speedStep, 1.00, speedCap);

    currentTarget = pickTarget();

    if (score > best){
      best = score;
      bestEl.textContent = best;
      saveBest(best);
    }

    updateHUD();
    setBanner('NICE', getComputedStyle(document.documentElement).getPropertyValue('--good'));

    fillBelt();
    ensureTargetSoon();
  }

  function onPointerDown(e, id){
    if (!running) return;
    const food = foodsOnBelt.find(f => f.id === id);
    if (!food) return;

    lastPointerId = e.pointerId;
    food.el.classList.add('dragging');

    const s = stageRect();
    const r = food.el.getBoundingClientRect();
    const offsetX = (e.clientX - r.left) - r.width/2;
    const offsetY = (e.clientY - r.top ) - r.height/2;

    activeDrag = { food, offsetX, offsetY };
    food.el.setPointerCapture(e.pointerId);
    e.preventDefault();
  }

  function onPointerMove(e){
    if (!activeDrag || e.pointerId !== lastPointerId) return;
    const { food, offsetX, offsetY } = activeDrag;
    const s = stageRect();

    const x = (e.clientX - s.left) - offsetX;
    const y = (e.clientY - s.top ) - offsetY;

    food.el.style.transition = 'none';
    food.el.style.left = `${x}px`;
    food.el.style.top = `${y}px`;
    food.el.style.transform = 'translate(-50%, -50%)';
  }

  function onPointerUp(e){
    if (!activeDrag || e.pointerId !== lastPointerId) return;

    const { food } = activeDrag;
    activeDrag = null;
    lastPointerId = null;

    food.el.classList.remove('dragging');

    const fRect = food.el.getBoundingClientRect();
    const zRect = dropZoneEl.getBoundingClientRect();
    const fCx = fRect.left + fRect.width/2;
    const fCy = fRect.top  + fRect.height/2;

    const inZone = (fCx >= zRect.left && fCx <= zRect.right && fCy >= zRect.top && fCy <= zRect.bottom);

    if (!inZone){
      const y = laneY();
      food.el.style.transition = 'top 120ms ease, transform 120ms ease';
      food.el.style.top = `${y}px`;
      food.el.style.transform = 'translate(-50%, -100%)';
      return;
    }

    if (food.def.key !== currentTarget.key){
      gameOver();
      return;
    }

    winCorrect(food);
  }

  stage.addEventListener('pointermove', onPointerMove);
  stage.addEventListener('pointerup', onPointerUp);
  stage.addEventListener('pointercancel', onPointerUp);

  let lastT = performance.now();
  function loop(now){
    const dt = (now - lastT) / 1000;
    lastT = now;

    if (running){
      const y = laneY();

      for (const f of foodsOnBelt){
        if (activeDrag && activeDrag.food.id === f.id) continue;
        f.x -= (baseSpeed * speedMult) * dt;
        f.el.style.left = `${f.x}px`;
        f.el.style.top  = `${y}px`;
        f.el.style.transform = 'translate(-50%, -100%)';
      }

      // Remove offscreen; target miss ends game
      for (const f of [...foodsOnBelt]){
        if (f.x < -180){
          if (f.def.key === currentTarget.key){
            gameOver();
            break;
          } else {
            removeFood(f);
          }
        }
      }

      acc += dt * 1000;

      // bounded upkeep (safe)
      fillBelt();
      ensureTargetSoon();

      if (acc >= spawnEveryMs){
        acc = 0;
        spawnFood(false);
      }
    }

    requestAnimationFrame(loop);
  }

  function reset(){
    running = true;
    streak = 0;
    score = 0;
    speedMult = 1.00;
    currentTarget = pickTarget();
    updateHUD();

    for (const f of [...foodsOnBelt]) removeFood(f);

    // Prime belt (bounded; safe)
    for (let i=0;i<8;i++){
      spawnFood(i===2); // inject target early
    }
    fillBelt();
    ensureTargetSoon();
  }

  function share(){
    const txt = `$PHAT Conveyor Munch — ${score} correct · streak ${streak} · speed ${speedMult.toFixed(2)}x\nplanetfatness.fit/snack`;
    if (navigator.share){
      navigator.share({ text: txt }).catch(()=>{});
    } else {
      navigator.clipboard?.writeText(txt);
      setBanner('COPIED', '#fff');
    }
  }

  function timeToMidnight(){
    const n = new Date();
    const m = new Date(n);
    m.setHours(24,0,0,0);
    return m - n;
  }
  function fmt(ms){
    ms = Math.max(0, ms);
    const s = Math.floor(ms/1000);
    const hh = String(Math.floor(s/3600)).padStart(2,'0');
    const mm = String(Math.floor((s%3600)/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return `${hh}:${mm}:${ss}`;
  }
  setInterval(() => resetInEl.textContent = fmt(timeToMidnight()), 250);

  debugBtn.addEventListener('click', () => {
    debug = !debug;
    for (const f of foodsOnBelt){
      f.el.style.outline = debug
        ? (f.def.key===currentTarget.key ? '2px solid rgba(109,255,179,.85)' : '2px solid rgba(255,255,255,.14)')
        : 'none';
    }
    setBanner(debug ? 'DEBUG ON' : 'DEBUG OFF', '#fff');
  });

  resetBtn.addEventListener('click', reset);
  shareBtn.addEventListener('click', share);

  reset();
  requestAnimationFrame(loop);
})();
</script>

</body>
</html>